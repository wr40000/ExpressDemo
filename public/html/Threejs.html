<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="http://139.159.253.241:3000/stylesheets/github.css">
    <title>Document</title>
</head>
<body>
    <h1>资源网站</h1>
<p>webgl文档： <a href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-fundamentals.html">WebGL 基础概念 (webglfundamentals.org)</a></p>
<p>glsl文档： <a href="https://github.com/littlelogic/GLSL-Card/blob/master/README.md">GLSL-Card/README.md at master · littlelogic/GLSL-Card (github.com)</a></p>
<h1>导入时的一些问题</h1>
<p><strong>HTML文档引入JS模块出现路径问题</strong></p>
<p>前言
JS抽离, 引入three模块.
LiveServer报错:</p>
<p>Uncaught TypeError: Failed to resolve module specifier &quot;three&quot;.
Relative references must start with either &quot;/&quot;, &quot;./&quot;, or &quot;../&quot;.
1
2
事实上我已经数不清这是第多少次遇到这种问题了, 用HTML文档写一些库的案例, 然后各种引入报错, 找不到包之类.
只是这次的问题解决让我印象颇深, 也收获颇丰.</p>
<h2>一、错误情况</h2>
<h3>three引入</h3>
<p>html:</p>
<script src="./js/main.js" type="module"></script>
<p>JavaScript:</p>
<pre><code class="language-js">import * as THREE from &#39;three&#39;;
import { OrbitControls } from &#39;three/addons/controls/OrbitControls.js&#39;;
</code></pre>
<h3>gsap引入</h3>
<p>没有在html文档做操作, 直接npm下包在js文件引入:</p>
<pre><code class="language-js">import gsap from &#39;gsap&#39;;
</code></pre>
<p>结果就是两个都没能成功引入.</p>
<p>二、解决办法
路径没有写错, 只能说打包之后路径错误找不到某个模块了.</p>
<p>当导入JavaScript模块时, import语句和import()运算符都有一个&quot;<strong>模块标识符</strong>&quot;, 其指示要导入的模块. 浏览器根据此标识符解析出绝对路径, 才能成功导入.</p>
<p>导入映射（import map）是一个 JSON 对象, 其允许开发者在导入 JavaScript 模块时, 控制浏览器如何解析模块标识符. 它提供了在 import 语句或 import() 运算符中用作模块标识符的文本, 其会在解析标识符时与要替换的文本之间建立映射.</p>
<p><strong>在HTML文件增加以下来协助浏览器正确解析模块标识符, 这段代码可以在three.js源码的example任意一个案例中找到.</strong>
第一个映射修正three模块的路径, 第二个修正OrbitControls等附加模块的路径.</p>
<script type="importmap">
  {
    "imports": {
      "three": "../../node_modules/three/build/three.module.js",
      "three/addons/": "../../node_modules/three/examples/jsm/"
    }
  }
</script>

<p><strong>three的引入问题在于路径错误</strong>, LiveServer最后是需要找到three.module.js, three的其他附加模块需要找到jsm.
OrbitControls这种不在three.module.js内的模块导入, 可以在不配置importmap内three/addons/的情况下:</p>
<pre><code class="language-js">import { OrbitControls } from &#39;../../node_modules/three/examples/jsm/controls/OrbitControls.js&#39;;
</code></pre>
<p>实际上就是把importmap里的内容直接写到了js里.</p>
<p>但是对于three.module.js这种一次性导出多个类的文件就只能写在importmap里了.</p>
<p>gsap引入失败的问题在于HTML文档里是不能直接这样:</p>
<pre><code class="language-js">import gsap from &#39;gsap&#39;;
</code></pre>
<p>引入使用的.</p>
<p>需要先配置importmap:</p>
<script type="importmap">
  {
    "imports": {
      "gsap": "../../node_modules/gsap/index.js"
    }
  }
</script>

<p>然后再:</p>
<pre><code class="language-js">import { gsap } from &#39;gsap&#39;;
</code></pre>
<p>路径不固定, 只要引导到index.js即可.</p>
<p>或者不配置importmap, 直接js文件里这样写:</p>
<pre><code class="language-js">import { gsap } from &#39;../../node_modules/gsap/index.js&#39;;
</code></pre>
<pre><code>————————————————
版权声明：本文为CSDN博主「白瑕」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_52697994/article/details/131164740
</code></pre>
<p>一些报错</p>
<p>importmap</p>
<p>不行就别映射了，用绝对地址或者相对地址</p>
<p>一些细节</p>
<p><strong>注意使用</strong></p>
<script type="module"><script>
还有种可能，导入的外部资源链接不合适：

```
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
<pre><code>


# Three.js Journey

## 大纲

01
基础知识
创建您的第一个场景，并了解相机、几何图形、材质和纹理等基本原理。
添加一个调试面板来调整环境并设置所有内容的动画。
02
经典技术
使用各种灯光照亮场景，开始练习环境创建并创建数百万个粒子。
03
先进的技术
将物理学添加到你的世界中，让物体开始碰撞和绊倒。然后导入用Blender制作的自己的模型，使其看起来尽可能逼真。
04
着色器
使用Three.js材质很棒，但创建自己的材质更好。
学习着色器语言，释放WebGL的真正力量，创造令人惊叹的体验！
05
额外的
一旦了解了着色器，就有机会进一步尝试新技术。
但同样重要的是，通过监控和优化性能，确保您的项目在大多数设备上运行。
06
门户网站场景
了解如何使用Blender创建一个很酷的场景，并了解烘焙技术以获得最佳外观的灯光和阴影。

## 安装
</code></pre>
<pre><code>


## 位置

```js
mesh.position.length()

mesh.position.distanceTo(camera.position)

mesh.position.normalize()

mesh.position.set(0.7, - 0.6, 1)
</code></pre>
<h2>缩放</h2>
<pre><code>mesh.scale.x = 2
mesh.scale.y = 0.25
mesh.scale.z = 0.5 
</code></pre>
<h2>旋转</h2>
<pre><code>mesh.rotation.x = Math.PI * 0.25
mesh.rotation.y = Math.PI * 0.25
</code></pre>
<h2>坐标轴</h2>
<pre><code class="language-javascript">const axesHelper = new THREE.AxesHelper(2)
scene.add(axesHelper)
</code></pre>
<h2>组</h2>
<pre><code class="language-js">/**
* Objects
*/
const group = new THREE.Group()
group.scale.y = 2
group.rotation.y = 0.2
scene.add(group)

const cube1 = new THREE.Mesh(
new THREE.BoxGeometry(1, 1, 1),
new THREE.MeshBasicMaterial({ color: 0xff0000 })
)
cube1.position.x = - 1.5
group.add(cube1)

const cube2 = new THREE.Mesh(
new THREE.BoxGeometry(1, 1, 1),
new THREE.MeshBasicMaterial({ color: 0xff0000 })
)
cube2.position.x = 0
group.add(cube2)

const cube3 = new THREE.Mesh(
new THREE.BoxGeometry(1, 1, 1),
new THREE.MeshBasicMaterial({ color: 0xff0000 })
)
cube3.position.x = 1.5
group.add(cube3)
</code></pre>
<h2>动画</h2>
<pre><code class="language-js">/**
* Animate
*/
const tick = () =&gt;
{
// Update objects
mesh.rotation.y += 0.01

// Render
renderer.render(scene, camera)

// Call tick again on the next frame
window.requestAnimationFrame(tick)
}

tick()
</code></pre>
<h3>适应帧率</h3>
<pre><code class="language-js">/**
* Animate 我们将旋转基于自最后一帧以来花费的时间，无论帧速率如何，此旋转速度在每个屏幕和每台计算机上都是相同的。
*/
let time = Date.now()

const tick = () =&gt;
{
// Time
const currentTime = Date.now()
const deltaTime = currentTime - time
time = currentTime

// Update objects
mesh.rotation.y += 0.01 * deltaTime

// ...
}

tick()
</code></pre>
<p>实例化一个 <a href="https://threejs.org/docs/#api/en/core/Clock">Clock</a> 变量并使用内置方法，例如 .此方法将返回自<a href="https://threejs.org/docs/#api/en/core/Clock">创建时钟</a>以来经过的秒数。<code>getElapsedTime()</code></p>
<pre><code class="language-js">/**
* Animate
*/
const clock = new THREE.Clock()

const tick = () =&gt;
{
const elapsedTime = clock.getElapsedTime()

// Update objects
mesh.rotation.y = elapsedTime

// ...
}

tick()
</code></pre>
<h3>GSAP动画库</h3>
<pre><code class="language-js">/**
* Animate
*/
gsap.to(mesh.position, { duration: 1, delay: 1, x: 2 })

const tick = () =&gt;
{
// Render
renderer.render(scene, camera)

// Call tick again on the next frame
window.requestAnimationFrame(tick)
}

tick()
</code></pre>
<h2>相机</h2>
<pre><code class="language-js">const sizes = {
    width: 800,
    height: 600
}

const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 1, 100)
</code></pre>
<pre><code class="language-js">left right top bottom near far

const camera = new THREE.OrthographicCamera(- 1, 1, 1, - 1, 0.1, 100)

//我们需要使用画布比例（宽度与高度）。让我们创建一个名为（就像 PerspectiveCamera 一样）的变量并将该比率存储在其中：aspectRatio


const aspectRatio = sizes.width / sizes.height
const camera = new THREE.OrthographicCamera(- 1 * aspectRatio, 1 * aspectRatio, 1, - 1, 0.1, 100)
</code></pre>
<h2>控件</h2>
<pre><code class="language-js">// Cursor
const cursor = {
    x: 0,
    y: 0
}

//这是由于在 Three 中向上移动时轴为正.js但在网页中向下移动时轴为正。position.yclientY

//您可以通过在整个公式前面添加一个来简单地反转更新它（不要忘记括号）：cursor.y-

window.addEventListener(&#39;mousemove&#39;, (event) =&gt;
{
    cursor.x = event.clientX / sizes.width - 0.5
    cursor.y = - (event.clientY / sizes.height - 0.5)
})
</code></pre>
<pre><code class="language-js">import { OrbitControls } from &#39;three/examples/jsm/controls/OrbitControls.js&#39;

// Controls
const controls = new OrbitControls(camera, canvas)
controls.enableDamping = true  // 阻尼
</code></pre>
<h2>圆周旋转</h2>
<pre><code class="language-js">const tick = () =&gt;
{
    // ...

    // Update camera
    camera.position.x = Math.sin(cursor.x * Math.PI * 2) * 2
    camera.position.z = Math.cos(cursor.x * Math.PI * 2) * 2
    camera.position.y = cursor.y * 3
    camera.lookAt(mesh.position)

    // ...
}

tick()
</code></pre>
<pre><code class="language-js">let now = performance.now()

spotLight.target.position.x = Math.sin(now /1500) * 0.75
spotLight.target.position.z = Math.cos(now /1500) * 0.75
</code></pre>
<h2>窗口适应&amp;处理像素比</h2>
<pre><code class="language-js">window.addEventListener(&#39;resize&#39;, () =&gt;
{
    // Update sizes
    sizes.width = window.innerWidth
    sizes.height = window.innerHeight

    // Update camera
    camera.aspect = sizes.width / sizes.height
    camera.updateProjectionMatrix()

    // Update renderer
    renderer.setSize(sizes.width, sizes.height)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
})
</code></pre>
<h3>全屏</h3>
<pre><code class="language-js">window.addEventListener(&#39;dblclick&#39;, () =&gt;
{
    if(!document.fullscreenElement)
    {
        canvas.requestFullscreen()
    }
    else
    {
        document.exitFullscreen()
    }
})
</code></pre>
<h2>几何</h2>
<pre><code class="language-js">const geometry = new THREE.BoxGeometry(1, 1, 1, 2, 2, 2)
const material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
</code></pre>
<h3>缓冲区几何图形</h3>
<pre><code class="language-js">// Create an empty BufferGeometry
const geometry = new THREE.BufferGeometry()
</code></pre>
<p>要将顶点添加到 <a href="https://threejs.org/docs/#api/en/core/BufferGeometry">BufferGeometry</a>，您必须从 <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Float32Array">Float32Array</a> 开始。</p>
<pre><code class="language-js">const positionsArray = new Float32Array(9)

// First vertice
positionsArray[0] = 0
positionsArray[1] = 0
positionsArray[2] = 0

// Second vertice
positionsArray[3] = 0
positionsArray[4] = 1
positionsArray[5] = 0

// Third vertice
positionsArray[6] = 1
positionsArray[7] = 0
positionsArray[8] = 0
</code></pre>
<p>或者传递一个数组：</p>
<pre><code class="language-js">const positionsArray = new Float32Array([
0, 0, 0, // First vertex
0, 1, 0, // Second vertex
1, 0, 0  // Third vertex
])
</code></pre>
<p>在将该数组发送到 <a href="https://threejs.org/docs/#api/en/core/BufferGeometry">BufferGeometry</a> 之前，必须将其转换为 <a href="https://threejs.org/docs/#api/en/core/BufferAttribute">BufferAttribute</a>。</p>
<p>第一个参数对应于类型化数组，第二个参数对应于构成一个顶点属性的值量。要读取这个数组，我们必须 3 x 3，因为顶点位置由 3 个值 （和 ） 组成：<code>x``y``z</code></p>
<pre><code class="language-js">const positionsAttribute = new THREE.BufferAttribute(positionsArray, 3)
</code></pre>
<p>然后，我们可以使用该方法将此属性添加到我们的 <a href="https://threejs.org/docs/#api/en/core/BufferGeometry">BufferGeometry</a> 中。第一个参数是此属性的名称，第二个参数是值：<code>setAttribute(...)</code></p>
<pre><code class="language-js">geometry.setAttribute(&#39;position&#39;, positionsAttribute)
</code></pre>
<h2>GUI</h2>
<h3>Dat</h3>
<pre><code class="language-js">import * as dat from &#39;lil-gui&#39;

// 实例化
const gui = new dat.GUI()
</code></pre>
<pre><code class="language-js">Range —for numbers with minimum and maximum value
Color —for colors with various formats
Text —for simple texts
Checkbox —for booleans ( or truefalse)
Select —for a choice from a list of values
Button —to trigger functions
Folder —to organize your panel if you have too many elements
</code></pre>
<pre><code class="language-js">gui.add(mesh.position, &#39;y&#39;, - 3, 3, 0.01)

gui
    .add(mesh.position, &#39;y&#39;)
    .min(- 3)
    .max(3)
    .step(0.01)
    .name(&#39;elevation&#39;)

gui.add(mesh, &#39;visible&#39;)
gui.add(material, &#39;wireframe&#39;)
</code></pre>
<h3>二级菜单</h3>
<pre><code class="language-js">const spot = gui.addFolder(&quot;spotLight&quot;)
spot.add(spotLight.target.position, &#39;x&#39;)
    .min(0).max(10).step(0.001)
    .name(&quot;spot.pos.x&quot;)
spot.add(spotLight, &#39;intensity&#39;)
    .min(0).max(10).step(0.001)
    .name(&quot;spot-intensity&quot;)
spot.add(spotLight, &#39;distance&#39;)
    .min(0).max(10).step(0.001)
    .name(&quot;spot-distance&quot;)
spot.add(spotLight, &#39;angle&#39;)
    .min(0).max(Math.PI * 0.3).step(0.001*Math.PI)
    .name(&quot;spot-angle&quot;)
spot.add(spotLight, &#39;penumbra&#39;) // 聚光锥的半影衰减百分比。默认值为 0。
    .min(0).max(1).step(0.001)
    .name(&quot;spot-penumbra&quot;)
</code></pre>
<h3>color</h3>
<pre><code class="language-js">const parameters = {
    color: 0xff0000
}


const material = new THREE.MeshBasicMaterial({ color: parameters.color })
// ...

gui
    .addColor(parameters, &#39;color&#39;)
    .onChange(() =&gt;
    {
        material.color.set(parameters.color)
    })
</code></pre>
<h3>checkBox</h3>
<pre><code class="language-js">gui
    .add(renderer, &#39;toneMapping&#39;, {
        No: THREE.NoToneMapping,
        Linear: THREE.LinearToneMapping,
        Reinhard: THREE.ReinhardToneMapping,
        Cineon: THREE.CineonToneMapping,
        ACESFilmic: THREE.ACESFilmicToneMapping
    })
    .onFinishChange(() =&gt;
    {
        renderer.toneMapping = Number(renderer.toneMapping)
        updateAllMaterials()
    })
</code></pre>
<h3>动画</h3>
<pre><code class="language-js">const parameters = {
    color: 0xff0000,
    spin: () =&gt;
    {
        gsap.to(mesh.rotation, { duration: 1, y: mesh.rotation.y + Math.PI * 2 })
    }
}

gui.add(parameters, &#39;spin&#39;)
</code></pre>
<h3>下拉框控件</h3>
<pre><code class="language-js">var testObj = {
    type: &quot;two&quot;,
    speed: 50,
};

var gui = new dat.GUI();
var f = gui.addFolder(&#39;下拉框类型&#39;);
f.add(testObj, &quot;type&quot;, [&#39;one&#39;, &#39;two&#39;, &#39;三&#39;]);
f.add(testObj, &quot;speed&quot;, {slow: 1, &#39;中速&#39;: 20, fast: 50});
f.open();
</code></pre>
<h3>双向控制</h3>
<p>gui能够很轻松的实现单向控制（gui控制视图区域的动画，位置等），但是如果调节视图区域中的节点位置，并不会影响gui上的变化。</p>
<p><img src="http://139.159.253.241/images/Threejs.assets/v2-1a3fc457454fcadceb8a9fd8acbad05f_b.gif" alt="动图"></p>
<p>其实，gui中内置了一个setValue()方法去设置gui中的值，初步思路已经明了了，当视图区域位置信息发生变化时，就调用此方法对gui进行设置即可。在vue框架中，实现数据双向绑定的机制是数据劫持（），我们利用这个方式，来实现gui与视图区的双向控制。</p>
<pre><code class="language-js">function observe(data) {
    if (!data || typeof data !== &#39;object&#39;) {
        return;
    }
    // 取出所有属性遍历
    Object.keys(data).forEach(function (key) {
        defineReactive(data, key, data[key]);
    });
};

function defineReactive(data, key, val) {
    observe(val); // 监听子属性
    Object.defineProperty(data, key, {
        enumerable: false, // 可枚举
        configurable: false, // 不能再define
        get: function () {
            return val;
        },
        set: function (newVal) {
            console.log(&#39;哈哈哈，监听到值变化了 &#39;, val, &#39; --&gt; &#39;, newVal);
            val = newVal;
        }
    });
}
</code></pre>
<p>我们通过上面两个方法，能够监听到数据的变化，我们在set方法中进行操作即可。</p>
<p><img src="http://139.159.253.241/images/Threejs.assets/v2-05b8c0ac96ca0e8be967891816b34481_b.jpg" alt="动图封面"></p>
<h3>GUI样式</h3>
<pre><code class="language-js">gui.hide()

const gui = new dat.GUI({ closed: true })

const gui = new dat.GUI({ width: 400 })
</code></pre>
<h2>性能插件</h2>
<pre><code class="language-js">// stats-js

import Stats from &#39;three/examples/jsm/libs/stats.module.js&#39;

let stats: any = new Stats()

// // 设置监视器面板，传入面板id（0: fps, 1: ms, 2: mb）
stats.setMode(0)

// // 设置监视器位置
stats.domElement.style.position = &#39;absolute&#39;
stats.domElement.style.left = &#39;0px&#39;
stats.domElement.style.top = &#39;0px&#39;
// 将监视器添加到页面中
document.body.appendChild(stats.domElement)
</code></pre>
<h2>纹理 texture</h2>
<p>使用 <a href="https://threejs.org/docs/#api/en/textures/Texture">Texture</a> 类创建纹理</p>
<pre><code class="language-js">const image = new Image()
const texture = new THREE.Texture(image)
image.addEventListener(&#39;load&#39;, () =&gt;
{
    texture.needsUpdate = true
})
image.src = &#39;/textures/door/color.jpg&#39;

const material = new THREE.MeshBasicMaterial({ map: texture })
</code></pre>
<h3>TextureLoader</h3>
<pre><code class="language-javascript">const textureLoader = new THREE.TextureLoader()
const texture = textureLoader.load(&#39;/textures/door/color.jpg&#39;)
</code></pre>
<ul>
<li><code>load</code>当图像成功加载时</li>
<li><code>progress</code>加载过程中</li>
<li><code>error</code>如果出现问题</li>
</ul>
<pre><code class="language-js">const textureLoader = new THREE.TextureLoader()
const texture = textureLoader.load(
    &#39;/textures/door/color.jpg&#39;,
    () =&gt;
    {
        console.log(&#39;loading finished&#39;)
    },
    () =&gt;
    {
        console.log(&#39;loading progressing&#39;)
    },
    () =&gt;
    {
        console.log(&#39;loading error&#39;)
    }
)
</code></pre>
<h3><a href="https://threejs.org/docs/index.html#api/en/loaders/managers/LoadingManager">LoadManager</a></h3>
<p>创建 <a href="https://threejs.org/docs/index.html#api/en/loaders/managers/LoadingManager">LoadManager</a> 类的实例并将其传递给 <a href="https://threejs.org/docs/index.html#api/en/loaders/TextureLoader">TextureLoader</a>：</p>
<pre><code class="language-javascript">const loadingManager = new THREE.LoadingManager()
const textureLoader = new THREE.TextureLoader(loadingManager)
</code></pre>
<p>加载所需的所有图像</p>
<pre><code class="language-javascript">const colorTexture = textureLoader.load(&#39;/textures/door/color.jpg&#39;)
const alphaTexture = textureLoader.load(&#39;/textures/door/alpha.jpg&#39;)
const heightTexture = textureLoader.load(&#39;/textures/door/height.jpg&#39;)
const normalTexture = textureLoader.load(&#39;/textures/door/normal.jpg&#39;)
const ambientOcclusionTexture = textureLoader.load(&#39;/textures/door/ambientOcclusion.jpg&#39;)
const metalnessTexture = textureLoader.load(&#39;/textures/door/metalness.jpg&#39;)
const roughnessTexture = textureLoader.load(&#39;/textures/door/roughness.jpg&#39;)
</code></pre>
<pre><code class="language-javascript">const material = new THREE.MeshBasicMaterial({ map: colorTexture })
</code></pre>
<pre><code class="language-javascript">const colorTexture = textureLoader.load(&#39;/textures/door/color.jpg&#39;)
colorTexture.repeat.x = 2
colorTexture.repeat.y = 3
</code></pre>
<pre><code>grassColorTexture.repeat.set(8, 8)：这一行代码设置了 grassColorTexture（草地颜色贴图）在 u 轴和 v 轴方向上的重复次数，将贴图在横向和纵向上重复显示 8 次。这会使贴图在模型表面重复呈现，产生更自然的效果，就像草地一样。
</code></pre>
<ul>
<li><code>wrapS</code>用于轴<code>x</code></li>
<li><code>wrapT</code>用于轴<code>y</code></li>
</ul>
<pre><code>grassColorTexture.wrapS = THREE.RepeatWrapping：这一行设置 grassColorTexture 在 u 轴（水平方向）上的包裹方式为 RepeatWrapping，这意味着当贴图的坐标超出了 [0, 1] 的范围时，它会在重复方向上重复显示。
</code></pre>
<pre><code class="language-javascript">colorTexture.wrapS = THREE.RepeatWrapping
colorTexture.wrapT = THREE.RepeatWrapping
</code></pre>
<pre><code class="language-javascript">colorTexture.wrapS = THREE.MirroredRepeatWrapping
colorTexture.wrapT = THREE.MirroredRepeatWrapping
</code></pre>
<pre><code class="language-javascript">colorTexture.offset.x = 0.5
colorTexture.offset.y = 0.5
</code></pre>
<pre><code class="language-javascript">colorTexture.rotation = Math.PI * 0.25

// 以该点为中心旋转
colorTexture.center.x = 0.5  
colorTexture.center.y = 0.5
</code></pre>
<h3></h3>
<h3><a href="https://threejs.org/docs/index.html?q=Texture#api/zh/constants/Textures">放大滤镜（Magnification Filters）</a></h3>
<pre><code>THREE.NearestFilter
THREE.LinearFilter
这些常量用于纹理的magFilter属性，它们定义了当被纹理化的像素映射到小于或者等于1纹理元素（texel）的区域时，将要使用的纹理放大函数。

NearestFilter返回与指定纹理坐标（在曼哈顿距离之内）最接近的纹理元素的值。

LinearFilter是默认值，返回距离指定的纹理坐标最近的四个纹理元素的加权平均值， 并且可以包含纹理的其他部分中，被包裹或者被重复的项目，具体取决于 wrapS 和 wrapT 的值，and on the exact mapping。
</code></pre>
<h3>缩小滤镜（Minification Filters）</h3>
<pre><code>这些常量用于纹理的minFilter属性，它们定义了当被纹理化的像素映射到大于1纹理元素（texel）的区域时，将要使用的纹理缩小函数。

除了NearestFilter 和 LinearFilter， 下面的四个函数也可以用于缩小：

NearestMipmapNearestFilter选择与被纹理化像素的尺寸最匹配的mipmap， 并以NearestFilter（最靠近像素中心的纹理元素）为标准来生成纹理值。

NearestMipmapLinearFilter选择与被纹理化像素的尺寸最接近的两个mipmap， 并以NearestFilter为标准来从每个mipmap中生成纹理值。最终的纹理值是这两个值的加权平均值。

LinearMipmapNearestFilter选择与被纹理化像素的尺寸最匹配的mipmap， 并以LinearFilter（最靠近像素中心的四个纹理元素的加权平均值）为标准来生成纹理值。

LinearMipmapLinearFilter是默认值，它选择与被纹理化像素的尺寸最接近的两个mipmap， 并以LinearFilter为标准来从每个mipmap中生成纹理值。最终的纹理值是这两个值的加权平均值。
</code></pre>
<h2>material</h2>
<h3>code</h3>
<pre><code class="language-js">import &#39;./style.css&#39;
import * as THREE from &#39;three&#39;
import { OrbitControls } from &#39;three/examples/jsm/controls/OrbitControls.js&#39;
import * as dat from &#39;dat.gui&#39;

/**
 * Base
 */
const gui = new dat.GUI();

// Canvas
const canvas = document.querySelector(&#39;canvas.webgl&#39;)

// Scene
const scene = new THREE.Scene()

const textureLoader = new THREE.TextureLoader();
const cubeTextureLoader = new THREE.CubeTextureLoader();

const doorColorTexture = textureLoader.load(&#39;/textures/door/color.jpg&#39;)
const doorAlphaTexture = textureLoader.load(&#39;/textures/door/alpha.jpg&#39;)
const doorAmbientOcclusionTexture = textureLoader.load(&#39;/textures/door/ambientOcclusion.jpg&#39;)
const doorHeightTexture = textureLoader.load(&#39;/textures/door/height.jpg&#39;)
const doorNormalTexture = textureLoader.load(&#39;/textures/door/normal.jpg&#39;)
const doorMetalnessTexture = textureLoader.load(&#39;/textures/door/metalness.jpg&#39;)
const doorRoughnessTexture = textureLoader.load(&#39;/textures/door/roughness.jpg&#39;)
const matcapTexture = textureLoader.load(&#39;/textures/matcaps/8.png&#39;)
const gradientTexture = textureLoader.load(&#39;/textures/gradients/5.jpg&#39;)
gradientTexture.minFilter = THREE.NearestFilter
gradientTexture.magFilter = THREE.NearestFilter
gradientTexture.generateMipmaps = false

const environmentMapTexture = cubeTextureLoader.load([  // 加载CubeTexture的一个类。 内部使用ImageLoader来加载文件。
    &#39;/textures/environmentMaps/0/px.jpg&#39;,
    &#39;/textures/environmentMaps/0/nx.jpg&#39;,
    &#39;/textures/environmentMaps/0/py.jpg&#39;,
    &#39;/textures/environmentMaps/0/ny.jpg&#39;,
    &#39;/textures/environmentMaps/0/pz.jpg&#39;,
    &#39;/textures/environmentMaps/0/nz.jpg&#39;
])

// const material = new THREE.MeshBasicMaterial()
// material.map = doorColorTexture
// material.color = new THREE.Color(&quot;#ff00ff&quot;)
// material.wireframe = true
// material.transparent = true
// material.opacity = 0.5

// material.alphaMap = doorAlphaTexture
// material.side = THREE.DoubleSide

// const material = new THREE.MeshNormalMaterial()
// material.wireframe = true
// material.flatShading = true

// const material = new THREE.MeshMatcapMaterial()
// material.matcap = matcapTexture

// const material = new THREE.MeshDepthMaterial()

// const material = new THREE.MeshLambertMaterial()

// const material = new THREE.MeshPhongMaterial()
// material.shininess = 100  // 高光
// material.specular = new THREE.Color(0xff00ff)  // 反光色

// const material = new THREE.MeshToonMaterial()
// 卡通着色的渐变贴图。使用此类纹理时，需要将Texture.minFilterTexture.minFilter
// 和Texture.magFilterTexture.magFilter设置为THREE.NearestFilter。默认为空。
// material.gradientMap = gradientTexture  

// const material = new THREE.MeshStandardMaterial()
// material.metalness = 0.5
// material.roughness = 0.45
// material.map = doorColorTexture //颜色贴图。可以选择包括一个alpha通道，通常与.transparent 或.alphaTest。默认为null。 纹理贴图颜色由漫反射颜色.color调节。
// material.aoMap = doorAmbientOcclusionTexture // 该纹理的红色通道用作环境遮挡贴图。默认值为null。aoMap需要第二组UV。
// material.aoMapIntensity = 1 // 环境遮挡效果的强度。默认值为1。零是不遮挡效果。
// material.displacementMap = doorHeightTexture // 位移贴图
// material.displacementScale = 0 //位移贴图对网格的影响程度（黑色是无位移，白色是最大位移）。如果没有设置位移贴图，则不会应用此值。默认值为1。
// material.roughnessMap = doorRoughnessTexture
// material.metalnessMap = doorMetalnessTexture
// material.normalScale.set(0.5, 0.5)  // 法线贴图对材质的影响程度。典型范围是0-1。默认值是Vector2设置为（1,1）。
// material.transparent = true
// material.alphaMap = doorAlphaTexture  //alpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为null。

const material = new THREE.MeshStandardMaterial()
material.metalness = 0.5
material.roughness = 0.45
material.envMap = environmentMapTexture

gui.add(material, &#39;metalness&#39;).min(0).max(1).step(0.0001)
gui.add(material, &#39;roughness&#39;).min(0).max(1).step(0.0001)
gui.add(material, &#39;aoMapIntensity&#39;).min(0).max(10).step(0.0001)
gui.add(material, &#39;displacementScale&#39;).min(0).max(1).step(0.0001)
gui.add(material, &#39;wireframe&#39;)

const ambientlight = new THREE.AmbientLight(0xffffff, 0.5)
scene.add(ambientlight)
gui.add(ambientlight, &#39;intensity&#39;).min(0).max(1).step(0.0001)

const light = new THREE.PointLight(0xffffff, 0.5)
light.position.x = 2
light.position.y = 3
light.position.z
scene.add(light)
gui.add(light, &#39;intensity&#39;).min(0).max(1).step(0.0001)
// gui.add(light, &#39;distance&#39;).min(0).max(1).step(0.0001)
// gui.add(light, &#39;decay&#39;).min(0).max(5).step(0.0001)



const sphere = new THREE.Mesh(
    new THREE.SphereBufferGeometry(0.5, 64, 64),
    material
)
sphere.position.x = -1.5
// console.log(sphere.geometry);
sphere.geometry.setAttribute(&#39;uv2&#39;, new THREE.BufferAttribute(sphere.geometry.attributes.uv.array,2))

const plane = new THREE.Mesh(
    new THREE.PlaneBufferGeometry(1, 1, 100, 100),
    material
)
plane.geometry.setAttribute(&#39;uv2&#39;, new THREE.BufferAttribute(plane.geometry.attributes.uv.array,2))
// console.log(plane.geometry.attributes.uv);

const torus = new THREE.Mesh(
    new THREE.TorusBufferGeometry(0.3, 0.2, 128, 256),
    material
)
torus.position.x = 1.5
torus.geometry.setAttribute(&#39;uv2&#39;, new THREE.BufferAttribute(torus.geometry.attributes.uv.array,2))

scene.add(sphere, plane, torus)

/**
 * Sizes
 */
const sizes = {
    width: window.innerWidth,
    height: window.innerHeight
}

window.addEventListener(&#39;resize&#39;, () =&gt;
{
    // Update sizes
    sizes.width = window.innerWidth
    sizes.height = window.innerHeight

    // Update camera
    camera.aspect = sizes.width / sizes.height
    camera.updateProjectionMatrix()

    // Update renderer
    renderer.setSize(sizes.width, sizes.height)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
})

/**
 * Camera
 */
// Base camera
const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)
camera.position.x = 1
camera.position.y = 1
camera.position.z = 2
scene.add(camera)

// Controls
const controls = new OrbitControls(camera, canvas)
controls.enableDamping = true

/**
 * Renderer
 */
const renderer = new THREE.WebGLRenderer({
    canvas: canvas
})
renderer.setSize(sizes.width, sizes.height)
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

/**
 * Animate
 */
const clock = new THREE.Clock()

const tick = () =&gt;
{
    const elapsedTime = clock.getElapsedTime()

    sphere.rotation.y = 0.15 * elapsedTime;
    sphere.rotation.x = 0.15 * elapsedTime;


    plane.rotation.y = 0.15 * elapsedTime;
    plane.rotation.x = 0.15 * elapsedTime;
    
    torus.rotation.y = 0.15 * elapsedTime;
    torus.rotation.x = 0.15 * elapsedTime;

    // Update controls
    controls.update()

    // Render
    renderer.render(scene, camera)

    // Call tick again on the next frame
    window.requestAnimationFrame(tick)
}

tick()
</code></pre>
<h3>环境贴图</h3>
<p>要将环境贴图添加到我们的材料中，我们必须使用该属性。三.js仅支持多维数据集环境映射。立方体环境地图是 6 个图像，每个图像对应于环境的一个侧面。<code>envMap</code></p>
<p>您可以在文件夹中找到多个环境映射。<code>/static/textures/environmentMap/</code></p>
<p>若要加载多维数据集纹理，必须使用 <a href="https://threejs.org/docs/index.html#api/en/loaders/CubeTextureLoader">CubeTextureLoader</a> 而不是 <a href="https://threejs.org/docs/index.html#api/en/loaders/TextureLoader">TextureLoader</a>。</p>
<p>在实例化 和 调用其方法之前实例化 <a href="https://threejs.org/docs/index.html#api/en/loaders/CubeTextureLoader">CubeTextureLoader</a>，但使用路径数组而不是一个路径：<code>material``load(...)</code></p>
<pre><code>const cubeTextureLoader = new THREE.CubeTextureLoader()

const environmentMapTexture = cubeTextureLoader.load([
&#39;/textures/environmentMaps/0/px.jpg&#39;,
&#39;/textures/environmentMaps/0/nx.jpg&#39;,
&#39;/textures/environmentMaps/0/py.jpg&#39;,
&#39;/textures/environmentMaps/0/ny.jpg&#39;,
&#39;/textures/environmentMaps/0/pz.jpg&#39;,
&#39;/textures/environmentMaps/0/nz.jpg&#39;
])
</code></pre>
<pre><code>material.envMap = environmentMapTexture
</code></pre>
<h3>在何处查找环境地图</h3>
<p>要找到很酷的环境地图，您可以随时在网络上进行简单的搜索，并确保如果您不是出于个人使用，则有权使用环境地图。</p>
<p>最好的来源之一是<a href="https://hdrihaven.com/">HDRIHaven</a>。这个网站有数百个很棒的HDRI。HDRI 代表 <strong>高动态范围成像</strong>。它们由一个图像（不是立方体贴图）组成，并且包含比简单图像更多的数据，从而改善照明信息以获得更逼真的结果。<a href="https://hdrihaven.com/">HDRIHaven</a> 图像是免费的，并且在 <a href="https://hdrihaven.com/p/license.php">CC0 许可</a>下，这意味着您可以用它们做任何您想做的事情，而无需注明作者。但是，如果您欣赏他们的工作，可以通过订阅<a href="https://www.patreon.com/hdrihaven/overview">他们的 Patreon</a> 来感谢他们。</p>
<p>但我们有一个问题。正如我们所说，Three.js仅支持立方体地图。要将 HDRI 转换为立方体地图，您可以使用以下在线工具：<a href="https://matheowis.github.io/HDRI-to-CubeMap/">https://matheowis.github.io/HDRI-to-CubeMap/</a></p>
<p>上传HDRI，根据需要旋转它，然后下载由6张图像组成的立方体图版本。默认格式为 ，如果需要，必须将它们转换为。<code>.png``.jpg</code></p>
<h2>text3D</h2>
<h3>FontLoader</h3>
<p>一个用于加载JSON格式的字体的类。。返回font, 返回值是表示字体的<a href="https://threejs.org/docs/index.html#api/zh/extras/core/Shape">Shape</a>类型的数组。 其内部使用<a href="https://threejs.org/docs/index.html#api/zh/loaders/FileLoader">FileLoader</a>来加载文件。</p>
<p>你可以使用<a href="https://gero3.github.io/facetype.js/">facetype.js</a>来在线转换字体。</p>
<h4>进口</h4>
<p>FontLoader 是一个附加组件，必须显式导入。 See <a href="https://threejs.org/docs/#manual/introduction/Installation">Installation / Addons</a>.</p>
<pre><code>import { FontLoader } from &#39;three/addons/loaders/FontLoader.js&#39;;
</code></pre>
<h4>代码示例</h4>
<pre><code>const loader = new FontLoader();
const font = loader.load(
    // 资源URL
    &#39;fonts/helvetiker_bold.typeface.json&#39;,

    // onLoad回调
    function ( font ) {
        // do something with the font
        console.log( font );
    },

    // onProgress回调
    function ( xhr ) {
        console.log( (xhr.loaded / xhr.total * 100) + &#39;% loaded&#39; );
    },

    // onError回调
    function ( err ) {
        console.log( &#39;An error happened&#39; );
    }
);
</code></pre>
<h3>文本缓冲几何体（TextGeometry）</h3>
<p>一个用于将文本生成为单一的几何体的类。 它是由一串给定的文本，以及由加载的font（字体）和该几何体<a href="https://threejs.org/docs/index.html#api/zh/geometries/ExtrudeGeometry">ExtrudeGeometry</a>父类中的设置所组成的参数来构造的。 请参阅<a href="https://threejs.org/docs/index.html#examples/zh/loaders/FontLoader">FontLoader</a>页面来查看更多详细信息。</p>
<h4>进口</h4>
<p>TextGeometry 是一个附加组件，必须显式导入。 See <a href="https://threejs.org/docs/#manual/introduction/Installation">Installation / Addons</a>.</p>
<pre><code>import { TextGeometry } from &#39;three/addons/geometries/TextGeometry.js&#39;;
</code></pre>
<pre><code>const loader = new FontLoader();

loader.load( &#39;fonts/helvetiker_regular.typeface.json&#39;, function ( font ) {

    const geometry = new TextGeometry( &#39;Hello three.js!&#39;, {
        font: font,
        size: 80,
        height: 5,
        curveSegments: 12,
        bevelEnabled: true,
        bevelThickness: 10,
        bevelSize: 8,
        bevelSegments: 5
    } );
} );
</code></pre>
<pre><code>构造器
TextGeometry(text : String, parameters : Object)
text — 将要显示的文本。
parameters — 包含有下列参数的对象：

    font — THREE.Font的实例。
    size — Float。字体大小，默认值为100。
    height — Float。挤出文本的厚度。默认值为50。
    curveSegments — Integer。（表示文本的）曲线上点的数量。默认值为12。
    bevelEnabled — Boolean。是否开启斜角，默认为false。
    bevelThickness — Float。文本上斜角的深度，默认值为20。
    bevelSize — Float。斜角与原始文本轮廓之间的延伸距离。默认值为8。
    bevelSegments — Integer。斜角的分段数。默认值为3。
</code></pre>
<h3>中心</h3>
<pre><code>textGeometry.center()
</code></pre>
<h3>注意！！！！</h3>
<p><strong>B的开销非常大</strong></p>
<p>A:</p>
<pre><code>        const donutGeometry = new THREE.TorusBufferGeometry(0.3, 0.2, 32, 64)
        
        console.time(&#39;donut&#39;)
        for(let i = 0; i &lt; 1000; i++)
        {
            const donut = new THREE.Mesh(donutGeometry, textmaterial)
            donut.position.x = (Math.random() - 0.5) * 30
            donut.position.y = (Math.random() - 0.5) * 30
            donut.position.z = (Math.random() - 0.5) * 30
            donut.rotation.x = Math.random() * Math.PI
            donut.rotation.y = Math.random() * Math.PI
            const scale = Math.random()
            donut.scale.set(scale, scale, scale)

            scene.add(donut)
        }
</code></pre>
<p>B:</p>
<pre><code>       for(let i = 0; i &lt; 1000; i++)
        {
            const donutGeometry = new THREE.TorusBufferGeometry(0.3, 0.2, 32, 64)
            const donut = new THREE.Mesh(donutGeometry, textmaterial)
            donut.position.x = (Math.random() - 0.5) * 30
            donut.position.y = (Math.random() - 0.5) * 30
            donut.position.z = (Math.random() - 0.5) * 30
            donut.rotation.x = Math.random() * Math.PI
            donut.rotation.y = Math.random() * Math.PI
            const scale = Math.random()
            donut.scale.set(scale, scale, scale)

            scene.add(donut)
        }
</code></pre>
<h2>灯光</h2>
<h3>更新灯光辅助</h3>
<pre><code>window.requestAnimationFrame(() =&gt;
{
    spotLightHelper.update()
})

window.requestAnimationFrame(() =&gt;
{
    rectAreaLightHelper.position.copy(rectAreaLight.position)
    rectAreaLightHelper.quaternion.copy(rectAreaLight.quaternion)
    rectAreaLightHelper.update()
})
</code></pre>
<h2>阴影</h2>
<h3>必备条件</h3>
<pre><code class="language-js">renderer.shadowMap.enabled = true

sphere.castShadow = true

directionalLight.castShadow = true

plane.receiveShadow = true
</code></pre>
<h3>优化</h3>
<pre><code>directionalLight.shadow.mapSize.width = 1024 
directionalLight.shadow.mapSize.height = 1024 
</code></pre>
<pre><code class="language-js">directionalLight.shadow.camera.near = 1
directionalLight.shadow.camera.far = 6
directionalLight.shadow.camera.top = 2
directionalLight.shadow.camera.bottom = -2
directionalLight.shadow.camera.left = -2
directionalLight.shadow.camera.right = 2
</code></pre>
<pre><code>renderer.shadowMap.type = THREE.PCFSoftShadowMap
</code></pre>
<h2>鬼屋</h2>
<h3>纹理处理</h3>
<pre><code class="language-js">grassColorTexture.repeat.set(8, 8)
grassAmbientOcclusionTexture.repeat.set(8, 8)
grassNormalTexture.repeat.set(8, 8)
grassRoughnessTexture.repeat.set(8, 8)

grassColorTexture.wrapS = THREE.RepeatWrapping
grassAmbientOcclusionTexture.wrapS = THREE.RepeatWrapping
grassNormalTexture.wrapS = THREE.RepeatWrapping
grassRoughnessTexture.wrapS = THREE.RepeatWrapping

grassColorTexture.wrapT = THREE.RepeatWrapping
grassAmbientOcclusionTexture.wrapT = THREE.RepeatWrapping
grassNormalTexture.wrapT = THREE.RepeatWrapping
grassRoughnessTexture.wrapT = THREE.RepeatWrapping
</code></pre>
<p><strong>aoMap: bricksAmbientOcclusionTexture</strong>,需要第二组<strong>uv</strong></p>
<pre><code class="language-js">walls.geometry.setAttribute(&#39;uv2&#39;, new THREE.Float32BufferAttribute(walls.geometry.attributes.uv.array, 2))
</code></pre>
<p>对 <code>door</code> 对象的 UV 坐标进行了复制，添加了 <code>uv2</code> 属性。这是为了提供额外的 UV 坐标，通常用于支持一些高级的材质特性，例如 lightmaps 或 reflection maps。</p>
<p>具体来说，<code>uv</code> 属性是顶点的默认 UV 坐标，而 <code>uv2</code> 是额外的 UV2 坐标。在 Three.js 中，<code>uv2</code> 通常用于存储 lightmap 数据，但也可以用于其他一些需要额外 UV 数据的场景。</p>
<p>在这里，通过使用 <code>new THREE.Float32BufferAttribute(door.geometry.attributes.uv.array, 2)</code>，实际上是将原始 UV 坐标复制一份，使 <code>uv2</code> 与 <code>uv</code> 保持一致。这么做可能是为了确保两者在初次创建 <code>door</code> 对象时具有相同的初始值。</p>
<p>总体而言，这段代码的目的是为 <code>door</code> 对象添加一个额外的 UV 属性 <code>uv2</code>，并将其数据初始化为与默认 UV 属性 <code>uv</code> 相同的值。</p>
<h3>雾</h3>
<pre><code>const fog = new THREE.Fog(&#39;#262837&#39;, 1, 15)

scene.fog = fog
</code></pre>
<h4>优化</h4>
<pre><code>renderer.setClearColor(&#39;#262837&#39;)
</code></pre>
<h2>particles</h2>
<pre><code>const particlesGeometry = new THREE.BufferGeometry()
const count = 50000

const positions = new Float32Array(count * 3)
const colors = new Float32Array(count * 3)

for(let i = 0; i &lt; count * 3; i++)
{
    positions[i] = (Math.random() - 0.5) * 10
    colors[i] = Math.random()
}

particlesGeometry.setAttribute(&#39;position&#39;, new THREE.BufferAttribute(positions, 3))
particlesGeometry.setAttribute(&#39;color&#39;, new THREE.BufferAttribute(colors, 3))

// Material
const particlesMaterial = new THREE.PointsMaterial()

particlesMaterial.size = 0.1
particlesMaterial.sizeAttenuation = true

particlesMaterial.color = new THREE.Color(&#39;#ff88cc&#39;)

particlesMaterial.transparent = true
particlesMaterial.alphaMap = particleTexture
// particlesMaterial.alphaTest = 0.01
// particlesMaterial.depthTest = false
particlesMaterial.depthWrite = false
particlesMaterial.blending = THREE.AdditiveBlending

particlesMaterial.vertexColors = true

// Points
const particles = new THREE.Points(particlesGeometry, particlesMaterial)
scene.add(particles)
</code></pre>
<h3>Galaxy</h3>
<p>基本要素</p>
<pre><code>// Debug
const gui = new dat.GUI()

// Canvas
const canvas = document.querySelector(&#39;canvas.webgl&#39;)

// Scene
const scene = new THREE.Scene()
</code></pre>
<h4>封装到一个函数里，方便gui更新</h4>
<pre><code>const generateGalaxy = () =&gt;
{
    // Destroy old galaxy
    if(points !== null)
    {
        geometry.dispose()
        material.dispose()
        scene.remove(points)
    }

    /**
     * Geometry
     */
    geometry = new THREE.BufferGeometry()

    const positions = new Float32Array(parameters.count * 3)
    const colors = new Float32Array(parameters.count * 3)

    const colorInside = new THREE.Color(parameters.insideColor)
    const colorOutside = new THREE.Color(parameters.outsideColor)

    for(let i = 0; i &lt; parameters.count; i++)
    {
        // Position
        const i3 = i * 3

        const radius = Math.random() * parameters.radius

        const spinAngle = radius * parameters.spin
        const branchAngle = (i % parameters.branches) / parameters.branches * Math.PI * 2
        
        const randomX = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() &lt; 0.5 ? 1 : - 1) * parameters.randomness * radius
        const randomY = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() &lt; 0.5 ? 1 : - 1) * parameters.randomness * radius
        const randomZ = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() &lt; 0.5 ? 1 : - 1) * parameters.randomness * radius

        positions[i3    ] = Math.cos(branchAngle + spinAngle) * radius + randomX
        positions[i3 + 1] = randomY
        positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * radius + randomZ

        // Color
        const mixedColor = colorInside.clone()
        mixedColor.lerp(colorOutside, radius / parameters.radius)
        
        colors[i3    ] = mixedColor.r
        colors[i3 + 1] = mixedColor.g
        colors[i3 + 2] = mixedColor.b
    }

    geometry.setAttribute(&#39;position&#39;, new THREE.BufferAttribute(positions, 3))
    geometry.setAttribute(&#39;color&#39;, new THREE.BufferAttribute(colors, 3))

    /**
     * Material
     */
    material = new THREE.PointsMaterial({
        size: parameters.size,
        sizeAttenuation: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true
    })

    /**
     * Points
     */
    points = new THREE.Points(geometry, material)
    scene.add(points)
}
</code></pre>
<h4>优化 =&gt; 每次更新前清空数据，重新绘制</h4>
<pre><code>    if(points !== null)
    {
        geometry.dispose()
        material.dispose()
        scene.remove(points)
    }
</code></pre>
<h4>gui =&gt; 更新数据直接调用绘制函数即可  onFinishChange</h4>
<pre><code>gui.addColor(parameters, &#39;outsideColor&#39;).onFinishChange(generateGalaxy)
</code></pre>
<h2>鼠标交互 =&gt; 射线与物体相交</h2>
<h3>获取鼠标坐标</h3>
<pre><code>window.addEventListener(&#39;mousemove&#39;, (e)=&gt;{
    mouse.x = (e.clientX / sizes.width) * 2 - 1
    mouse.y = (1 - e.clientY /sizes.height -0.5) * 2
    // console.log(e.clientY /sizes.height);
    // console.log(mouse.x, mouse.y);
})
</code></pre>
<h3>实例化射线</h3>
<pre><code>const rayOrigin = new THREE.Vector3(-3,0,0)
const rayDirection = new THREE.Vector3(10,0,0)
rayDirection.normalize()

raycaster.set(rayOrigin, rayDirection)
</code></pre>
<pre><code>const raycaster = new THREE.Raycaster()

raycaster.setFromCamera(mouse,camera)
</code></pre>
<h3>获取射线相交对象的数组</h3>
<pre><code>const intersects = raycaster.intersectObjects(objects)
</code></pre>
<h3>处理物体变化</h3>
<pre><code>const objects = [object1,object2,object3]

    for(const object of objects){
            // console.log(object);
            object.material.color.set(&#39;#ff0000&#39;)
        }

    for(const intersect of intersects){
        intersect.object.material.color.set(&#39;#0000ff&#39;)
    }

    if(intersects.length){
        if(!currentIntersect){
            console.log(&#39;mouse enter&#39;);
        }
        currentIntersect = intersects[0]
    }else{
        if(currentIntersect)
        {
            console.log(&#39;mouse leave&#39;)
        }
        
        currentIntersect = null
    }
</code></pre>
<h3>鼠标交互</h3>
<pre><code>window.addEventListener(&#39;click&#39;, ()=&gt;{
    if(currentIntersect){
        switch(currentIntersect.object){
            case object1:
                console.log(&#39;click on object 1&#39;);
                break;
            case object2:
                console.log(&#39;click on object 2&#39;);
                break;
            case object3:
                console.log(&#39;click on object 3&#39;);
                break;
        }
    }
})
</code></pre>
<h2>滚动视差</h2>
<p><strong>平缓过渡</strong>
        视差动画是一个很好的开始，但感觉有点过于机械化。在现实生活中不可能有这样的线性动画，原因有很多：相机有重量，与空气和表面有摩擦，肌肉不能做出这样的线性运动，等等。这就是为什么运动感觉有点不对。我们将添加一些“缓和”（也称为“平滑”或“lerping”），我们将使用一个众所周知的公式。
这个公式背后的想法是，在每一帧上，我们不将相机直接移动到目标，而是将其（比方说）移动到离目的地近十分之一的位置。然后，在下一帧，又近了10帧。然后，在下一帧，又近了10帧。
在每一帧中，相机都会离目的地更近一点。但是，它越靠近，移动就越慢，因为它总是朝着目标位置移动实际位置的十分之一。
首先，我们需要将更改为，因为我们正在添加到实际位置：=+=</p>
<pre><code class="language-js">cameraGroup.position.x += (parallaxX - cameraGroup.position.x)
    * 5 * deltaTime
cameraGroup.position.y += (parallaxY - cameraGroup.position.y)
    * 5 * deltaTime
</code></pre>
<p><strong>卡通材质</strong></p>
<pre><code>const material = new THREE.MeshToonMaterial({
    color: parameters.materialColor,
    map: gradientTexture 
})
</code></pre>
<pre><code>当一个纹素覆盖大于一个像素时，贴图将如何采样。默认值为THREE.LinearFilter， 它将获取四个最接近的纹素，并在他们之间进行双线性插值。 另一个选项是THREE.NearestFilter，它将使用最接近的纹素的值。
</code></pre>
<p>渐变纹理加上</p>
<pre><code>const textureLoader = new THREE.TextureLoader()
const gradientTexture  = textureLoader.load(&#39;textures/gradients/3.jpg&#39;)
gradientTexture.magFilter = THREE.NearestFilter
</code></pre>
<h3>视差</h3>
<pre><code>window.addEventListener(&#39;mousemove&#39;, (e)=&gt;{
    cursor.x = e.clientX / sizes.width - 0.5
    cursor.y = e.clientY / sizes.height - 0.5
})

onst clock = new THREE.Clock()
let previousTime = 0

const tick = () =&gt;
{
    const elapsedTime = clock.getElapsedTime()
    const deltaTime = elapsedTime - previousTime 
    previousTime = elapsedTime
    
    const parallaxX = cursor.x * 0.5
    const parallaxY = - cursor.y * 0.5

    cameraGroup.position.x += (parallaxX - cameraGroup.position.x) * 5 * deltaTime
    cameraGroup.position.y += (parallaxY - cameraGroup.position.y) * 5 * deltaTime
}
</code></pre>
<h3>新章节动画提示</h3>
<pre><code>window.addEventListener(&#39;scroll&#39;, ()=&gt;{
    Scroll = window.scrollY / sizes.height    
    // console.log(Scroll);

    const newSection = Math.round(Scroll)

    if(newSection != currentSection)
    {
        currentSection = newSection
        
        gsap.to(
            sectionMeshes[currentSection].rotation,
            {
                duration: 1.5,
                ease: &#39;power2.inOut&#39;,
                x: &#39;+=6&#39;,
                y: &#39;+=3&#39;
            }
            )
    }
})
</code></pre>
<p>动画与<strong>mesh.rotation.y</strong></p>
<pre><code>    for(let mesh of sectionMeshes){
        mesh.rotation.y = elapsedTime * 0.2
        mesh.rotation.x = elapsedTime * 0.2
    }
</code></pre>
<p> 变换冲突，会导致动画不生效，需要更改为：</p>
<pre><code>   for(let mesh of sectionMeshes){
        mesh.rotation.y += deltaTime * 0.2
        mesh.rotation.x += deltaTime * 0.2
    }
</code></pre>
<h3>注意</h3>
<pre><code>for(let i = 0;i &lt; particlesCount;i++){
    positions[i * 3] = (Math.random() - 0.5) * 10
    positions[i * 3 + 1] = (Math.random() - 0.5) * sectionMeshes.length * objectsDistance -  objectsDistance
    positions[i * 3 + 2] = (Math.random() - 0.5) * 10
    console.log(positions[i + 1]);
}
</code></pre>
<h2>Physics</h2>
<p><strong>库</strong></p>
<pre><code>import * as CANNON from &#39;cannon-es&#39;
</code></pre>
<h3><strong>物理库抽象的对应得物理世界</strong></h3>
<pre><code>const world = new CANNON.World()
world.broadphase = new CANNON.SAPBroadphase(world)
world.allowSleep = true   // 休眠模式
world.gravity.set(0, - 9.82, 0)  // 重力
</code></pre>
<h3>材质</h3>
<h4>1&gt;</h4>
<pre><code>const concreteMaterial = new CANNON.Material(&#39;concrete&#39;)
const plasticMaterial = new CANNON.Material(&#39;plastic&#39;)

const concretePlasticContactMaterial = new CANNON.ContactMaterial(
        concreteMaterial,
        plasticMaterial,
        {
            friction: 0.1,
            restitution: 0.7
        }
    )
    
world.addContactMaterial(concretePlasticContactMaterial)

// 再将材质赋予抽象的物体
</code></pre>
<h4>2&gt;默认材质</h4>
<p><strong>抽象的物体不需要单独设置材质</strong></p>
<pre><code>const defaultMaterial = new CANNON.Material(&#39;default&#39;)
const defaultContactMaterial = new CANNON.ContactMaterial(
    defaultMaterial,
    defaultMaterial,
    {
    friction: 0.1,
    restitution: 0.7
    }
)
// world.addContactMaterial(defaultContactMaterial)
world.defaultContactMaterial = defaultContactMaterial  // 默认材料
</code></pre>
<h3>创建抽象物理世界的物体</h3>
<pre><code>const sphereShape = new CANNON.Sphere(0.5)
const sphereBody = new CANNON.Body({
    mass: 1, // 质量
    position: new CANNON.Vec3(0, 3, 0),
    shape: sphereShape,
    // material: plasticMaterial
    // material: defaultMaterial
    })

// 施加力
sphereBody.applyLocalForce(new CANNON.Vec3(150, 0, 0), new CANNON.Vec3(0, 0, 0))    

world.addBody(sphereBody)
</code></pre>
<pre><code>const floorShape = new CANNON.Plane()
const floorBody = new CANNON.Body()
floorBody.mass = 0
// floorBody.material = concreteMaterial
// floorBody.material = defaultMaterial
floorBody.addShape(floorShape)
world.addBody(floorBody)
</code></pre>
<p><strong>四元数旋转</strong></p>
<pre><code>floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(- 1, 0, 0), Math.PI * 0.5) 
</code></pre>
<p><strong><code>floorBody.addShape(floorShape)</code> 表示将一个碰撞形状（<code>floorShape</code>）添加到名为 <code>floorBody</code> 的 Cannon.js 刚体实例中。这通常用于在物理模拟中指定刚体的碰撞形状，以便其他刚体可以与其进行交互、碰撞和响应。</strong></p>
<p><strong>具体来说：</strong></p>
<ul>
<li><strong><code>floorBody</code> 是一个 Cannon.js 刚体对象，表示地面或平面。该刚体用于表示物理模拟中的地面，其他物体可以与其碰撞。</strong></li>
<li><strong><code>floorShape</code> 是一个 Cannon.js 碰撞形状，用于描述地面的碰撞区域。在这种情况下，<code>floorShape</code> 应该是一个平面（<code>CANNON.Plane</code>）形状，表示一个无限大的平面。</strong></li>
</ul>
<p><strong>通过调用 <code>floorBody.addShape(floorShape)</code>，将平面碰撞形状添加到地面的刚体中，从而指定地面的物理形状。这将允许其他物体与地面发生碰撞，并产生相应的物理交互。这样，在物理模拟中，其他物体可以与这个地面刚体进行碰撞、反弹等行为。</strong></p>
<h3>与threejs<strong>的物体建立联系</strong></h3>
<pre><code>for(const object of objectsToUpdate)
{
    object.mesh.position.copy(object.body.position)
    object.mesh.quaternion.copy(object.body.quaternion)
}
</code></pre>
<h2>Blender</h2>
<h3>快捷键操作</h3>
<p><img src="http://139.159.253.241/images/Threejs.assets/image-20230811192134342.png" alt="image-20230811192134342"></p>
<h3>快捷键操作</h3>
<p>alt + g ：移动至鼠标原点</p>
<h2>导入模型</h2>
<p><img src="http://139.159.253.241/images/Threejs.assets/image-20230813152443832.png" alt="image-20230813152443832"><img src="http://139.159.253.241/images/Threejs.assets/image-20230813152727505.png" alt="image-20230813152727505"></p>
<h3>GLTF&amp;DRACO</h3>
<pre><code>import { GLTFLoader } from &#39;three/examples/jsm/loaders/GLTFLoader.js&#39;
import { DRACOLoader } from &#39;three/examples/jsm/loaders/DRACOLoader.js&#39;
</code></pre>
<pre><code class="language-js">const gltfLoader = new GLTFLoader()

const dracoLoader = new DRACOLoader()
dracoLoader.setDecoderPath(&#39;/draco/&#39;)

gltfLoader.setDRACOLoader(dracoLoader)

let mixer = null
gltfLoader.load(
    // &#39;/models/Duck/glTF/Duck.gltf&#39;,
    // &#39;/models/Duck/glTF-Binary/Duck.gltf&#39;,
    // &#39;/models/Duck/glTF-Draco/Duck.gltf&#39;,
    // &#39;/models/Duck/glTF-Embedded/Duck.gltf&#39;,

    &#39;/models/Fox/glTF/Fox.gltf&#39;,

    // &#39;/models/FlightHelmet/glTF/FlightHelmet.gltf&#39;,
    (gltf) =&gt;
    {
        console.log(&#39;success&#39;)

        mixer = new THREE.AnimationMixer(gltf.scene)
        const action = mixer.clipAction(gltf.animations[2])
        action.play()

        // console.log(gltf)
        // for(const child of gltf.scene.children){
        //     scene.add(child)
        // }

        // 方法一
        // while(gltf.scene.children.length){
        //     console.log(gltf.scene.children.length);
        //     scene.add(gltf.scene.children[0])
        // }

        // 方法二
        // const children = [...gltf.scene.children]
        //   for(const child of children){
        //     scene.add(child)
        // }

        // 方法三
        gltf.scene.scale.set(0.025,0.025,0.025)
        scene.add(gltf.scene)

    },
    // (progress) =&gt;
    // {
    //     console.log(&#39;progress&#39;)
    //     console.log(progress)
    // },
    // (error) =&gt;
    // {
    //     console.log(&#39;error&#39;)
    //     console.log(error)
    // }
    )
</code></pre>
<h3>动画</h3>
<pre><code>mixer = new THREE.AnimationMixer(gltf.scene)
const action = mixer.clipAction(gltf.animations[2])
action.play()
</code></pre>
<pre><code>const tick = () =&gt;
{
    if(mixer)
    {
        mixer.update(deltaTime)
    }
    // Update controls
    controls.update()

    // Render
    renderer.render(scene, camera)

    // Call tick again on the next frame
    window.requestAnimationFrame(tick)
}

tick()
</code></pre>
<h2>真实渲染</h2>
<h3>环境贴图</h3>
<pre><code>const cubeTextureLoader = new THREE.CubeTextureLoader()

const environmentMap = cubeTextureLoader.load([
    &#39;/textures/environmentMaps/0/px.jpg&#39;,
    &#39;/textures/environmentMaps/0/nx.jpg&#39;,
    &#39;/textures/environmentMaps/0/py.jpg&#39;,
    &#39;/textures/environmentMaps/0/ny.jpg&#39;,
    &#39;/textures/environmentMaps/0/pz.jpg&#39;,
    &#39;/textures/environmentMaps/0/nz.jpg&#39;
])
environmentMap.encoding = THREE.sRGBEncoding
scene.background = environmentMap
</code></pre>
<h3>加载模型</h3>
<pre><code>gltfLoader.load(
    &#39;/models/FlightHelmet/glTF/FlightHelmet.gltf&#39;,
    (gltf) =&gt;
    {
        gltf.scene.scale.set(10, 10, 10)
        gltf.scene.position.set(0, - 4, 0)
        gltf.scene.rotation.y = Math.PI * 0.5
        scene.add(gltf.scene)

        const gltfGUI = gui.addFolder(&#39;gltf&#39;)        
        gltfGUI.add(gltf.scene.rotation, &#39;y&#39;).min(- Math.PI).max(Math.PI).step(0.001).name(&#39;rotation&#39;)
        updateAllMaterials() // 更新材质

    }
)
</code></pre>
<h4>更新材质</h4>
<pre><code>const debugObject = {}
debugObject.envMapIntensity = 1

const updateAllMaterials = () =&gt;
{
    scene.traverse((child) =&gt; // 在对象以及后代中执行的回调函数。
    {
        // console.log(child)
        // instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
        if(child instanceof THREE.Mesh &amp;&amp; child.material instanceof THREE.MeshStandardMaterial)
            {
                child.material.envMap = environmentMap
                child.material.envMapIntensity = debugObject.envMapIntensity
                child.material.needsUpdate = true
                child.castShadow = true
                child.receiveShadow = true

            }
    })
}
</code></pre>
<h3>优化</h3>
<pre><code>renderer.physicallyCorrectLights = true
renderer.outputEncoding = THREE.sRGBEncoding
renderer.toneMapping = THREE.ACESFilmicToneMapping
renderer.toneMappingExposure = 3
renderer.shadowMap.enabled = true
renderer.shadowMap.type = THREE.PCFSoftShadowMap
</code></pre>
<h2>shader</h2>
<p><strong>module - rules添加</strong></p>
<pre><code>// Shaders
{
    test: /\.(glsl|vs|fs|vert|frag)$/,
    exclude: /node_modules/,
    use: [
        &#39;raw-loader&#39;
    ]
}
</code></pre>
<p><img src="http://139.159.253.241/images/Threejs.assets/image-20230813153546896.png" alt="image-20230813153546896"></p>
<pre><code>import testVertexShader from &#39;./shaders/test/vertex.glsl&#39;
import testFragmentShader from &#39;./shaders/test/fragment.glsl&#39;

// Material
const material = new THREE.RawShaderMaterial({
    vertexShader: testVertexShader,
    fragmentShader: testFragmentShader,
    // wireframe: true,
    transparent: true,
    uniforms:
    {
        uFrequency: { value: new THREE.Vector2(10, 5) },
        uTime: { value: 0 },
        uColor: { value: new THREE.Color(&#39;orange&#39;) },
        uTexture: { value: flagTexture }
    }
})
</code></pre>
<h3>vertexShader</h3>
<p><strong>uniform</strong></p>
<pre><code>uniforms:
{
    uFrequency: { value: new THREE.Vector2(10, 5) },
    uTime: { value: 0 },
    uColor: { value: new THREE.Color(&#39;orange&#39;) },
    uTexture: { value: flagTexture }
}

//shader
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
</code></pre>
<p><strong>varying</strong></p>
<pre><code>//vertexShader
varying float vUv;

void main{
    //...
    vUv = uv;
}

//fragmentShader
varying vec2 vUv;

viod{
    //...
    
}
</code></pre>
<p><strong>attribute</strong></p>
<pre><code>geometry.setAttribute(&#39;aRandom&#39;, new THREE.BufferAttribute(randoms, 1))

//shader
attribute float aRandom;
</code></pre>
<h3>fragmentShader</h3>
<pre><code>precision mediump float;

uniform vec3 uColor;
uniform sampler2D uTexture;

varying vec2 vUv;
varying float vElevation;

void main()
{
    vec4 textureColor = texture2D(uTexture, vUv);
    textureColor.rgb *= vElevation * 2.0 + 0.5;
    gl_FragColor = textureColor;
    // gl_FragColor = vec4(vUv, 1.0, 1.0);
}
</code></pre>
<p>在 GLSL（OpenGL Shading Language）中，<code>precision mediump float;</code> 是用于声明浮点数精度的语句。让我解释一下它的含义：</p>
<p>GLSL 是一种用于在图形处理单元（GPU）上编写着色器程序的语言，着色器通常用于渲染图形和计算。</p>
<ul>
<li><code>precision</code>：这是一个关键字，用于声明数据类型的精度。</li>
<li><code>mediump</code>：这是精度限定词之一。在 GLSL 中，精度限定词用于指定数据类型（如浮点数）的精确程度。<code>mediump</code> 表示中等精度，适用于中等要求的计算，它通常在移动设备上的 GPU 上使用，可以在大多数场景下提供足够的精度。</li>
<li><code>float</code>：这是数据类型，表示单精度浮点数。</li>
</ul>
<p>因此，<code>precision mediump float;</code> 这一语句表示在 GLSL 代码中，浮点数类型 <code>float</code> 应该使用中等精度来进行计算和表示。这有助于在保持一定计算性能的同时，确保合适的数值精度，以满足渲染和计算的要求。根据需要，你还可以使用其他精度限定词，如 <code>highp</code>（高精度）或 <code>lowp</code>（低精度），来适应不同的应用场景。</p>
<h2>文字版P28 =&gt; shader绘制各种纹理</h2>
<h2>shader - sea</h2>
<h2>shader - galaxy</h2>
<pre><code>// size: parameters.size,
// sizeAttenuation: true,

更改为ShaderMaterial后，这两个属性需要删除，可能会看到黑屏。这取决于 GPU 在未提供大小时如何处理粒子
</code></pre>
<h3>粒子尺寸&amp;随机大小</h3>
<pre><code>geometry = new THREE.BufferGeometry()

const positions = new Float32Array(parameters.count * 3)
const colors = new Float32Array(parameters.count * 3)
const scales = new Float32Array(parameters.count * 1)

// ...

for(let i = 0; i &lt; parameters.count; i++)
{
// ...

// Scale
scales[i] = Math.random()
}
</code></pre>
<pre><code>uniforms:
{
    uSize: { value: 8 }
},

uniform float uSize;
attribute float aScale;

void main()
{
// ...

    gl_PointSize = uSize * aScale;
}
</code></pre>
<p><strong>处理像素比例</strong></p>
<pre><code>renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

uniforms:
{
    uSize: { value: 8 * renderer.getPixelRatio() }
}
</code></pre>
<h3>粒子尺寸衰减</h3>
<p><strong>尺寸衰减会使远离相机的粒子变小，而靠近相机的粒子更大。这模拟了视角。</strong></p>
<p><strong>源码位置：</strong></p>
<pre><code>/node_modules/three/src/renderers/shaders/ShaderLib/point_vert.glsl.js
</code></pre>
<pre><code>#ifdef USE_SIZEATTENUATION

bool isPerspective = isPerspectiveMatrix( projectionMatrix );

if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

#endif
</code></pre>
<p>需要的部分：</p>
<pre><code>gl_PointSize *= ( scale / - mvPosition.z );
</code></pre>
<p>在我的代码里：</p>
<pre><code>gl_PointSize = uSize * aScale;
gl_PointSize *= (1.0 / - viewPosition.z);
</code></pre>
<p><img src="http://139.159.253.241/images/Threejs.assets/image-20230813163035103.png" alt="image-20230813163035103"></p>
<h3>绘制图案</h3>
<h4>step</h4>
<pre><code>void main()
{
    // Disc
    float strength = distance(gl_PointCoord, vec2(0.5));
    strength = step(0.5, strength);
    strength = 1.0 - strength;

    gl_FragColor = vec4(vec3(strength), 1.0);
}
</code></pre>
<p><img src="http://139.159.253.241/images/Threejs.assets/image-20230813163205080.png" alt="image-20230813163205080"></p>
<h4>距离线性衰减</h4>
<pre><code>void main()
{
    // Diffuse point
    float strength = distance(gl_PointCoord, vec2(0.5));
    strength *= 2.0;
    strength = 1.0 - strength;

    gl_FragColor = vec4(vec3(strength), 1.0);
}
</code></pre>
<p><img src="http://139.159.253.241/images/Threejs.assets/image-20230813163247001.png" alt="image-20230813163247001"></p>
<h4>pow()</h4>
<pre><code>void main()
{
    // Light point
    float strength = distance(gl_PointCoord, vec2(0.5));
    strength = 1.0 - strength;
    strength = pow(strength, 10.0);

    gl_FragColor = vec4(vec3(strength), 1.0);
}
</code></pre>
<p><strong>因为衰减过快，可能需要放大粒子：</strong></p>
<pre><code>uniforms:
{
    uSize: { value: 30 * renderer.getPixelRatio() }
},
</code></pre>
<h4>颜色</h4>
<pre><code>varying vec3 vColor;

void main()
{
    // Light point
    float strength = distance(gl_PointCoord, vec2(0.5));
    strength = 1.0 - strength;
    strength = pow(strength, 10.0);

    // Final color
    vec3 color = mix(vec3(0.0), vColor, strength);
    gl_FragColor = vec4(color, 1.0);
}
</code></pre>
<p>​	</p>
<h3>动画</h3>
<pre><code>uniforms:
{
    uTime: { value: 0 },
    uSize: { value: 30 * renderer.getPixelRatio() }
},


const elapsedTime = clock.getElapsedTime()

// Update material
material.uniforms.uTime.value = elapsedTime
</code></pre>
<pre><code>vec4 modelPosition = modelMatrix * vec4(position, 1.0);

// Rotate
float angle = atan(modelPosition.x, modelPosition.z);
float distanceToCenter = length(modelPosition.xz);
float angleOffset = (1.0 / distanceToCenter) * uTime * 0.2;
angle += angleOffset;
modelPosition.x = cos(angle) * distanceToCenter;
modelPosition.z = sin(angle) * distanceToCenter;
</code></pre>
<h4>修复随机性</h4>
<pre><code>positions[i3    ] = Math.cos(branchAngle) * radius
positions[i3 + 1] = 0
positions[i3 + 2] = Math.sin(branchAngle) * radius

randomness[i3    ] = randomX
randomness[i3 + 1] = randomY
randomness[i3 + 2] = randomZ

geometry.setAttribute(&#39;position&#39;, new THREE.BufferAttribute(positions, 3))
geometry.setAttribute(&#39;aRandomness&#39;, new THREE.BufferAttribute(randomness, 3))

// Randomness
modelPosition.xyz += aRandomness;
</code></pre>
<h1>GSAP</h1>
<p><code>gsap.to()</code> - This is the most common type of tween. A <code>.to()</code> tween will start at the element&#39;s current state and <strong>animate &quot;to&quot; the values defined in the tween.</strong></p>
<p><code>gsap.from()</code> - Like a backwards <code>.to()</code> where it <strong>animates &quot;from&quot; the values defined in the tween</strong> and ends at the element&#39;s current state.</p>
<p><code>gsap.fromTo()</code> - <strong>You define *both* the starting *and* ending values.</strong></p>
<p><code>gsap.set()</code> - <strong>Immediately sets properties</strong> (no animation). It&#39;s essentially a zero-duration <code>.to()</code> tween which can be reverted.</p>
<pre><code class="language-js">// use a class or ID
gsap.to(&quot;.box&quot;, { x: 200 });

// a complex CSS selector
gsap.to(&quot;section &gt; .box&quot;, { x: 200 });

// a variable
let box = document.querySelector(&quot;.box&quot;);
gsap.to(box, { x: 200 })

// or even an Array of elements
let square = document.querySelector(&quot;.square&quot;);
let circle = document.querySelector(&quot;.circle&quot;);
                                      
gsap.to([square, circle], { x: 200 })
</code></pre>
<p><img src="http://139.159.253.241/images/Threejs.assets/image-20230920101431165.png" alt="image-20230920101431165"></p>
<p><strong>变换的参照物</strong></p>
<pre><code class="language-js">x: 200, // use default of px
x: &quot;+=200&quot; // relative values
x: &#39;40vw&#39;, // or pass in a string with a different unit for GSAP to parse
x: () =&gt; window.innerWidth / 2, // you can even use functional values to do a calculation!
  
rotation: 360 // use default of degrees
rotation: &quot;1.25rad&quot; // use radians
</code></pre>
<p><img src="http://139.159.253.241/images/Threejs.assets/image-20230920105214072.png" alt="image-20230920105214072"></p>
<h2>液体失真</h2>
<pre><code>https://github.com/codrops/LiquidDistortion.git

https://tympanus.net/codrops/2017/10/10/liquid-distortion-effects/
</code></pre>
<p><img src="http://139.159.253.241/images/Threejs.assets/image-20230920101040066.png" alt="image-20230920101040066"></p>

</body>
</html>