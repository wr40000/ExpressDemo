<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="http://139.159.253.241:3000/stylesheets/github.css">
    <title>Document</title>
</head>
<body>
    <h1><strong>tensor（张量）</strong></h1>
<h1>torch.squeeze()</h1>
<pre><code>torch.squeeze(input, dim=None, out=None) 
</code></pre>
<p>squeeze()函数的功能是维度压缩。返回一个tensor（张量），其中 input 中维度大小为1的所有维都已删除。
举个例子：如果 input 的形状为 (A×1×B×C×1×D)，那么返回的tensor的形状则为 (A×B×C×D)
当给定 dim 时，那么只在给定的维度（dimension）上进行压缩操作，注意给定的维度大小必须是1，否则不能进行压缩。
举个例子：如果 input 的形状为 (A×1×B)，squeeze(input, dim=0)后，返回的tensor不变，因为第0维的大小为A，不是1；squeeze(input, 1)后，返回的tensor将被压缩为 (A×B)。</p>
<pre><code>x = torch.randn(size=(2, 1, 2, 1, 2))
x.shape
输出结果如下：
torch.Size([2, 1, 2, 1, 2])
</code></pre>
<pre><code>版权声明：本文为CSDN博主「cv_lhp」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/flyingluohaipeng/article/details/125092937
</code></pre>
<h2>torch.<a href="https://so.csdn.net/so/search?q=unsqueeze&spm=1001.2101.3001.7020">unsqueeze</a>()</h2>
<pre><code>torch.unsqueeze(input, dim) → Tensor
</code></pre>
<p><strong>unsqueeze()函数起升维的作用,参数dim表示在哪个地方加一个维度，注意dim范围在:[-input.dim() - 1, input.dim() + 1]之间，比如输入input是一维，则dim=0时数据为行方向扩，dim=1时为列方向扩，再大错误。</strong></p>
<pre><code>x = torch.tensor([1, 2, 3, 4])
y = torch.unsqueeze(x, 0)#在第0维扩展，第0维大小为1
y,y.shape
输出结果如下：
(tensor([[1, 2, 3, 4]]), torch.Size([1, 4]))
</code></pre>
<pre><code>y = torch.unsqueeze(x, 1)#在第1维扩展，第1维大小为1
y,y.shape
输出结果如下：
(tensor([[1],
         [2],
         [3],
         [4]]),
 torch.Size([4, 1]))
</code></pre>
<pre><code>y = torch.unsqueeze(x, -1)#在第最后一维扩展，最后一维大小为1
y,y.shape
输出结果如下：
(tensor([[1],
         [2],
         [3],
         [4]]),
 torch.Size([4, 1]))
</code></pre>
<h1>numpy&amp;tensor</h1>
<p><strong>numpy转tensor</strong></p>
<pre><code>x = torch.from_numpy(x)
</code></pre>
<p><strong>tensor转numpy</strong></p>
<pre><code>import torch
x = torch.ones(5) # 创建张量x
# tensor([1., 1., 1., 1., 1.])
x_ = x.detach().numpy() # 转换
# array([1., 1., 1., 1., 1.], dtype=float32)
或者：
x_= x.numpy()
</code></pre>
<p><img src="Torch.assets/image-20230423202321986.png" alt="image-20230423202321986"></p>
<h1>初学者安装Sklearn详细步骤（有详细步骤截图，亲测完成）</h1>
<pre><code>http://t.csdn.cn/sxA5t
</code></pre>
<p><img src="Torch.assets/image-20230424183700484.png" alt="image-20230424183700484"></p>
<h1>torch.cat()</h1>
<p>[torch.cat()](<a href="https://pytorch.org/docs/stable/generated/torch.cat.html?highlight=torch">https://pytorch.org/docs/stable/generated/torch.cat.html?highlight=torch</a> cat#torch.cat)</p>
<p><img src="Torch.assets/image-20230509145951256.png" alt="image-20230509145951256"></p>
<p><strong>1.2 函数功能</strong>
<strong>函数将两个张量（tensor）按指定维度拼接在一起，注意：除拼接维数dim数值可不同外其余维数数值需相同，方能对齐，如下面例子所示。torch.cat()函数不会新增维度，而torch.stack()函数会新增一个维度，相同的是两个都是对张量进行拼接</strong></p>
<pre><code>输入两个二维张量（dim=0）：dim=0对行进行拼接
a = torch.randn(2,3)
b =  torch.randn(3,3)
c = torch.cat((a,b),dim=0)
a,b,c
输入两个二维张量（dim=1）: dim=1对列进行拼接
a = torch.randn(2,3)
b =  torch.randn(2,4)
c = torch.cat((a,b),dim=1)
a,b,c
输入两个三维张量：dim=0 对通道进行拼接
a = torch.randn(2,3,4)
b =  torch.randn(1,3,4)
c = torch.cat((a,b),dim=0)
a,b,c
输入两个三维张量：dim=1对行进行拼接
a = torch.randn(2,3,4)
b =  torch.randn(2,4,4)
c = torch.cat((a,b),dim=1)
a,b,c
输入两个三维张量：dim=2对列进行拼接
a = torch.randn(2,3,4)
b =  torch.randn(2,3,5)
c = torch.cat((a,b),dim=2)
a,b,c
</code></pre>
<h1>python--isinstance()</h1>
<p>一、isinstance() 函数
  下面从用途描述、使用方法、案例分析、三个方面进行讲解。</p>
<p>1.1 用途描述
  isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。</p>
<p>1.2 使用方法
语法：
isinstance(object, classinfo)
参数含义：
object – 实例对象。
classinfo – 可以是直接或间接类名、基本类型或者由它们组成的元组。
返回值：
如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False。
1.3 案例分析
  需要注意的是第三个小例子，a的类型只要是元组中的一个就会返回True。</p>
<pre><code>a = 9
isinstance (a,int)
isinstance (a,str)
isinstance (a,(str,int,list))   # 是元组中的一个返回 True
&quot;&quot;&quot;--------------------------------------输出-------------------------------------------&quot;&quot;&quot;
True
False
True
</code></pre>
<ul>
<li>type() 与 isinstance()区别，通过下面代码片段可得出以下要点：<ul>
<li>type() 不会认为子类是一种父类类型，不考虑继承关系。</li>
<li>isinstance() 会认为子类是一种父类类型，考虑继承关系。</li>
<li>如果要判断两个类型是否相同推荐使用 isinstance()。</li>
</ul>
</li>
</ul>
<pre><code>class A:
    pass
 
class B(A):
    pass
isinstance(A(), A)    # returns True
type(A()) == A        # returns True
isinstance(B(), A)    # returns True
type(B()) == A        # returns False
</code></pre>
<pre><code>————————————————
版权声明：本文为CSDN博主「二进制研究员」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_44186785/article/details/119989696
</code></pre>
<h1>python--进度条 tqdm</h1>
<pre><code>http://t.csdn.cn/CcDsn
</code></pre>
<p>安装tqdm</p>
<pre><code>conda install tqdm
or
pip install tqdm
</code></pre>
<p>使用<code>tqdm.tqdm()</code>实现进度条</p>
<p>示例：</p>
<pre><code>for i in tqdm(range(20), desc=&#39;It\&#39;s a test&#39;):
    time.sleep(0.1)
</code></pre>
<p><img src="Torch.assets/2021041914523741.png" alt="在这里插入图片描述"></p>
<p><img src="Torch.assets/image-20230509150727050.png" alt="image-20230509150727050"></p>
<h1>python--assert</h1>
<p>使用assert是学习python的一个非常好的习惯，在没完善一个程序之前，我们不知道程序在哪里会出错，与其让它在运行时崩溃，不如在出现错误条件时就崩溃。</p>
<p>用一个程序说明：</p>
<pre><code>def  zero(s):
    a = int(s)
    assert a &gt; 0,&quot;a超出范围&quot;   #这句的意思：如果a确实大于0，程序正常往下运行
    return a

zero(&quot;-2&quot;)  #但是如果a是小于0的，程序会抛出AssertionError错误，报错为参数内容“a超出范围”
</code></pre>
<p>运行结果如下：</p>
<pre><code>Traceback (most recent call last):
  File &quot;e:\Python_list\class_student\temp.py&quot;, line 6, in &lt;module&gt;
    zero(&quot;-2&quot;)
  File &quot;e:\Python_list\class_student\temp.py&quot;, line 3, in zero
    assert a &gt; 0,&quot;a超出范围&quot;
AssertionError: a超出范围
</code></pre>
<h2></h2>
<h1>np.expand_dims-扩展数组的形状</h1>
<p>第一层理解：这个axis会插在形状的哪里（知道形状会怎么改变）</p>
<p>假设我们有个数组a</p>
<pre><code>import numpy as np
a=np.array([[1,2,3],[4,5,6]])
</code></pre>
<p><img src="Torch.assets/image-20230331202733155.png" alt="image-20230331202733155">第二层理解：这个第二层理解：这个数组的内在会怎么改变（知道中括号[]会加在哪）</p>
<p>先说结论，会给插入维度后的每个值（或数组）加一个中括号【】。
这里不理解没关系，看下面的例子。</p>
<p>假设我们有个数组a</p>
<pre><code>import numpy as np
a=np.array([[1,2,3],[4,5,6]])
</code></pre>
<p><img src="Torch.assets/image-20230331202853199.png" alt="image-20230331202853199"></p>
<pre><code>b=np.expand_dims(a, axis=0)
</code></pre>
<p><img src="Torch.assets/image-20230331202917966.png" alt="image-20230331202917966"></p>
<pre><code>b=np.expand_dims(a, axis=2)
</code></pre>
<p><img src="Torch.assets/image-20230331202940474.png" alt="image-20230331202940474"></p>
<pre><code>b=np.expand_dims(a, axis=1)
</code></pre>
<p><strong>np.expand_dims有什么用</strong></p>
<p>假设你有一张灰度图，读取之后的shape是（360，480）
而模型的输入要求是（1，360，380）或者是（360，480，1）
那么你就可以通过np.expand_dims(a, axis=0)或者np.expand_dims(a, axis=-1)，将形状改变为满足模型的输入。</p>
<h1>glob.glob() 函数</h1>
<p>查找符合特定规则的文件路径名。跟使用windows下的文件搜索差不多。查找文件只用到三个匹配符：”<em>”, “?”, “[]”。”</em>”匹配0个或多个字符；”?”匹配单个字符；”[]”匹配指定范围内的字符，如：[0-9]匹配数字</p>
<p><strong>glob.glob</strong></p>
<p>返回所有匹配的文件路径列表。它只有一个参数pathname，定义了文件路径匹配规则，这里可以是绝对路径，也可以是相对路径。下面是使用glob.glob的例子：</p>
<pre><code>import glob

#获取指定目录下的所有图片
print (glob.glob(r&quot;/home/qiaoyunhao/*/*.png&quot;),&quot;\n&quot;)#加上r让字符串不转义

#获取上级目录的所有.py文件
print (glob.glob(r&#39;../*.py&#39;)) #相对路径
</code></pre>
<p><strong>glob.iglob</strong></p>
<pre><code>import glob
#父目录中的.py文件
f = glob.iglob(r&#39;../*.py&#39;)
print (f) #&lt;generator object iglob at 0x00B9FF80&gt;
for py in f:
    print (py)
</code></pre>
<p><img src="Torch.assets/image-20230423225141585.png" alt="image-20230423225141585"></p>
<p><strong>split()</strong> </p>
<pre><code>str.split(str=&quot;&quot;,num=string.count(str))[n]
</code></pre>
<p>参数说明：
str:表示为分隔符，默认为空格，但是不能为空(’’)。若字符串中没有分隔符，则把整个字符串作为列表的一个元素
num:表示分割次数。如果存在参数num，则仅分隔成 num+1 个子字符串，并且每一个子字符串可以赋给新的变量。默认为 -1, 即分隔所有。</p>
<p>注意：当使用空格作为分隔符时，对于中间为空的项会自动忽略</p>
<p><strong>分离字符串</strong></p>
<p><strong>1、以’ *<em>.*</em> &#39;为分隔符</strong></p>
<pre><code>print(string.split(&#39;.&#39;))
</code></pre>
<p>输出：</p>
<pre><code>[&#39;www&#39;, &#39;gziscas&#39;, &#39;com&#39;, &#39;cn&#39;]
</code></pre>
<p><strong>2、分割两次</strong></p>
<pre><code>print(string.split(&#39;.&#39;,2))
</code></pre>
<p>输出：</p>
<pre><code>[&#39;www&#39;, &#39;gziscas&#39;, &#39;com.cn&#39;]
</code></pre>
<p><strong>3、分割两次，并取序列为1的项</strong></p>
<pre><code>print(string.split(&#39;.&#39;,2)[1])
</code></pre>
<p>输出：</p>
<pre><code>gziscas
</code></pre>
<p><strong>4、分割两次，并把分割后的3个部分保存到3个文件</strong></p>
<pre><code>u1, u2, u3 =string.split(&#39;.&#39;,2)

print(u1)   #输出：www
print(u2)   #输出：gziscas
print(u3)   #输出：com.cn
</code></pre>
<pre><code>www
gziscas
com.cn
</code></pre>
<p><strong>四、实例</strong></p>
<pre><code>str=&quot;hello boy&lt;[www.baidu.com]&gt;byebye&quot;

print(str.split(&quot;[&quot;)[1].split(&quot;]&quot;)[0])
</code></pre>
<p>输出：</p>
<pre><code>www.baidu.com
</code></pre>
<pre><code class="language-python">accuracy = (outputs.argmax(1) == labels).sum()

这行代码的意思是计算模型的预测结果与真实标签一致的数量。具体地说，假设模型输出是一个形状为[batch_size,num_classes]的张量（其中batch_size是批次大小，num_classes是分类数），则outputs.argmax(1)返回每个样本最大概率的类别索引。然后，(outputs.argmax(1) == labels)对比这些索引值与真实标签是否一致，得到一个布尔型的张量。最后，.sum()函数统计所有True的元素数量，也就是预测正确的样本数。这个数字可以用来评估模型在验证集或测试集上的性能表现。
</code></pre>
<h1># 对所有元素求和# 取平均</h1>
<pre><code># 对所有元素求和
sum_temperature = torch.sum(temperature)
# 取平均
average_temperature = torch.mean(temperature)
</code></pre>
<h1>view(-1, 1)</h1>
<p><code>view(-1, 1)</code> 是 PyTorch 中用于调整张量形状的方法之一。具体来说，<code>view</code> 方法允许你改变张量的形状，而 <code>-1</code> 表示由 PyTorch 自动计算该维度的大小，以保证张量的总元素数不变。</p>
<p>在这个特定的例子中，<code>temperature.view(-1, 1)</code> 的目的是将 <code>temperature</code> 张量转换为一个列向量，其中列数为 1。<code>-1</code> 的作用是告诉 PyTorch 自动计算行数，以确保总的元素数量不变。这样做是为了确保 <code>temperature</code> 能够与 <code>logits_student</code> 进行按元素的除法，因为两个张量在进行按元素运算时，需要具有相同的形状。</p>
<p>例如，如果 <code>temperature</code> 的形状是 <code>(128,)</code>，<code>temperature.view(-1, 1)</code> 将其转换为形状为 <code>(128, 1)</code> 的张量，其中每个元素都被放置在单独的行中，从而可以与 <code>logits_student</code> 的每一行进行按元素的除法。</p>

</body>
</html>