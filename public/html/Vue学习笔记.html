<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="http://127.0.0.1:3030/stylesheets/github.css">
    <title>Document</title>
</head>
<body>
    <h1>一些报错</h1>
<p><strong>解决vue3+ts+eslint下Parsing error: ‘＞‘ expected.eslint</strong></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20230517221615448.png" alt="image-20230517221615448"></p>
<pre><code>把.eslintrc.json里的parserOptions配置改成

&quot;parser&quot;: &quot;vue-eslint-parser&quot;,

&quot;parserOptions&quot;:{&quot;parser&quot;:&quot;@typescript-eslint/parser&quot;},
</code></pre>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20230517221634837.png" alt="image-20230517221634837"></p>
<h1>Vue.js is detected on this page的解决方法</h1>
<pre><code>chrome://version/

\Extensions\nhdogjmejiglipccpnnnanhbledajbpd\6.1.4_0

persistent
</code></pre>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231017094729048.png" alt="image-20231017094729048"></p>
<h1>尚硅谷禹神Vue2教程</h1>
<h2>禹神的小技巧：</h2>
<p><strong>折叠注释</strong></p>
<pre><code>//#region

//#endregion
</code></pre>
<h3>en写get set :</h3>
<p><img src="typora-user-images.assets/image-20230404115006613.png" alt="image-20230404115006613"></p>
<p><img src="typora-user-images.assets/image-20230403184736342.png" alt="image-20230403184736342"></p>
<h2>配置</h2>
<pre><code>lintOnSave:false, //关闭语法检查
</code></pre>
<h2>模板语法</h2>
<p><img src="typora-user-images.assets/image-20230403184457472.png" alt="image-20230403184457472"></p>
<h2><strong>Vue核心 el与data的两种写法</strong></h2>
<p><img src="typora-user-images.assets/image-20230403184839651.png" alt="image-20230403184839651"></p>
<h2><strong>Vue核心 MVVM模型 数据代理</strong></h2>
<p><img src="typora-user-images.assets/image-20230403190625613.png" alt="image-20230403190625613"></p>
<pre><code class="language-vue">let number = 18
let person = {
name:&#39;张三&#39;,
sex:&#39;男&#39;,
}

Object.defineProperty(person,&#39;age&#39;,{
// value:18,
// enumerable:true, //控制属性是否可以枚举，默认值是false
// writable:true, //控制属性是否可以被修改，默认值是false
// configurable:true //控制属性是否可以被删除，默认值是false

//当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值
get(){
    console.log(&#39;有人读取age属性了&#39;)
    return number
},

//当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值
set(value){
    console.log(&#39;有人修改了age属性，且值是&#39;,value)
    number = value
}

})

// console.log(Object.keys(person))
</code></pre>
<h3>数据代理</h3>
<h4>Vue中的this.$options.data()和this.$data</h4>
<pre><code>版权声明：本文为CSDN博主「mocoe」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/mocoe/article/details/89682022
</code></pre>
<h5>问题</h5>
<p>项目里遇到一个问题，用this.$options.data()重置组件data时，data()里用this获取的props或method都为undefined，代码简化如下：</p>
<pre><code class="language-js">export default {
    props: {
        P: Object
    },
    data () {
        return {
            A: {
                a: this.methodA
            },
            B: this.P
        };
    },
    methods: {
        resetData () { // 更新时调用
            Object.assign(this.$data, this.$options.data()); // 有问题！！！
        },
        methodA () {
            // do sth.
        },
        methodB () { // 通过用户操作调用
            this.A.a &amp;&amp; this.A.a(); // this.A.a is undefined, this.B is undefined！！！
        }
    }
}
</code></pre>
<p>调用resetData()之后，再调用methodB()时，this.A.a和this.B是undefined。</p>
<h5>解决</h5>
<p>resetData里这样写：</p>
<pre><code>resetData () { // 更新时调用
    Object.assign(this.$data, this.$options.data.call(this));
}
</code></pre>
<h5>原因</h5>
<p>和Vue实例的初始化相关。(源码version2.6.10)</p>
<p>1、new Vue的时候传了一个对象，把该对象记为options，Vue将options中自定义的属性和Vue构造函数中定义的属性合并为vm.$options，vm.$options.data()中的this指向vm.$options，而methodA和B并没有直接挂在vm.$options下，所以this.methodA和this.B为undefined。</p>
<pre><code>// 创建一个vue实例
const options = {
    customOption: &#39;foo&#39;,
    data () {
        A: this.methodA
    },
    methods: {
        methodA () {}
    },
    created: function () {
        console.log(this.$options.customOption) // =&gt; &#39;foo&#39;
    }
};
new Vue(options);
 
// src/core/instance/init.js
initMixin (Vue: Class&lt;Component&gt;) {
    const vm: Component = this
    // ...
    vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
    )
    // ...
}
</code></pre>
<p>2、然后将vm.$options.data映射到vm._data，使得可以通过vm._data访问数据，在映射过程中，通过call将data()的this指向当前的实例vm，并将data()的执行结果返回，因为prop和methods的初始化在data之前，所以这时vm上已有_props和_methods，可以拿到this.methodA和this.B。（vm.key如何实现vm._props.key效果见3）。</p>
<pre><code>// src/core/instance/state.js
initState (vm: Component) {
    // ...
    const opts = vm.$options
    if (opts.props) initProps(vm, opts.props)
    if (opts.methods) initMethods(vm, opts.methods)
    if (opts.data) {
        initData(vm) // 里面通过getData(data, vm)改变this
    }
    // ...
}

getData (data: Function, vm: Component): any {
    // ...
    try {
        return data.call(vm, vm) // this替换为vm
    }
    // ...
}
</code></pre>
<p>3、上面把属性映射到了vm._data里，可以通过vm._data.A访问数据，Vue再通过一个代理方法使得vm.A可以直接访问A。</p>
<pre><code>// src/core/instance/state.js
proxy(vm, `_data`, key);

proxy (target: Object, sourceKey: string, key: string) {
    sharedPropertyDefinition.proxyget = function proxyGetter () {
        return this[sourceKey][key]
    }
    sharedPropertyDefinition.set = function proxySetter (val) {
        this[sourceKey][key] = val
    }
    Object.defineProperty(target, key, sharedPropertyDefinition)
}
</code></pre>
<h5>总结</h5>
<p>data()中若使用了this来访问props或methods，在重置$data时，注意this.$options.data()的this指向，最好使用this.$options.data.call(this)。</p>
<pre><code>参考
https://www.cnblogs.com/denon/p/10420029.html

https://www.jianshu.com/p/983680723ec1
</code></pre>
<p><img src="typora-user-images.assets/image-20230403191404704.png" alt="image-20230403191404704"></p>
<p><img src="typora-user-images.assets/image-20230403191428495.png" alt="image-20230403191428495"></p>
<p><img src="typora-user-images.assets/image-20230403191903158.png" alt="image-20230403191903158"></p>
<p>​        1.Vue中的数据代理：</p>
<p>​              通过vm对象来代理data对象中属性的操作（读/写）</p>
<p>​        2.Vue中数据代理的好处：</p>
<p>​              更加方便的操作data中的数据</p>
<p>​        3.基本原理：</p>
<p>​              通过Object.defineProperty()把data对象中所有属性添加到vm上。</p>
<p>​              为每一个添加到vm上的属性，都指定一个getter/setter。</p>
<p>​              在getter/setter内部去操作（读/写）data中对应的属性。</p>
<h2><strong>Vue核心 事件处理</strong></h2>
<h3>事件的基本使用：</h3>
<p>​              1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；</p>
<p>​              2.事件的回调需要配置在methods对象中，最终会在vm上；</p>
<p>​              <strong>3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；</strong></p>
<p>​              4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；</p>
<p>​              5.@click=&quot;demo&quot; 和 @click=&quot;demo($event)&quot; 效果一致，但后者可以传参；</p>
<h3>事件修饰符</h3>
<pre><code>1.prevent：阻止默认事件（常用）；
2.stop：阻止事件冒泡（常用）；
3.once：事件只触发一次（常用）；
4.capture：使用事件的捕获模式；
5.self：只有event.target是当前操作的元素时才触发事件；
6.passive：事件的默认行为立即执行，无需等待事件回调执行完
</code></pre>
<h4>.capture事件修饰符的作用添加事件侦听器时使用事件捕获模式</h4>
<p>即是给元素添加一个监听器，当元素发生冒泡时，先触发带有该修饰符的元素。若有多个该修饰符，则由外而内触发。
就是谁有该事件修饰符，就先触发谁。</p>
<h4>冒泡和捕获</h4>
<p><img src="typora-user-images.assets/image-20230403193251037.png" alt="image-20230403193251037"></p>
<p>self：只有event.target是当前操作的元素时才触发事件；</p>
<p><img src="typora-user-images.assets/image-20230403193421058.png" alt="image-20230403193421058"></p>
<p><img src="typora-user-images.assets/image-20230403193448474.png" alt="image-20230403193448474"></p>
<p>两者的e.target是一个事件,即button</p>
<p>@wheel 和 @scroll</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;事件修饰符&lt;/title&gt;
        &lt;!-- 引入Vue --&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
        &lt;style&gt;
            *{
                margin-top: 20px;
            }
            .demo1{
                height: 50px;
                background-color: skyblue;
            }
            .box1{
                padding: 5px;
                background-color: skyblue;
            }
            .box2{
                padding: 5px;
                background-color: orange;
            }
            .list{
                width: 200px;
                height: 200px;
                background-color: peru;
                overflow: auto;
            }
            li{
                height: 100px;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 
                Vue中的事件修饰符：
                        1.prevent：阻止默认事件（常用）；
                        2.stop：阻止事件冒泡（常用）；
                        3.once：事件只触发一次（常用）；
                        4.capture：使用事件的捕获模式；
                        5.self：只有event.target是当前操作的元素时才触发事件；
                        6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；
        --&gt;
        &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            &lt;h2&gt;欢迎来到{{name}}学习&lt;/h2&gt;
            &lt;!-- 阻止默认事件（常用） --&gt;
            &lt;a href=&quot;http://www.atguigu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt;

            &lt;!-- 阻止事件冒泡（常用） --&gt;
            &lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;
                &lt;button @click.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;
                &lt;!-- 修饰符可以连续写 --&gt;
                &lt;!-- &lt;a href=&quot;http://www.atguigu.com&quot; @click.prevent.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt; --&gt;
            &lt;/div&gt;

            &lt;!-- 事件只触发一次（常用） --&gt;
            &lt;button @click.once=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;

            &lt;!-- 使用事件的捕获模式 --&gt;
            &lt;div class=&quot;box1&quot; @click.capture=&quot;showMsg(1)&quot;&gt;
                div1
                &lt;div class=&quot;box2&quot; @click=&quot;showMsg(2)&quot;&gt;
                    div2
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- 只有event.target是当前操作的元素时才触发事件； --&gt;
            &lt;div class=&quot;demo1&quot; @click.self=&quot;showInfo&quot;&gt;
                &lt;button @click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;
            &lt;/div&gt;

            &lt;!-- 事件的默认行为立即执行，无需等待事件回调执行完毕； --&gt;
            &lt;ul @wheel.passive=&quot;demo&quot; class=&quot;list&quot;&gt;
                &lt;li&gt;1&lt;/li&gt;
                &lt;li&gt;2&lt;/li&gt;
                &lt;li&gt;3&lt;/li&gt;
                &lt;li&gt;4&lt;/li&gt;
            &lt;/ul&gt;

        &lt;/div&gt;
    &lt;/body&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

        new Vue({
            el:&#39;#root&#39;,
            data:{
                name:&#39;尚硅谷&#39;
            },
            methods:{
                showInfo(e){
                    alert(&#39;同学你好！&#39;)
                    // console.log(e.target)
                },
                showMsg(msg){
                    console.log(msg)
                },
                demo(){
                    for (let i = 0; i &lt; 100000; i++) {
                        console.log(&#39;#&#39;)
                    }
                    console.log(&#39;累坏了&#39;)
                }
            }
        })
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3>键盘事件</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;键盘事件&lt;/title&gt;
        &lt;!-- 引入Vue --&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 
                1.Vue中常用的按键别名：
                            回车 =&gt; enter
                            删除 =&gt; delete (捕获“删除”和“退格”键)
                            退出 =&gt; esc
                            空格 =&gt; space
                            换行 =&gt; tab (特殊，必须配合keydown去使用)
                            上 =&gt; up
                            下 =&gt; down
                            左 =&gt; left
                            右 =&gt; right

                2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）

                3.系统修饰键（用法特殊）：ctrl、alt、shift、meta
                            (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。
                            (2).配合keydown使用：正常触发事件。

                4.也可以使用keyCode去指定具体的按键（不推荐）

                5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名
        --&gt;
        &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            &lt;h2&gt;欢迎来到{{name}}学习&lt;/h2&gt;
            &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keydown.huiche=&quot;showInfo&quot;&gt;
        &lt;/div&gt;
    &lt;/body&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。
        Vue.config.keyCodes.huiche = 13 //定义了一个别名按键

        new Vue({
            el:&#39;#root&#39;,
            data:{
                name:&#39;尚硅谷&#39;
            },
            methods: {
                showInfo(e){
                    // console.log(e.key,e.keyCode)
                    console.log(e.target.value)
                }
            },
        })
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2>计算属性</h2>
<h3>Objcet.defineproperty</h3>
<p><img src="typora-user-images.assets/image-20230403200255951.png" alt="image-20230403200255951"></p>
<p><strong>计算属性：</strong>
<strong>1.定义：要用的属性不存在，要通过已有属性计算得来。</strong>
<strong>2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。</strong>
<strong>3.get函数什么时候执行？</strong>
<strong>(1).初次读取时会执行一次。</strong>
<strong>(2).当依赖的数据发生改变时会被再次调用。</strong>
<strong>4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</strong>
<strong>5.备注：</strong>
<strong>1.计算属性最终会出现在vm上，直接读取使用即可。</strong>
<strong>2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</strong></p>
<pre><code class="language-vue">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;姓名案例_计算属性实现&lt;/title&gt;
        &lt;!-- 引入Vue --&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;!-- 
    --&gt;
        &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            测试：&lt;input type=&quot;text&quot; v-model=&quot;x&quot;&gt; &lt;br/&gt;&lt;br/&gt;
            全名：&lt;span&gt;{{fullName}}&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;
            &lt;!-- 全名：&lt;span&gt;{{fullName}}&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;
            全名：&lt;span&gt;{{fullName}}&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;
            全名：&lt;span&gt;{{fullName}}&lt;/span&gt; --&gt;
        &lt;/div&gt;
    &lt;/body&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

        const vm = new Vue({
            el:&#39;#root&#39;,
            data:{
                firstName:&#39;张&#39;,
                lastName:&#39;三&#39;,
                x:&#39;你好&#39;
            },
            methods: {
                demo(){
                    
                }
            },
            computed:{
                fullName:{
                    //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值
                    //get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。
                    get(){
                        console.log(&#39;get被调用了&#39;)
                        // console.log(this) //此处的this是vm
                        return this.firstName + &#39;-&#39; + this.lastName
                    },
                    //set什么时候调用? 当fullName被修改时。
                    set(value){
                        console.log(&#39;set&#39;,value)
                        const arr = value.split(&#39;-&#39;)
                        this.firstName = arr[0]
                        this.lastName = arr[1]
                    }
                }
            }
        })
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3>计算属性简写</h3>
<p><img src="typora-user-images.assets/image-20230403201319721.png" alt="image-20230403201319721"></p>
<p><img src="typora-user-images.assets/image-20230403202225544.png" alt="image-20230403202225544"></p>
<h2>监听属性</h2>
<p><strong>监视属性watch：</strong>
<strong>1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作</strong>
<strong>2.监视的属性必须存在，才能进行监视！！</strong>
<strong>3.监视的两种写法：</strong>
<strong>(1).new Vue时传入watch配置</strong>
<strong>(2).通过vm.$watch监视</strong></p>
<pre><code class="language-vue">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;天气案例_监视属性&lt;/title&gt;
        &lt;!-- 引入Vue --&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 
         --&gt;
        &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;
            &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;
        &lt;/div&gt;
    &lt;/body&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
            el:&#39;#root&#39;,
            data:{
                isHot:true,
            },
            computed:{
                info(){
                    return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;
                }
            },
            methods: {
                changeWeather(){
                    this.isHot = !this.isHot
                }
            },
            /* watch:{
                isHot:{
                    immediate:true, //初始化时让handler调用一下
                    //handler什么时候调用？当isHot发生改变时。
                    handler(newValue,oldValue){
                        console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
                    }
                }
            } */
        })

        vm.$watch(&#39;isHot&#39;,{
            immediate:true, //初始化时让handler调用一下
            //handler什么时候调用？当isHot发生改变时。
            handler(newValue,oldValue){
                console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
            }
        })
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><img src="typora-user-images.assets/image-20230403202645337.png" alt="image-20230403202645337"></p>
<h4>*</h4>
<p>isHot是个key值，也就是个字符串，正规写法为&quot;isHot&quot;</p>
<p><img src="typora-user-images.assets/image-20230403202941350.png" alt="image-20230403202941350"></p>
<p><strong>深度监视：</strong>
<strong>(1).Vue中的watch默认不监测对象内部值的改变（一层）。</strong>
<strong>(2).配置deep:true可以监测对象内部值改变（多层）。</strong>
<strong>备注：</strong>
<strong>(1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！</strong>
<strong>(2).使用watch时根据数据的具体结构，决定是否采用深度监视。</strong></p>
<pre><code class="language-vue">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;天气案例_深度监视&lt;/title&gt;
        &lt;!-- 引入Vue --&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;!-- 
         --&gt;
        &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;
            &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;
            &lt;hr/&gt;
            &lt;h3&gt;a的值是:{{numbers.a}}&lt;/h3&gt;
            &lt;button @click=&quot;numbers.a++&quot;&gt;点我让a+1&lt;/button&gt;
            &lt;h3&gt;b的值是:{{numbers.b}}&lt;/h3&gt;
            &lt;button @click=&quot;numbers.b++&quot;&gt;点我让b+1&lt;/button&gt;
            &lt;button @click=&quot;numbers = {a:666,b:888}&quot;&gt;彻底替换掉numbers&lt;/button&gt;
            {{numbers.c.d.e}}
        &lt;/div&gt;
    &lt;/body&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。
        
        const vm = new Vue({
            el:&#39;#root&#39;,
            data:{
                isHot:true,
                numbers:{
                    a:1,
                    b:1,
                    c:{
                        d:{
                            e:100
                        }
                    }
                }
            },
            computed:{
                info(){
                    return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;
                }
            },
            methods: {
                changeWeather(){
                    this.isHot = !this.isHot
                }
            },
            watch:{
                isHot:{
                    // immediate:true, //初始化时让handler调用一下
                    //handler什么时候调用？当isHot发生改变时。
                    handler(newValue,oldValue){
                        console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
                    }
                },
                //监视多级结构中某个属性的变化
                /* &#39;numbers.a&#39;:{
                    handler(){
                        console.log(&#39;a被改变了&#39;)
                    }
                } */
                //监视多级结构中所有属性的变化
                numbers:{
                    deep:true,
                    handler(){
                        console.log(&#39;numbers改变了&#39;)
                    }
                }
            }
        })

    &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-vue">watch:{
    //正常写法
    /* isHot:{
    // immediate:true, //初始化时让handler调用一下
    // deep:true,//深度监视
    handler(newValue,oldValue){
    console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
}
}, */
//简写
/* isHot(newValue,oldValue){
        console.log(&#39;isHot被修改了&#39;,newValue,oldValue,this)
} */
}
})

//正常写法
/* vm.$watch(&#39;isHot&#39;,{
    immediate:true, //初始化时让handler调用一下
    deep:true,//深度监视
    handler(newValue,oldValue){
    console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
}
}) */

//简写
/* vm.$watch(&#39;isHot&#39;,(newValue,oldValue)=&gt;{
    console.log(&#39;isHot被修改了&#39;,newValue,oldValue,this)
}) */
</code></pre>
<h2>计算属性&amp;监听属性</h2>
<p><img src="typora-user-images.assets/image-20230403205331338.png" alt="image-20230403205331338"></p>
<p><strong>返回undefined,计算属性完全靠返回值，目前还办不到让返回值等一等再返回</strong></p>
<p>面临异步任务时，使用watch</p>
<p> computed和watch之间的区别：</p>
<p>1.computed能完成的功能，watch都可以完成。</p>
<p>2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</p>
<p>两个重要的小原则：</p>
<p><strong>1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</strong></p>
<p><strong>2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，</strong></p>
<p>​                <strong>这样this的指向才是vm 或 组件实例对象。</strong></p>
<h2><strong>Vue核心 绑定样式 条件渲染</strong></h2>
<h3>绑定样式</h3>
<pre><code class="language-vue">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;绑定样式&lt;/title&gt;
        &lt;style&gt;
            .basic{
                width: 400px;
                height: 100px;
                border: 1px solid black;
            }
            
            .happy{
                border: 4px solid red;;
                background-color: rgba(255, 255, 0, 0.644);
                background: linear-gradient(30deg,yellow,pink,orange,yellow);
            }
            .sad{
                border: 4px dashed rgb(2, 197, 2);
                background-color: gray;
            }
            .normal{
                background-color: skyblue;
            }

            .atguigu1{
                background-color: yellowgreen;
            }
            .atguigu2{
                font-size: 30px;
                text-shadow:2px 2px 10px red;
            }
            .atguigu3{
                border-radius: 20px;
            }
        &lt;/style&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 
            绑定样式：
                    1. class样式
                                写法:class=&quot;xxx&quot; xxx可以是字符串、对象、数组。
                                        字符串写法适用于：类名不确定，要动态获取。
                                        对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。
                                        数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。
                    2. style样式
                                :style=&quot;{fontSize: xxx}&quot;其中xxx是动态值。
                                :style=&quot;[a,b]&quot;其中a、b是样式对象。
        --&gt;
        &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            &lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt;
            &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt;

            &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --&gt;
            &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt;

            &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt;
            &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt;

            &lt;!-- 绑定style样式--对象写法 --&gt;
            &lt;div class=&quot;basic&quot; :style=&quot;styleObj&quot;&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt;
            &lt;!-- 绑定style样式--数组写法 --&gt;
            &lt;div class=&quot;basic&quot; :style=&quot;styleArr&quot;&gt;{{name}}&lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        Vue.config.productionTip = false
        
        const vm = new Vue({
            el:&#39;#root&#39;,
            data:{
                name:&#39;尚硅谷&#39;,
                mood:&#39;normal&#39;,
                classArr:[&#39;atguigu1&#39;,&#39;atguigu2&#39;,&#39;atguigu3&#39;],
                classObj:{
                    atguigu1:false,
                    atguigu2:false,
                },
                styleObj:{
                    fontSize: &#39;40px&#39;,
                    color:&#39;red&#39;,
                },
                styleObj2:{
                    backgroundColor:&#39;orange&#39;
                },
                styleArr:[
                    {
                        fontSize: &#39;40px&#39;,
                        color:&#39;blue&#39;,
                    },
                    {
                        backgroundColor:&#39;gray&#39;
                    }
                ]
            },
            methods: {
                changeMood(){
                    const arr = [&#39;happy&#39;,&#39;sad&#39;,&#39;normal&#39;]
                    const index = Math.floor(Math.random()*3)
                    this.mood = arr[index]
                }
            },
        })
    &lt;/script&gt;
    
&lt;/html&gt;
</code></pre>
<h3>条件渲染</h3>
<p><img src="typora-user-images.assets/image-20230403211945513.png" alt="image-20230403211945513"></p>
<h2><strong>Vue核心 列表渲染 数据监视</strong></h2>
<h3>v-for指令:</h3>
<p>​            1.用于展示列表数据</p>
<p>​            2.语法：v-for=&quot;(item, index) in xxx&quot; :key=&quot;yyy&quot;</p>
<p>​            3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</p>
<pre><code class="language-vue">    &lt;body&gt;
        &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            &lt;!-- 遍历数组 --&gt;
            &lt;h2&gt;人员列表（遍历数组）&lt;/h2&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;index&quot;&gt;
                    {{p.name}}-{{p.age}}
                &lt;/li&gt;
            &lt;/ul&gt;

            &lt;!-- 遍历对象 --&gt;
            &lt;h2&gt;汽车信息（遍历对象）&lt;/h2&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;(value,k) of car&quot; :key=&quot;k&quot;&gt;
                    {{k}}-{{value}}
                &lt;/li&gt;
            &lt;/ul&gt;

            &lt;!-- 遍历字符串 --&gt;
            &lt;h2&gt;测试遍历字符串（用得少）&lt;/h2&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;(char,index) of str&quot; :key=&quot;index&quot;&gt;
                    {{char}}-{{index}}
                &lt;/li&gt;
            &lt;/ul&gt;
            
            &lt;!-- 遍历指定次数 --&gt;
            &lt;h2&gt;测试遍历指定次数（用得少）&lt;/h2&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;(number,index) of 5&quot; :key=&quot;index&quot;&gt;
                    {{index}}-{{number}}
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;

        &lt;script type=&quot;text/javascript&quot;&gt;
            Vue.config.productionTip = false
            
            new Vue({
                el:&#39;#root&#39;,
                data:{
                    persons:[
                        {id:&#39;001&#39;,name:&#39;张三&#39;,age:18},
                        {id:&#39;002&#39;,name:&#39;李四&#39;,age:19},
                        {id:&#39;003&#39;,name:&#39;王五&#39;,age:20}
                    ],
                    car:{
                        name:&#39;奥迪A8&#39;,
                        price:&#39;70万&#39;,
                        color:&#39;黑色&#39;
                    },
                    str:&#39;hello&#39;
                }
            })
        &lt;/script&gt;
</code></pre>
<p><img src="typora-user-images.assets/image-20230404103114805.png" alt="image-20230404103114805"></p>
<h3>面试题：react、vue中的key有什么作用？diff算法（key的内部原理）</h3>
<p>​                        </p>
<h4>虚拟DOM中key的作用：</h4>
<p>变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 
随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p>
<p>对比规则：
                                    (1).旧虚拟DOM中找到了与新虚拟DOM相同的key：
                                                ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！
                                                ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p>
<p>​                                    (2).旧虚拟DOM中未找到与新虚拟DOM相同的key
​                                                创建新的真实DOM，随后渲染到到页面。
​                                                </p>
<h4>用index作为key可能会引发的问题：</h4>
<p>破坏顺序操作:
会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</p>
<p>如果结构中还包含输入类的DOM：
    会产生错误DOM更新 ==&gt; 界面有问题。</p>
<p>开发中如何选择key?:
1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。
2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，
使用index作为key是没有问题的。</p>
<pre><code class="language-vue">        &lt;div id=&quot;root&quot;&gt;
            &lt;!-- 遍历数组 --&gt;
            &lt;h2&gt;人员列表（遍历数组）&lt;/h2&gt;
            &lt;button @click.once=&quot;add&quot;&gt;添加一个老刘&lt;/button&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;index&quot;&gt;
                    {{p.name}}-{{p.age}}
                    &lt;input type=&quot;text&quot;&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;

        &lt;script type=&quot;text/javascript&quot;&gt;
            Vue.config.productionTip = false
            
            new Vue({
                el:&#39;#root&#39;,
                data:{
                    persons:[
                        {id:&#39;001&#39;,name:&#39;张三&#39;,age:18},
                        {id:&#39;002&#39;,name:&#39;李四&#39;,age:19},
                        {id:&#39;003&#39;,name:&#39;王五&#39;,age:20}
                    ]
                },
                methods: {
                    add(){
                        const p = {id:&#39;004&#39;,name:&#39;老刘&#39;,age:40}
                        this.persons.unshift(p)
                    }
                },
            })
        &lt;/script&gt;
</code></pre>
<h4>图解</h4>
<p>index作为key,可能出现错误</p>
<p><img src="typora-user-images.assets/image-20230404105007033.png" alt="image-20230404105007033"></p>
<h3>列表过滤</h3>
<p><img src="typora-user-images.assets/image-20230404110429073.png" alt="image-20230404110429073"></p>
<h4>注意：</h4>
<p>​	<strong>“”也包含在字符串中，且由indexof方法返回值不为-1</strong></p>
<p>​	<strong>filter不破坏原数组，且会有一个返回值，注意接收</strong></p>
<p>​	下面的watch属性，如果写成：</p>
<pre><code>handler(val){
this.persons = this.persons.filter((p)=&gt;{
return p.name.indexOf(val) !== -1
})
}
</code></pre>
<p>则数据会越来越少</p>
<pre><code class="language-vue">    &lt;body&gt;
        &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            &lt;h2&gt;人员列表&lt;/h2&gt;
            &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;(p,index) of filPerons&quot; :key=&quot;index&quot;&gt;
                    {{p.name}}-{{p.age}}-{{p.sex}}
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;

        &lt;script type=&quot;text/javascript&quot;&gt;
            Vue.config.productionTip = false
            
            //用watch实现
            //#region 
            /* new Vue({
                el:&#39;#root&#39;,
                data:{
                    keyWord:&#39;&#39;,
                    persons:[
                        {id:&#39;001&#39;,name:&#39;马冬梅&#39;,age:19,sex:&#39;女&#39;},
                        {id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:20,sex:&#39;女&#39;},
                        {id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:21,sex:&#39;男&#39;},
                        {id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:22,sex:&#39;男&#39;}
                    ],
                    filPerons:[]
                },
                watch:{
                    keyWord:{
                        immediate:true,
                        handler(val){
                            this.filPerons = this.persons.filter((p)=&gt;{
                                return p.name.indexOf(val) !== -1
                            })
                        }
                    }
                }
            }) */
            //#endregion
            
            //用computed实现
            new Vue({
                el:&#39;#root&#39;,
                data:{
                    keyWord:&#39;&#39;,
                    persons:[
                        {id:&#39;001&#39;,name:&#39;马冬梅&#39;,age:19,sex:&#39;女&#39;},
                        {id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:20,sex:&#39;女&#39;},
                        {id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:21,sex:&#39;男&#39;},
                        {id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:22,sex:&#39;男&#39;}
                    ]
                },
                computed:{
                    filPerons(){
                        return this.persons.filter((p)=&gt;{
                            return p.name.indexOf(this.keyWord) !== -1
                        })
                    }
                }
            }) 
        &lt;/script&gt;
</code></pre>
<h3>列表排序</h3>
<pre><code class="language-vue">    &lt;body&gt;
        &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            &lt;h2&gt;人员列表&lt;/h2&gt;
            &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&gt;
            &lt;button @click=&quot;sortType = 2&quot;&gt;年龄升序&lt;/button&gt;
            &lt;button @click=&quot;sortType = 1&quot;&gt;年龄降序&lt;/button&gt;
            &lt;button @click=&quot;sortType = 0&quot;&gt;原顺序&lt;/button&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;(p,index) of filPerons&quot; :key=&quot;p.id&quot;&gt;
                    {{p.name}}-{{p.age}}-{{p.sex}}
                    &lt;input type=&quot;text&quot;&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;

        &lt;script type=&quot;text/javascript&quot;&gt;
            Vue.config.productionTip = false
            
            new Vue({
                el:&#39;#root&#39;,
                data:{
                    keyWord:&#39;&#39;,
                    sortType:0, //0原顺序 1降序 2升序
                    persons:[
                        {id:&#39;001&#39;,name:&#39;马冬梅&#39;,age:30,sex:&#39;女&#39;},
                        {id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:31,sex:&#39;女&#39;},
                        {id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:18,sex:&#39;男&#39;},
                        {id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:19,sex:&#39;男&#39;}
                    ]
                },
                computed:{
                    filPerons(){
                        const arr = this.persons.filter((p)=&gt;{
                            return p.name.indexOf(this.keyWord) !== -1
                        })
                        //判断一下是否需要排序
                        if(this.sortType){
                            arr.sort((p1,p2)=&gt;{
                                return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age
                            })
                        }
                        return arr
                    }
                }
            }) 

        &lt;/script&gt;
</code></pre>
<h4>注意：</h4>
<p>​	理清0原顺序 1降序 2升序的实现流程</p>
<h3>更新时的一个问题</h3>
<pre><code class="language-vue">    &lt;body&gt;
        &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            &lt;h2&gt;人员列表&lt;/h2&gt;
            &lt;button @click=&quot;updateMei&quot;&gt;更新马冬梅的信息&lt;/button&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;p.id&quot;&gt;
                    {{p.name}}-{{p.age}}-{{p.sex}}
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;

        &lt;script type=&quot;text/javascript&quot;&gt;
            Vue.config.productionTip = false
            
            const vm = new Vue({
                el:&#39;#root&#39;,
                data:{
                    persons:[
                        {id:&#39;001&#39;,name:&#39;马冬梅&#39;,age:30,sex:&#39;女&#39;},
                        {id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:31,sex:&#39;女&#39;},
                        {id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:18,sex:&#39;男&#39;},
                        {id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:19,sex:&#39;男&#39;}
                    ]
                },
                methods: {
                    updateMei(){
                        // this.persons[0].name = &#39;马老师&#39; //奏效
                        // this.persons[0].age = 50 //奏效
                        // this.persons[0].sex = &#39;男&#39; //奏效
                        // this.persons[0] = {id:&#39;001&#39;,name:&#39;马老师&#39;,age:50,sex:&#39;男&#39;} //不奏效
                        this.persons.splice(0,1,{id:&#39;001&#39;,name:&#39;马老师&#39;,age:50,sex:&#39;男&#39;})
                    }
                }
            }) 

        &lt;/script&gt;
</code></pre>
<p>事实上，确实改变了数组，但是Vue监测不到，可以用const vm = new Vue来接收一下实例对象，打印如下：</p>
<h4><img src="typora-user-images.assets/image-20230404112837741.png" alt="image-20230404112837741">关于数组的元素没有get set的问题</h4>
<p>想要生效，让VUE监测到数组发生更改，需要用pop push shift unshift sort splice resverse 方法更改数组 或者使用Vue.set   vm.$set，但是注意：数组的每个元素没有get set，但是如果元素是个对象，那么对象里相应的属性是有get set的，也就是</p>
<pre><code class="language-vue">&lt;button @click=&quot;updateFirstFriendName&quot;&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br/&gt;

friends:[
{name:&#39;jerry&#39;,age:35},
{name:&#39;tony&#39;,age:36}
]

updateFirstFriendName(){
this.student.friends[0].name = &#39;张三&#39;
},
</code></pre>
<p>也就是说name是有get set的，这个操作vue是可以监测到的</p>
<h3>数据监测的原理</h3>
<p><img src="typora-user-images.assets/image-20230404114617046.png" alt="image-20230404114617046"></p>
<p><img src="typora-user-images.assets/image-20230404115241674.png" alt="image-20230404115241674"></p>
<p>用Objcet.defineproperty硬写数据监测，出现死循环</p>
<h4>！简写数据监测：</h4>
<pre><code class="language-vue">    &lt;body&gt;
        &lt;script type=&quot;text/javascript&quot; &gt;

            let data = {
                name:&#39;尚硅谷&#39;,
                address:&#39;北京&#39;,
            }

            //创建一个监视的实例对象，用于监视data中属性的变化
            const obs = new Observer(data)		
            console.log(obs)	

            //准备一个vm实例对象
            let vm = {}
            vm._data = data = obs

            function Observer(obj){
                //汇总对象中所有的属性形成一个数组
                const keys = Object.keys(obj)
                //遍历
                keys.forEach((k)=&gt;{
                //this是Obsersver的实例对象，是不会重复死循环的关键
                    Object.defineProperty(this,k,{
                        get(){
                            return obj[k]
                        },
                        set(val){
                            console.log(`${k}被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了`)
                            obj[k] = val
                        }
                    })
                })
            }
        &lt;/script&gt;
    &lt;/body&gt;
</code></pre>
<h4>解决后添加的属性没有get和set属性的问题</h4>
<h5>Vue.set &amp;  vm.$set</h5>
<p><img src="typora-user-images.assets/image-20230404130526741.png" alt="image-20230404130526741"></p>
<pre><code class="language-vue">    &lt;body&gt;
        &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            &lt;h1&gt;学校信息&lt;/h1&gt;
            &lt;h2&gt;学校名称：{{school.name}}&lt;/h2&gt;
            &lt;h2&gt;学校地址：{{school.address}}&lt;/h2&gt;
            &lt;h2&gt;校长是：{{school.leader}}&lt;/h2&gt;
            &lt;hr/&gt;
            &lt;h1&gt;学生信息&lt;/h1&gt;
            &lt;button @click=&quot;addSex&quot;&gt;添加一个性别属性，默认值是男&lt;/button&gt;
            &lt;h2&gt;姓名：{{student.name}}&lt;/h2&gt;
            &lt;h2 v-if=&quot;student.sex&quot;&gt;性别：{{student.sex}}&lt;/h2&gt;
            &lt;h2&gt;年龄：真实{{student.age.rAge}}，对外{{student.age.sAge}}&lt;/h2&gt;
            &lt;h2&gt;朋友们&lt;/h2&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;(f,index) in student.friends&quot; :key=&quot;index&quot;&gt;
                    {{f.name}}--{{f.age}}
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/body&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

        const vm = new Vue({
            el:&#39;#root&#39;,
            data:{
                school:{
                    name:&#39;尚硅谷&#39;,
                    address:&#39;北京&#39;,
                },
                student:{
                    name:&#39;tom&#39;,
                    age:{
                        rAge:40,
                        sAge:29,
                    },
                    friends:[
                        {name:&#39;jerry&#39;,age:35},
                        {name:&#39;tony&#39;,age:36}
                    ]
                }
            },
            methods: {
                addSex(){
                    // Vue.set(this.student,&#39;sex&#39;,&#39;男&#39;)
                    this.$set(this.student,&#39;sex&#39;,&#39;男&#39;)
                }
            }
        })
    &lt;/script&gt;
</code></pre>
<h4>总结： Vue监视数据的原理：</h4>
<ol>
<li><p><strong>vue会监视data中所有层次的数据。</strong></p>
</li>
<li><p><strong>如何监测对象中的数据？</strong></p>
</li>
</ol>
<p>​                <strong>通过setter实现监视，且要在new Vue时就传入要监测的数据。</strong></p>
<p>​                  <strong>(1).对象中后追加的属性，Vue默认不做响应式处理</strong></p>
<p>​                  <strong>(2).如需给后添加的属性做响应式，请使用如下API：</strong></p>
<p>​                          <strong>Vue.set(target，propertyName/index，value) 或</strong> </p>
<p>​                          <strong>vm.$set(target，propertyName/index，value)</strong></p>
<ol start="3">
<li><strong>如何监测数组中的数据？</strong></li>
</ol>
<p>​                  <strong>通过包裹数组更新元素的方法实现，本质就是做了两件事：</strong></p>
<p>​                    <strong>(1).调用原生对应的方法对数组进行更新。</strong></p>
<p>​                    <strong>(2).重新解析模板，进而更新页面。</strong></p>
<p><strong>4.在Vue修改数组中的某个元素一定要用如下方法：</strong></p>
<p>​              <strong>1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</strong></p>
<p>​              <strong>2.Vue.set() 或 vm.$set()</strong></p>
<p>​        </p>
<p>​        特别注意：<strong>Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</strong></p>
<pre><code class="language-vue">    &lt;body&gt;
        &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            &lt;h1&gt;学生信息&lt;/h1&gt;
            &lt;button @click=&quot;student.age++&quot;&gt;年龄+1岁&lt;/button&gt; &lt;br/&gt;
            &lt;button @click=&quot;addSex&quot;&gt;添加性别属性，默认值：男&lt;/button&gt; &lt;br/&gt;
            &lt;button @click=&quot;student.sex = &#39;未知&#39; &quot;&gt;修改性别&lt;/button&gt; &lt;br/&gt;
            &lt;button @click=&quot;addFriend&quot;&gt;在列表首位添加一个朋友&lt;/button&gt; &lt;br/&gt;
            &lt;button @click=&quot;updateFirstFriendName&quot;&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br/&gt;
            &lt;button @click=&quot;addHobby&quot;&gt;添加一个爱好&lt;/button&gt; &lt;br/&gt;
            &lt;button @click=&quot;updateHobby&quot;&gt;修改第一个爱好为：开车&lt;/button&gt; &lt;br/&gt;
            &lt;button @click=&quot;removeSmoke&quot;&gt;过滤掉爱好中的抽烟&lt;/button&gt; &lt;br/&gt;
            &lt;h3&gt;姓名：{{student.name}}&lt;/h3&gt;
            &lt;h3&gt;年龄：{{student.age}}&lt;/h3&gt;
            &lt;h3 v-if=&quot;student.sex&quot;&gt;性别：{{student.sex}}&lt;/h3&gt;
            &lt;h3&gt;爱好：&lt;/h3&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;(h,index) in student.hobby&quot; :key=&quot;index&quot;&gt;
                    {{h}}
                &lt;/li&gt;
            &lt;/ul&gt;
            &lt;h3&gt;朋友们：&lt;/h3&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;(f,index) in student.friends&quot; :key=&quot;index&quot;&gt;
                    {{f.name}}--{{f.age}}
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/body&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

        const vm = new Vue({
            el:&#39;#root&#39;,
            data:{
                student:{
                    name:&#39;tom&#39;,
                    age:18,
                    hobby:[&#39;抽烟&#39;,&#39;喝酒&#39;,&#39;烫头&#39;],
                    friends:[
                        {name:&#39;jerry&#39;,age:35},
                        {name:&#39;tony&#39;,age:36}
                    ]
                }
            },
            methods: {
                addSex(){
                    // Vue.set(this.student,&#39;sex&#39;,&#39;男&#39;)
                    this.$set(this.student,&#39;sex&#39;,&#39;男&#39;)
                },
                addFriend(){
                    this.student.friends.unshift({name:&#39;jack&#39;,age:70})
                },
                updateFirstFriendName(){
                    this.student.friends[0].name = &#39;张三&#39;
                },
                addHobby(){
                    this.student.hobby.push(&#39;学习&#39;)
                },
                updateHobby(){
                    // this.student.hobby.splice(0,1,&#39;开车&#39;)
                    // Vue.set(this.student.hobby,0,&#39;开车&#39;)
                    this.$set(this.student.hobby,0,&#39;开车&#39;)
                },
                removeSmoke(){
                    this.student.hobby = this.student.hobby.filter((h)=&gt;{
                        return h !== &#39;抽烟&#39;
                    })
                }
            }
        })
    &lt;/script&gt;
</code></pre>
<h2>收集表单数据</h2>
<h3>收集表单数据：</h3>
<p><strong>若</strong>：<input type="text"/>，则v-model收集的是value值，用户输入的就是value值。**
<strong>若：<input type="radio"/>，则v-model收集的是value值，且要给标签配置value值。</strong>
<strong>若：<input type="checkbox"/></strong>
        <strong>1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</strong>
        <strong>2.配置input的value属性:</strong>
                    <strong>(1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）</strong>
                    <strong>(2)v-model的初始值是数组，那么收集的的就是value组成的数组</strong>
<strong>备注：v-model的三个修饰符：</strong>
            <strong>lazy：失去焦点再收集数据</strong>
            <strong>number：输入字符串转为有效的数字</strong>
            <strong>trim：输入首尾空格过滤</strong></p>
<pre><code>&lt;form @submit.prevent=&quot;demo&quot;&gt;
&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot;&gt;
JSON.stringify(this.userInfo)
</code></pre>
<pre><code class="language-vue">&lt;body&gt;

        &lt;!-- 准备好一个容器--&gt;
        &lt;div id=&quot;root&quot;&gt;
            &lt;form @submit.prevent=&quot;demo&quot;&gt;
                账号：&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.account&quot;&gt; &lt;br/&gt;&lt;br/&gt;
                密码：&lt;input type=&quot;password&quot; v-model=&quot;userInfo.password&quot;&gt; &lt;br/&gt;&lt;br/&gt;
                年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot;&gt; &lt;br/&gt;&lt;br/&gt;
                性别：
                男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot;&gt;
                女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;female&quot;&gt; &lt;br/&gt;&lt;br/&gt;
                爱好：
                学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot;&gt;
                打游戏&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;game&quot;&gt;
                吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;eat&quot;&gt;
                &lt;br/&gt;&lt;br/&gt;
                所属校区
                &lt;select v-model=&quot;userInfo.city&quot;&gt;
                    &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt;
                    &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;
                    &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;
                    &lt;option value=&quot;shenzhen&quot;&gt;深圳&lt;/option&gt;
                    &lt;option value=&quot;wuhan&quot;&gt;武汉&lt;/option&gt;
                &lt;/select&gt;
                &lt;br/&gt;&lt;br/&gt;
                其他信息：
                &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt; &lt;br/&gt;&lt;br/&gt;
                &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot;&gt;阅读并接受&lt;a href=&quot;http://www.atguigu.com&quot;&gt;《用户协议》&lt;/a&gt;
                &lt;button&gt;提交&lt;/button&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    &lt;/body&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        Vue.config.productionTip = false

        new Vue({
            el:&#39;#root&#39;,
            data:{
                userInfo:{
                    account:&#39;&#39;,
                    password:&#39;&#39;,
                    age:18,
                    sex:&#39;female&#39;,
                    hobby:[],
                    city:&#39;beijing&#39;,
                    other:&#39;&#39;,
                    agree:&#39;&#39;
                }
            },
            methods: {
                demo(){
                    console.log(JSON.stringify(this.userInfo))
                }
            }
        })
    &lt;/script&gt;
</code></pre>
<h2>过滤器</h2>
<p>​      过滤器：</p>
<p>​        定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。</p>
<p>​        语法：</p>
<p>​            1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}</p>
<p>​            2.使用过滤器：{{ xxx | 过滤器名}}  或  v-bind:属性 = &quot;xxx | 过滤器名&quot;</p>
<p>​        备注：</p>
<p>​            1.过滤器也可以接收额外参数、多个过滤器也可以串联</p>
<p>​            2.并没有改变原本的数据, 是产生新的对应的数据</p>
<h2>指令</h2>
<p>​        我们学过的指令：</p>
<p>​            v-bind  : 单向绑定解析表达式, 可简写为 :xxx</p>
<p>​            v-model : 双向数据绑定</p>
<p>​            v-for  : 遍历数组/对象/字符串</p>
<p>​            v-on   : 绑定事件监听, 可简写为@</p>
<p>​            v-if     : 条件渲染（动态控制节点是否存存在）</p>
<p>​            v-else  : 条件渲染（动态控制节点是否存存在）</p>
<p>​            v-show  : 条件渲染 (动态控制节点是否展示)</p>
<h3>v-text</h3>
<p>​            1.作用：向其所在的节点中渲染文本内容。</p>
<p>​            2.与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会。</p>
<h3>v-html</h3>
<p>​            1.作用：向指定节点中渲染包含html结构的内容。</p>
<p>​            2.与插值语法的区别：</p>
<p>​                  (1).v-html会替换掉节点中所有的内容，{{xx}}则不会。</p>
<p>​                  (2).v-html可以识别html结构。</p>
<p>​            3.严重注意：v-html有安全性问题！！！！</p>
<p>​                  (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</p>
<p>​                  (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</p>
<h3>v-cloak</h3>
<p>​            1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</p>
<p>​            2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。</p>
<h3>v-once指令：</h3>
<p>​            1.v-once所在节点在初次动态渲染后，就视为静态内容了。</p>
<p>​            2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</p>
<h3>v-pre指令：</h3>
<p>​          1.跳过其所在节点的编译过程。</p>
<p>​          2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</p>
<h3>自定义指令</h3>
<pre><code>自定义指令总结：
一、定义语法：
(1).局部指令：
new Vue({							new Vue({
directives:{指令名:配置对象}   或   		directives{指令名:回调函数}
        }) 											})
(2).全局指令：
Vue.directive(指令名,配置对象) 或   Vue.directive(指令名,回调函数)

二、配置对象中常用的3个回调：
(1).bind：指令与元素成功绑定时调用。
(2).inserted：指令所在元素被插入页面时调用。
(3).update：指令所在模板结构被重新解析时调用。

三、备注：
1.指令定义时不加v-，但使用时要加v-；
2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。
        
</code></pre>
<pre><code class="language-vue">&lt;div id=&quot;root&quot;&gt;
            &lt;h2&gt;{{name}}&lt;/h2&gt;
            &lt;h2&gt;当前的n值是：&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt;
            &lt;!-- &lt;h2&gt;放大10倍后的n值是：&lt;span v-big-number=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt; --&gt;
            &lt;h2&gt;放大10倍后的n值是：&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt;
            &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;
            &lt;hr/&gt;
            &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    
    &lt;script type=&quot;text/javascript&quot;&gt;
        Vue.config.productionTip = false
        new Vue({
            el:&#39;#root&#39;,
            data:{
                name:&#39;尚硅谷&#39;,
                n:1
            },
            directives:{
                //big函数何时会被调用？1.指令与元素成功绑定时（一上来）。2.指令所在的模板被重新解析时。
                /* &#39;big-number&#39;(element,binding){
                    // console.log(&#39;big&#39;)
                    element.innerText = binding.value * 10
                }, */
                big(element,binding){
                    console.log(&#39;big&#39;,this) //注意此处的this是window
                    console.log(element)    //&lt;span&gt;10&lt;/span&gt;
                    console.log(binding)	//{name: &#39;big&#39;, rawName: &#39;v-big&#39;, value: 1, expression: &#39;n&#39;, modifiers: {…}, …}
                    element.innerText = binding.value * 10
                },
                fbind:{
                    //指令与元素成功绑定时（一上来）
                    bind(element,binding){
                        element.value = binding.value
                    },
                    //指令所在元素被插入页面时
                    inserted(element,binding){
                        element.focus()
                    },
                    //指令所在的模板被重新解析时
                    update(element,binding){
                        element.value = binding.value
                    }
                }
            }
        })
        
    &lt;/script&gt;
</code></pre>
<h2>生命周期</h2>
<h3>常用的生命周期钩子：</h3>
<p>​            1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</p>
<p>​            2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</p>
<h3>关于销毁Vue实例</h3>
<p>​            1.销毁后借助Vue开发者工具看不到任何信息。</p>
<p>​            2.销毁后自定义事件会失效，但原生DOM事件依然有效。</p>
<p>​            3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p>
<h2>组件化编程</h2>
<h3>Vue中使用组件的三大步骤：</h3>
<p>​          一、定义组件(创建组件)</p>
<p>​          二、注册组件</p>
<p>​          三、使用组件(写组件标签)</p>
<h3>一、如何定义一个组件？</h3>
<p>​            使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；</p>
<p>​            区别如下：</p>
<p>​                1.el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。</p>
<p>​                2.data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。</p>
<p>​            备注：使用template可以配置组件结构。</p>
<h3>二、如何注册组件？</h3>
<p>​              1.局部注册：靠new Vue的时候传入components选项</p>
<p>​              2.全局注册：靠Vue.component(&#39;组件名&#39;,组件)</p>
<h3>三、编写组件标签：</h3>
<p>​              <school></school></p>
<h2>VueComponent</h2>
<p>1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。</p>
<p><strong>2.我们只需要写<school/>或<school></school>，Vue解析时会帮我们创建school组件的实例对象，</strong></p>
<p> <strong>即Vue帮我们执行的：new VueComponent(options)。</strong></p>
<p> 3.特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！</p>
<p> 4.关于this指向：</p>
<p>(1).组件配置中：</p>
<p>​      data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。</p>
<p> (2).new Vue(options)配置中：</p>
<p>​        data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。</p>
<p>5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。</p>
<p>​       Vue的实例对象，以后简称vm。</p>
<h2>原型</h2>
<p><img src="typora-user-images.assets/image-20230411214449579.png" alt="image-20230411214449579"></p>
<p>​        1.一个重要的内置关系：VueComponent.prototype.<strong>proto</strong> === Vue.prototype</p>
<p>​        2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</p>
<h2>JSON</h2>
<h3>保存为本地JSON文件</h3>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;home-div&quot;&gt;
    &lt;button @click=&quot;handledata&quot;&gt;数组处理&lt;/button&gt;
    &lt;button @click=&quot;download&quot;&gt;下载&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
 //这个放两个地方，一个index.html,一个组件自身
&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/FileSaver.js/2.0.5/FileSaver.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
export default {
  props: [&quot;testdata&quot;],
  data() {
    return {
      data: [],
    };
  },
  methods: {
    download() {
      var content = JSON.stringify({
        jiedao: this.data,
      });

      var blob = new Blob([content], {
        type: &quot;text/plain;charset=utf-8&quot;,
      });
      console.log(blob);
      saveAs(blob, &quot;data.json&quot;);
    },
    handledata() {
      console.log(this._props.testdata);
      this.data = this._props.testdata;
      this.data.forEach((item, index) =&gt; {
        let s1 = index / 300;
        item[2] = Math.floor(s1);
        return item;
      });
      console.log(this.data[400])
    },
  },
  mounted() {},
};
&lt;/script&gt;
</code></pre>
<h2>脚手架文件结构</h2>
<p>   ├── node_modules 
   ├── public
   │   ├── favicon.ico: 页签图标
   │   └── index.html: 主页面
   ├── src
   │   ├── assets: 存放静态资源
   │   │   └── logo.png
   │   │── component: 存放组件
   │   │   └── HelloWorld.vue
   │   │── App.vue: 汇总所有组件
   │   │── main.js: 入口文件
   ├── .gitignore: git版本管制忽略的配置
   ├── babel.config.js: babel的配置文件
   ├── package.json: 应用包配置文件 
   ├── README.md: 应用描述文件
   ├── package-lock.json：包版本控制文件</p>
<h2>关于不同版本的Vue</h2>
<ol>
<li>vue.js与vue.runtime.xxx.js的区别：<ol>
<li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li>
<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li>
</ol>
</li>
<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li>
</ol>
<h2>vue.config.js配置文件</h2>
<ol>
<li><p>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</p>
</li>
<li><p>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></p>
<h3>关闭语法检查</h3>
<pre><code>module.exports = {
  pages: {
    index: {
      //入口
      entry: &#39;src/main.js&#39;,
    },
  },
    lintOnSave:false, //关闭语法检查
    //开启代理服务器（方式一）
    /* devServer: {
    proxy: &#39;http://localhost:5000&#39;
  }, */
    //开启代理服务器（方式二）
    devServer: {
    proxy: {
      &#39;/atguigu&#39;: {
        target: &#39;http://localhost:5000&#39;,
                pathRewrite:{&#39;^/atguigu&#39;:&#39;&#39;},
        // ws: true, //用于支持websocket
        // changeOrigin: true //用于控制请求头中的host值
      },
      &#39;/demo&#39;: {
        target: &#39;http://localhost:5001&#39;,
                pathRewrite:{&#39;^/demo&#39;:&#39;&#39;},
        // ws: true, //用于支持websocket
        // changeOrigin: true //用于控制请求头中的host值
      }
    }
  }
}
</code></pre>
</li>
</ol>
<h2>ref属性</h2>
<ol>
<li><p>被用来给元素或子组件注册引用信息（id的替代者）</p>
</li>
<li><p>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</p>
</li>
<li><p>使用方式：</p>
<ol>
<li><p>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></p>
</li>
<li><p>获取：<code>this.$refs.xxx</code></p>
</li>
<li><p>得到一个组件实例对象</p>
<p><img src="typora-user-images.assets/image-20230412141714915.png" alt="image-20230412141714915"></p>
</li>
</ol>
</li>
</ol>
<h2>props配置项</h2>
<ol>
<li><p>功能：让组件接收外部传过来的数据,传到了组件实例vc身上</p>
</li>
<li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p>
</li>
<li><p>接收数据：</p>
<ol>
<li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p>
<pre><code>区别age=&quot;18&quot; 和 :age=&quot;18&quot; 一个是传了一个字符串，右边的是传了&quot;&quot;里的JS表达式的结果，也就是数字18
</code></pre>
<p> <img src="typora-user-images.assets/image-20230412142422631.png" alt="image-20230412142422631"></p>
</li>
<li><p>第二种方式（限制类型）：<code>props:{name:String}</code></p>
</li>
<li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
<pre><code class="language-js">props:{
 name:{
 type:String, //类型
 required:true, //必要性
 default:&#39;老王&#39; //默认值
 }
}
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>
</blockquote>
</li>
</ol>
<h2>mixin(混入)</h2>
<p><img src="typora-user-images.assets/image-20230412144141862.png" alt="image-20230412144141862"></p>
<p><img src="typora-user-images.assets/image-20230412144223136.png" alt="image-20230412144223136"></p>
<p><img src="typora-user-images.assets/image-20230412144249903.png" alt="image-20230412144249903"></p>
<ol>
<li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p>
</li>
<li><p>使用方式：</p>
<p> 第一步定义混合：</p>
<pre><code>{
    data(){....},
    methods:{....}
    ....
}
</code></pre>
<p> 第二步使用混入：</p>
<p>  全局混入：<code>Vue.mixin(xxx)</code>
  局部混入：<code>mixins:[&#39;xxx&#39;]  </code></p>
</li>
</ol>
<h2>插件</h2>
<ol>
<li><p>功能：用于增强Vue</p>
</li>
<li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li><p>定义插件：</p>
<pre><code class="language-js">对象.install = function (Vue, options) {
    // 1. 添加全局过滤器
    Vue.filter(....)

    // 2. 添加全局指令
    Vue.directive(....)

    // 3. 配置全局混入(合)
    Vue.mixin(....)

    // 4. 添加实例方法
    Vue.prototype.$myMethod = function () {...}
    Vue.prototype.$myProperty = xxxx
}
</code></pre>
<pre><code class="language-js">export default {
    install(Vue,x,y,z){
        console.log(x,y,z)
        //全局过滤器
        Vue.filter(&#39;mySlice&#39;,function(value){
            return value.slice(0,4)
        })

        //定义全局指令
        Vue.directive(&#39;fbind&#39;,{
            //指令与元素成功绑定时（一上来）
            bind(element,binding){
                element.value = binding.value
            },
            //指令所在元素被插入页面时
            inserted(element,binding){
                element.focus()
            },
            //指令所在的模板被重新解析时
            update(element,binding){
                element.value = binding.value
            }
        })

        //定义混入
        Vue.mixin({
            data() {
                return {
                    x:100,
                    y:200
                }
            },
        })

        //给Vue原型上添加一个方法（vm和vc就都能用了）
        Vue.prototype.hello = ()=&gt;{alert(&#39;你好啊&#39;)}
    }
}
</code></pre>
</li>
<li><p>使用插件：<code>Vue.use()</code></p>
</li>
</ol>
<h2>scoped样式</h2>
<ol>
<li><p>作用：让样式在局部生效，防止冲突。</p>
</li>
<li><p>写法：<code>&lt;style scoped&gt;</code></p>
<p><img src="typora-user-images.assets/image-20230412145349641.png" alt="image-20230412145349641"></p>
</li>
</ol>
<h2>总结TodoList案例</h2>
<h3>自己的总结</h3>
<p>v-model的一些技巧</p>
<pre><code>&lt;!-- &lt;input type=&quot;checkbox&quot; :checked=&quot;isAll&quot; @change=&quot;checkAll&quot;/&gt; --&gt;
可以直接写成：
&lt;input type=&quot;checkbox&quot; v-model=&quot;isAll&quot;/&gt;
</code></pre>
<pre><code>nanoid
nanoid()
</code></pre>
<p><img src="typora-user-images.assets/image-20230412152353480.png" alt="image-20230412152353480"></p>
<pre><code>receive 会出现在 MyHeader 的组件实例对象身上
</code></pre>
<p><img src="typora-user-images.assets/image-20230412153632670.png" alt="image-20230412153632670"></p>
<p><strong>如果v-model绑定的是一个布尔值，那么v-model就可以决定checkbox勾还是不勾</strong></p>
<p><strong>reduce</strong>条件统计</p>
<p><img src="typora-user-images.assets/image-20230412155744002.png" alt="image-20230412155744002"></p>
<p><img src="typora-user-images.assets/image-20230412155846393.png" alt="image-20230412155846393"></p>
<h3>组件化编码流程：</h3>
<p>(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p>
<p>(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p>
<p>​      1).一个组件在用：放在组件自身即可。</p>
<p>​      2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p>
<p>(3).实现交互：从绑定事件开始。</p>
<ol>
<li><p><strong>props适用于：</strong></p>
<p>  <strong>(1).父组件 ==&gt; 子组件 通信</strong></p>
<p>  <strong>(2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）</strong></p>
</li>
<li><p><strong>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</strong></p>
</li>
<li><p><strong>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</strong></p>
</li>
</ol>
<h2>webStorage</h2>
<h4>JSON.stringify()</h4>
<h4>JSON.parse()</h4>
<pre><code class="language-js">    &lt;body&gt;
        &lt;h2&gt;localStorage&lt;/h2&gt;
        &lt;button onclick=&quot;saveData()&quot;&gt;点我保存一个数据&lt;/button&gt;
        &lt;button onclick=&quot;readData()&quot;&gt;点我读取一个数据&lt;/button&gt;
        &lt;button onclick=&quot;deleteData()&quot;&gt;点我删除一个数据&lt;/button&gt;
        &lt;button onclick=&quot;deleteAllData()&quot;&gt;点我清空一个数据&lt;/button&gt;

        &lt;script type=&quot;text/javascript&quot; &gt;
            let p = {name:&#39;张三&#39;,age:18}

            function saveData(){
                localStorage.setItem(&#39;msg&#39;,&#39;hello!!!&#39;)
                localStorage.setItem(&#39;msg2&#39;,666)
                localStorage.setItem(&#39;person&#39;,JSON.stringify(p))
            }
            function readData(){
                console.log(localStorage.getItem(&#39;msg&#39;))
                console.log(localStorage.getItem(&#39;msg2&#39;))

                const result = localStorage.getItem(&#39;person&#39;)
                console.log(JSON.parse(result))

                // console.log(localStorage.getItem(&#39;msg3&#39;))
            }
            function deleteData(){
                localStorage.removeItem(&#39;msg2&#39;)
            }
            function deleteAllData(){
                localStorage.clear()
            }
        &lt;/script&gt;
</code></pre>
<ol>
<li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p>
</li>
<li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>
</li>
<li><p>相关API：</p>
<ol>
<li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code>
   该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。
   <strong>记得一定要传一个字符串</strong></p>
</li>
<li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p>
<p>   ​    该方法接受一个键名作为参数，返回键名对应的值。</p>
</li>
<li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p>
<p>   ​    该方法接受一个键名作为参数，并把该键名从存储中删除。</p>
</li>
<li><p><code> xxxxxStorage.clear()</code></p>
<p>   ​    该方法会清空存储中的所有数据。</p>
</li>
</ol>
</li>
<li><p>备注：</p>
<ol>
<li><p>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</p>
</li>
<li><p>LocalStorage存储的内容，需要手动清除才会消失。</p>
</li>
<li><p><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</p>
</li>
<li><p><code>JSON.parse(null)</code>的结果依然是null。</p>
<p><strong>如果第一次使用localstorage,里面没有数据，即为null，则会报错，</strong></p>
<p><img src="typora-user-images.assets/image-20230412163748801.png" alt="image-20230412163748801"></p>
<p>监测不到done的变化，需要开启深度监视</p>
<p><img src="typora-user-images.assets/image-20230412164005045.png" alt="image-20230412164005045"></p>
</li>
</ol>
</li>
</ol>
<h2>组件的自定义事件</h2>
<p><strong>给Student组件的实例对象vc身上绑定一个atguigu事件，只要atguigu被触发，demo函数立刻被调用</strong>(监听)</p>
<p><img src="typora-user-images.assets/image-20230412183712331.png" alt="image-20230412183712331"></p>
<ol>
<li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></p>
</li>
<li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p>
</li>
<li><p>绑定自定义事件：</p>
<ol>
<li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p>
</li>
<li><p>第二种方式，在父组件中：</p>
<pre><code class="language-js">&lt;Demo ref=&quot;demo&quot;/&gt;
......
mounted(){
   this.$refs.xxx.$on(&#39;atguigu&#39;,this.test)
    //this.$refs.xxx组件实例对象   .$on 当....时候，既当atguigu被触发时，this.text被调用
    //更加灵活，可以加定时器之类的
}
</code></pre>
</li>
<li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>
</li>
</ol>
</li>
<li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code>    </p>
</li>
<li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p>
</li>
<li><p><strong>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</strong></p>
</li>
<li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！（谁触发的atguigu事件，this就指向谁，也就是this指向student，使用箭头函数，其没有自己的this,向外寻找到this指向school）</p>
<p> <img src="typora-user-images.assets/image-20230412204155274.png" alt="image-20230412204155274"></p>
<p> <img src="typora-user-images.assets/image-20230412204228782.png" alt="image-20230412204228782"></p>
</li>
</ol>
<h2>全局事件总线（GlobalEventBus）</h2>
<p><img src="typora-user-images.assets/image-20230412221009834.png" alt="image-20230412221009834"></p>
<ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>安装全局事件总线：</p>
<p><strong>理解</strong></p>
<pre><code class="language-js">new Vue({
   ......
   beforeCreate() {
      Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm，this指向当前VC实例对象
   },
    ......
}) 
</code></pre>
</li>
<li><p>使用事件总线：</p>
<ol>
<li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<pre><code class="language-js">methods(){
  demo(data){......}
}
......
mounted() {
  this.$bus.$on(&#39;xxxx&#39;,this.demo)
}
</code></pre>
</li>
<li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p>
</li>
</ol>
</li>
<li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
<p><img src="typora-user-images.assets/image-20230412215805985.png" alt="image-20230412215805985"></p>
</li>
</ol>
<h2>消息订阅与发布（pubsub）</h2>
<ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>使用步骤：</p>
<ol>
<li><p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p>
</li>
<li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p>
<pre><code class="language-js">methods(){
  demo(data){......}
}
......
mounted() {
  this.pid = pubsub.subscribe(&#39;xxx&#39;,this.demo) //订阅消息
}
</code></pre>
</li>
<li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p>
</li>
<li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
<p><strong>调用第三方的库时，里面的this指向不一定是VC</strong></p>
<p><img src="typora-user-images.assets/image-20230412220823225.png" alt="image-20230412220823225"></p>
<p>占位，第一个参数不用</p>
<p><img src="typora-user-images.assets/image-20230412221207172.png" alt="image-20230412221207172"></p>
</li>
</ol>
</li>
</ol>
<h2>nextTick</h2>
<p><img src="typora-user-images.assets/image-20230415114553769.png" alt="image-20230415114553769"></p>
<ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li>
</ol>
<h2>Vue封装的过度与动画</h2>
<ol>
<li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li><p>图示：</p>
<p><img src="typora-user-images.assets/image-20230414203626501.png" alt="image-20230414203626501"></p>
<p><img src="typora-user-images.assets/image-20230414203653437.png" alt="image-20230414203653437"></p>
</li>
<li><p>写法：</p>
<ol>
<li><p>准备好样式：</p>
<ul>
<li>元素进入的样式：<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p>
<pre><code class="language-vue">&lt;transition name=&quot;hello&quot;&gt;
   &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;
&lt;/transition&gt;
</code></pre>
</li>
<li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
<p>appear</p>
</li>
</ol>
</li>
</ol>
<h2>vue脚手架配置代理</h2>
<h3>方法一</h3>
<p>  在vue.config.js中添加如下配置：</p>
<pre><code class="language-js">devServer:{
  proxy:&quot;http://localhost:5000&quot;
}
</code></pre>
<p>说明：</p>
<ol>
<li><p>优点：配置简单，请求资源时直接发给前端（8080）即可。</p>
</li>
<li><p>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</p>
</li>
<li><p>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</p>
<p><img src="typora-user-images.assets/image-20230413192507018.png" alt="image-20230413192507018"></p>
</li>
</ol>
<h3>方法二</h3>
<p>  编写vue.config.js配置具体代理规则：</p>
<pre><code class="language-js">module.exports = {
   devServer: {
      proxy: {
      &#39;/api1&#39;: {// 匹配所有以 &#39;/api1&#39;开头的请求路径
        target: &#39;http://localhost:5000&#39;,// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: {&#39;^/api1&#39;: &#39;&#39;}
      },
      &#39;/api2&#39;: {// 匹配所有以 &#39;/api2&#39;开头的请求路径
        target: &#39;http://localhost:5001&#39;,// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: {&#39;^/api2&#39;: &#39;&#39;}
      }
    }
  }
}
/*
   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080
   changeOrigin默认值为true
*/
</code></pre>
<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2>github案例</h2>
<p>检查较为严格</p>
<p><img src="typora-user-images.assets/image-20230413194413377.png" alt="image-20230413194413377"></p>
<p>建议方式</p>
<p><img src="typora-user-images.assets/image-20230413194512779.png" alt="image-20230413194512779"></p>
<p>以后边的为主</p>
<p><img src="typora-user-images.assets/image-20230413200335886.png" alt="image-20230413200335886"></p>
<h2>插槽</h2>
<ol>
<li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。</p>
</li>
<li><p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li><p>使用方式：</p>
<ol>
<li><p>默认插槽：</p>
<pre><code class="language-vue">父组件中：
        &lt;Category&gt;
           &lt;div&gt;html结构1&lt;/div&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
               &lt;!-- 定义插槽 --&gt;
               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
</code></pre>
</li>
<li><p>具名插槽：</p>
<pre><code class="language-vue">父组件中：
        &lt;Category&gt;
            &lt;template slot=&quot;center&quot;&gt;
              &lt;div&gt;html结构1&lt;/div&gt;
            &lt;/template&gt;

            &lt;template v-slot:footer&gt;
               &lt;div&gt;html结构2&lt;/div&gt;
            &lt;/template&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
               &lt;!-- 定义插槽 --&gt;
               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;
               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
</code></pre>
</li>
<li><p>作用域插槽：</p>
<ol>
<li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p>
</li>
<li><p>具体编码：</p>
<pre><code class="language-vue">父组件中：
      &lt;Category&gt;
         &lt;template scope=&quot;scopeData&quot;&gt;
            &lt;!-- 生成的是ul列表 --&gt;
            &lt;ul&gt;
               &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;{{g}}&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/template&gt;
      &lt;/Category&gt;

      &lt;Category&gt;
         &lt;template slot-scope=&quot;scopeData&quot;&gt;
            &lt;!-- 生成的是h4标题 --&gt;
            &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;{{g}}&lt;/h4&gt;
         &lt;/template&gt;
      &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
      
        &lt;script&gt;
            export default {
                name:&#39;Category&#39;,
                props:[&#39;title&#39;],
                //数据在子组件自身
                data() {
                    return {
                        games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;劲舞团&#39;,&#39;超级玛丽&#39;]
                    }
                },
            }
        &lt;/script&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<pre><code>
</code></pre>
</li>
</ol>
<h2>Vuex</h2>
<p><img src="F:%5C%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%5C%E5%B0%9A%E7%A1%85%E8%B0%B7%5Cvue%5C%E8%B5%84%E6%96%99%EF%BC%88%E5%90%AB%E8%AF%BE%E4%BB%B6%EF%BC%89%5C02_%E5%8E%9F%E7%90%86%E5%9B%BE%5Cvuex.png" alt="vuex"></p>
<h3>1.概念</h3>
<p>​     在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3>2.何时使用？</h3>
<p>​     多个组件需要共享数据时</p>
<h3>3.搭建vuex环境</h3>
<ol>
<li><p>创建文件：<code>src/store/index.js</code></p>
<pre><code class="language-js">//引入Vue核心库
import Vue from &#39;vue&#39;
//引入Vuex
import Vuex from &#39;vuex&#39;
//应用Vuex插件
Vue.use(Vuex)

不引入和不use，则在new VUe时，即使传入store配置项，Vue也不认，同时所有的VC身上也没有store配置项。
引入和use Vuex，则在new VUe时，传入store配置项，同时所有的VC身上也有store配置项。

//准备actions对象——响应组件中用户的动作
const actions = {}
//准备mutations对象——修改state中的数据
const mutations = {}
//准备state对象——保存具体的数据
const state = {}

//创建并暴露store
export default new Vuex.Store({
   actions,
   mutations,
   state
})
</code></pre>
</li>
<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<pre><code class="language-js">......
//引入store
import store from &#39;./store&#39;
......

//创建vm
new Vue({
   el:&#39;#app&#39;,
   render: h =&gt; h(App),
   store
})
</code></pre>
</li>
</ol>
<h3>4.基本使用</h3>
<ol>
<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<pre><code class="language-js">//引入Vue核心库
import Vue from &#39;vue&#39;
//引入Vuex
import Vuex from &#39;vuex&#39;
//引用Vuex
Vue.use(Vuex)

const actions = {
    //响应组件中加的动作
   jia(context,value){
      // console.log(&#39;actions中的jia被调用了&#39;,miniStore,value)
      context.commit(&#39;JIA&#39;,value)
   },
}

const mutations = {
    //执行加
   JIA(state,value){
      // console.log(&#39;mutations中的JIA被调用了&#39;,state,value)
      state.sum += value
   }
}

//初始化数据
const state = {
   sum:0
}

//创建并暴露store
export default new Vuex.Store({
   actions,
   mutations,
   state,
})
</code></pre>
</li>
<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>
<blockquote>
<p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3>5.getters的使用</h3>
<ol>
<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>
</li>
<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<pre><code class="language-js">......

const getters = {
   bigSum(state){
      return state.sum * 10
   }
}

//创建并暴露store
export default new Vuex.Store({
   ......
   getters
})
</code></pre>
</li>
<li><p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3>6.四个map方法的使用</h3>
<p><strong>createNamespacedHelpers</strong></p>
<p><strong>创建基于命名空间的组件绑定辅助函数。其返回一个包含 mapState、mapGetters、mapActions 和 mapMutations 的对象。它们都已经绑定在了给定的命名空间上。</strong></p>
<pre><code>const {mapMutations: mapLayoutMutations,mapGetters:mapLayoutGetters} = createNamespacedHelpers(&#39;layout&#39;)
</code></pre>
<ol>
<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<pre><code class="language-js">computed: {
    //借助mapState生成计算属性：sum、school、subject（对象写法）
     ...mapState({sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;}),
         
    //借助mapState生成计算属性：sum、school、subject（数组写法）
    ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),
},
</code></pre>
</li>
<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<pre><code class="language-js">computed: {
    //借助mapGetters生成计算属性：bigSum（对象写法）
    ...mapGetters({bigSum:&#39;bigSum&#39;}),

    //借助mapGetters生成计算属性：bigSum（数组写法）
    ...mapGetters([&#39;bigSum&#39;])
},
</code></pre>
</li>
<li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<pre><code class="language-js">methods:{
    //靠mapActions生成：incrementOdd、incrementWait（对象形式）
    ...mapActions({incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;})

    //靠mapActions生成：incrementOdd、incrementWait（数组形式）
    ...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])
}
</code></pre>
</li>
<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<pre><code class="language-js">methods:{
    //靠mapActions生成：increment、decrement（对象形式）
    ...mapMutations({increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;}),
    
    //靠mapMutations生成：JIA、JIAN（对象形式）
    ...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;]),
}
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3>7.模块化+命名空间</h3>
<ol>
<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>
<p>**<strong><strong><strong>namespaced:true,//开启命名空间</strong></strong></strong></p>
</li>
<li><p>修改<code>store.js</code></p>
<pre><code class="language-javascript">const countAbout = {
  namespaced:true,//开启命名空间
  state:{x:1},
  mutations: { ... },
  actions: { ... },
  getters: {
    bigSum(state){
       return state.sum * 10
    }
  }
}

const personAbout = {
  namespaced:true,//开启命名空间
  state:{ ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    countAbout,
    personAbout
  }
})
</code></pre>
</li>
<li><p>开启命名空间后，组件中读取state数据：</p>
<pre><code class="language-js">//方式一：自己直接读取
this.$store.state.personAbout.list
//方式二：借助mapState读取：
...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),
</code></pre>
</li>
<li><p>开启命名空间后，组件中读取getters数据：</p>
<pre><code class="language-js">//方式一：自己直接读取
this.$store.getters[&#39;personAbout/firstPersonName&#39;]
//方式二：借助mapGetters读取：
...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])
</code></pre>
</li>
<li><p>开启命名空间后，组件中调用dispatch</p>
<pre><code class="language-js">//方式一：自己直接dispatch
this.$store.dispatch(&#39;personAbout/addPersonWang&#39;,personObj)
//方式二：借助mapActions：
...mapActions(&#39;countAbout&#39;,{incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;})
</code></pre>
</li>
<li><p>开启命名空间后，组件中调用commit</p>
<pre><code class="language-js">//方式一：自己直接commit
this.$store.commit(&#39;personAbout/ADD_PERSON&#39;,personObj)
//方式二：借助mapMutations：
...mapMutations(&#39;countAbout&#39;,{increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;}),
</code></pre>
</li>
</ol>
<pre><code>//该文件用于创建Vuex中最为核心的store
import Vue from &#39;vue&#39;
//引入Vuex
import Vuex from &#39;vuex&#39;
import countOptions from &#39;./count&#39;
import personOptions from &#39;./person&#39;
//应用Vuex插件
Vue.use(Vuex)

//创建并暴露store
export default new Vuex.Store({
    modules:{
        countAbout:countOptions,
        personAbout:personOptions
    }
})
</code></pre>
<pre><code class="language-js">//人员管理相关的配置
import axios from &#39;axios&#39;
import { nanoid } from &#39;nanoid&#39;
export default {
    namespaced:true,
    actions:{
        addPersonWang(context,value){
            if(value.name.indexOf(&#39;王&#39;) === 0){
                context.commit(&#39;ADD_PERSON&#39;,value)
            }else{
                alert(&#39;添加的人必须姓王！&#39;)
            }
        },
        addPersonServer(context){
            axios.get(&#39;https://api.uixsj.cn/hitokoto/get?type=social&#39;).then(
                response =&gt; {
                    context.commit(&#39;ADD_PERSON&#39;,{id:nanoid(),name:response.data})
                },
                error =&gt; {
                    alert(error.message)
                }
            )
        }
    },
    mutations:{
        ADD_PERSON(state,value){
            console.log(&#39;mutations中的ADD_PERSON被调用了&#39;)
            state.personList.unshift(value)
        }
    },
    state:{
        personList:[
            {id:&#39;001&#39;,name:&#39;张三&#39;}
        ]
    },
    getters:{
        firstPersonName(state){
            return state.personList[0].name
        }
    },
}
</code></pre>
<h2>路由</h2>
<ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<h3>1.基本使用</h3>
<ol>
<li><p>安装vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li><p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li><p>编写router配置项:</p>
<pre><code class="language-js">//引入VueRouter
import VueRouter from &#39;vue-router&#39;
//引入Luyou 组件
import About from &#39;../components/About&#39;
import Home from &#39;../components/Home&#39;

//创建router实例对象，去管理一组一组的路由规则
const router = new VueRouter({
   routes:[
      {
         path:&#39;/about&#39;,
         component:About
      },
      {
         path:&#39;/home&#39;,
         component:Home
      }
   ]
})

//暴露router
export default router
</code></pre>
</li>
<li><p>实现切换（active-class可配置高亮样式）</p>
<pre><code class="language-vue">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
</code></pre>
</li>
<li><p>指定展示位置</p>
<pre><code class="language-vue">&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
</li>
</ol>
<h3>2.几个注意点</h3>
<ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3>3.多级路由（多级路由）</h3>
<ol>
<li><p>配置路由规则，使用children配置项：</p>
<pre><code class="language-js">routes:[
   {
      path:&#39;/about&#39;,
      component:About,
   },
   {
      path:&#39;/home&#39;,
      component:Home,
      children:[ //通过children配置子级路由
         {
            path:&#39;news&#39;, //此处一定不要写：/news
            component:News
         },
         {
            path:&#39;message&#39;,//此处一定不要写：/message
            component:Message
         }
      ]
   }
]
</code></pre>
</li>
<li><p><strong>跳转（要写完整路径）：</strong></p>
<pre><code class="language-vue">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
</code></pre>
</li>
</ol>
<h3>4.路由的query参数</h3>
<ol>
<li><p>传递参数</p>
<pre><code class="language-vue">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;
            
&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;
&lt;router-link 
   :to=&quot;{
      path:&#39;/home/message/detail&#39;,
      query:{
         id:666,
         title:&#39;你好&#39;
      }
   }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
<li><p>接收参数：</p>
<pre><code class="language-js">$route.query.id
$route.query.title
</code></pre>
</li>
</ol>
<h3>5.命名路由</h3>
<ol>
<li><p>作用：可以简化路由的跳转。</p>
</li>
<li><p>如何使用</p>
<ol>
<li><p>给路由命名：<strong>name:&#39;hello&#39;</strong></p>
<pre><code class="language-js">{
   path:&#39;/demo&#39;,
   component:Demo,
   children:[
      {
         path:&#39;test&#39;,
         component:Test,
         children:[
            {
               name:&#39;hello&#39; //给路由命名
               path:&#39;welcome&#39;,
               component:Hello,
            }
         ]
      }
   ]
}
</code></pre>
</li>
<li><p>简化跳转：<strong>:to=&quot;{name:&#39;hello&#39;}&quot;</strong>  <strong>注意写成对象形式</strong></p>
<pre><code class="language-vue">&lt;!--简化前，需要写完整的路径 --&gt;
&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化后，直接通过名字跳转 --&gt;
&lt;router-link :to=&quot;{name:&#39;hello&#39;}&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化写法配合传递参数 --&gt;
&lt;router-link 
   :to=&quot;{
      name:&#39;hello&#39;,
      query:{
         id:666,
         title:&#39;你好&#39;
      }
   }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h3>6.路由的params参数</h3>
<ol>
<li><p>配置路由，声明接收params参数    <strong>path:&#39;detail/:id/:title&#39;</strong></p>
<pre><code class="language-js">{
   path:&#39;/home&#39;,
   component:Home,
   children:[
      {
         path:&#39;news&#39;,
         component:News
      },
      {
         component:Message,
         children:[
            {
               name:&#39;xiangqing&#39;,
               path:&#39;detail/:id/:title&#39;, //使用占位符声明接收params参数
               component:Detail
            }
         ]
      }
   ]
}
</code></pre>
</li>
<li><p>传递参数</p>
<pre><code class="language-vue">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;
            
&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;
&lt;router-link 
   :to=&quot;{
      name:&#39;xiangqing&#39;,
      params:{
         id:666,
            title:&#39;你好&#39;
      }
   }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
<blockquote>
<p><strong>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</strong></p>
</blockquote>
</li>
<li><p>接收参数：</p>
<pre><code class="language-js">$route.params.id
$route.params.title
</code></pre>
</li>
</ol>
<h3>7.路由的props配置</h3>
<p>  作用：让路由组件更方便的收到参数</p>
<pre><code class="language-js">{
   name:&#39;xiangqing&#39;,
   path:&#39;detail/:id&#39;,
   component:Detail,

   //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件
   // props:{a:900}

   //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件
   // props:true
   
   //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件
   props(route){
      return {
         id:route.query.id,
         title:route.query.title
      }
   }
}
</code></pre>
<h3>8.<code>&lt;router-link&gt;</code>的replace属性</h3>
<ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3>9.编程式路由导航</h3>
<ol>
<li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li><p>具体编码：     <strong>this.$router.push</strong></p>
<pre><code class="language-js">//$router的两个API
this.$router.push({
   name:&#39;xiangqing&#39;,
      params:{
         id:xxx,
         title:xxx
      }
})

this.$router.replace({
   name:&#39;xiangqing&#39;,
      params:{
         id:xxx,
         title:xxx
      }
})
this.$router.forward() //前进
this.$router.back() //后退
this.$router.go() //可前进也可后退
</code></pre>
</li>
</ol>
<h3>10.缓存路由组件</h3>
<ol>
<li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li><p>具体编码：</p>
<pre><code class="language-vue">&lt;keep-alive include=&quot;News&quot;&gt; 
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;

&lt;keep-alive :include=[&quot;News&quot;,&quot;Search&quot;]&gt; 
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
</code></pre>
</li>
</ol>
<h3>11.两个新的生命周期钩子</h3>
<ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3>12.路由守卫</h3>
<ol>
<li><p>作用：对路由进行权限控制</p>
</li>
<li><p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li><p>全局守卫:</p>
<pre><code>meta:{isAuth:true} :路由元信息
</code></pre>
<pre><code class="language-js">//全局前置守卫：初始化时执行、每次路由切换前执行
router.beforeEach((to,from,next)=&gt;{
   console.log(&#39;beforeEach&#39;,to,from)
   if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
      if(localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;){ //权限控制的具体规则
         next() //放行
      }else{
         alert(&#39;暂无权限查看&#39;)
         // next({name:&#39;guanyu&#39;})
      }
   }else{
      next() //放行
   }
})

//全局后置守卫：初始化时执行、每次路由切换后执行
router.afterEach((to,from)=&gt;{
   console.log(&#39;afterEach&#39;,to,from)
   if(to.meta.title){ 
      document.title = to.meta.title //修改网页的title
   }else{
      document.title = &#39;vue_test&#39;
   }
})
</code></pre>
</li>
<li><p>独享守卫:（只有前置，没有后置，可以和全局后置路由守卫配合使用）</p>
<pre><code class="language-js">beforeEnter(to,from,next){
   console.log(&#39;beforeEnter&#39;,to,from)
   if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
      if(localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;){
         next()
      }else{
         alert(&#39;暂无权限查看&#39;)
         // next({name:&#39;guanyu&#39;})
      }
   }else{
      next()
   }
}
</code></pre>
</li>
<li><p>组件内守卫：</p>
<pre><code class="language-js">//进入守卫：通过路由规则，进入该组件时被调用
beforeRouteEnter (to, from, next) {
},
//离开守卫：通过路由规则，离开该组件时被调用
beforeRouteLeave (to, from, next) {
}
</code></pre>
</li>
</ol>
<h3>13.路由器的两种工作模式</h3>
<p><img src="typora-user-images.assets/image-20230414194944452.png" alt="image-20230414194944452"></p>
<p>解决history不兼容的问题</p>
<p><img src="typora-user-images.assets/image-20230414195828503.png" alt="image-20230414195828503"></p>
<p><img src="typora-user-images.assets/image-20230414195936638.png" alt="image-20230414195936638"></p>
<ol>
<li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li>
<li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li>
<li>hash模式：<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>history模式：<ol>
<li>地址干净，美观 。</li>
<li>兼容性和hash模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>
</ol>
</li>
</ol>
<h2>elm按需引入</h2>
<pre><code>//引入Vue
import Vue from &#39;vue&#39;
//引入App
import App from &#39;./App.vue&#39;

//完整引入
//引入ElementUI组件库
// import ElementUI from &#39;element-ui&#39;;
//引入ElementUI全部样式
// import &#39;element-ui/lib/theme-chalk/index.css&#39;;

//按需引入
import { Button,Row,DatePicker } from &#39;element-ui&#39;;

//关闭Vue的生产提示
Vue.config.productionTip = false

//应用ElementUI
// Vue.use(ElementUI);
Vue.component(&#39;atguigu-button&#39;, Button);
Vue.component(&#39;atguigu-row&#39;, Row);
Vue.component(&#39;atguigu-date-picker&#39;, DatePicker);
</code></pre>
<p><img src="typora-user-images.assets/image-20230414201847577.png" alt="image-20230414201847577"></p>
<p><img src="typora-user-images.assets/image-20230414201546525.png" alt="image-20230414201546525"></p>
<h1>Vue3</h1>
<p><code>export default (await import(&#39;vue&#39;)).definecomponent</code> 是 vue 3 中创建组件的一种方式，它使用了 <code>definecomponent</code> 方法来定义一个组件，该方法通过传递一个包含组件选项的对象来创建组件。</p>
<p>在这种情况下，我们使用了动态导入 (<code>import()</code>) 来异步加载 vue 模块并获取 <code>vue</code> 对象。然后，我们调用其 <code>definecomponent</code> 方法，并将返回值设置为默认导出。</p>
<p>这种方式通常用于减小 javascript 包的大小。因为只有当组件被渲染或需要时才会加载 vue 模块，否则 vue 可能会通过 <code>import vue from &#39;vue&#39;</code> 初始加载 vue 模块，这可能会增加初始加载时间和总体 javascript 文件的大小。</p>
<p>可以取消这种方式。如果你想声明 Vue 组件而不使用 <code>export default (await import(&#39;vue&#39;)).defineComponent</code> 的语法，你可以导入 <code>Vue</code> 对象，然后在组件选项上调用 <code>Vue.extend()</code> 方法来创建一个基于 Vue 的构造函数。</p>
<p>示例代码如下：</p>
<pre><code>import Vue from &#39;vue&#39;;

const MyComponent = Vue.extend({
  // 组件选项
});

export default MyComponent;
</code></pre>
<p>这样做将以常规方式定义 Vue 组件，并且与使用 <code>export default (await import(&#39;vue&#39;)).defineComponent</code> 的方式相比，不会有任何额外的异步加载和动态模块导入的开销。</p>
<h2>props</h2>
<p>所有的 props 都遵循着<strong>单向绑定</strong>原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。</p>
<p>另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你<strong>不应该</strong>在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告</p>
<pre><code class="language-vue">const props = defineProps([&#39;foo&#39;])

// 使用 &lt;script setup&gt;
defineProps({
  title: String,
  likes: Number
})

&lt;script setup lang=&quot;ts&quot;&gt;
defineProps&lt;{
  title?: string
  likes?: number
}&gt;()
&lt;/script&gt;

&lt;!-- 根据一个变量的值动态传入 --&gt;
&lt;BlogPost :title=&quot;post.title&quot; /&gt;

&lt;!-- 根据一个更复杂表达式的值动态传入 --&gt;
&lt;BlogPost :title=&quot;post.title + &#39; by &#39; + post.author.name&quot; /&gt;
</code></pre>
<h2>Prop 校验</h2>
<pre><code class="language-js">defineProps({
  // 基础类型检查
  // （给出 `null` 和 `undefined` 值则会跳过任何类型检查）
  propA: Number,
  // 多种可能的类型
  propB: [String, Number],
  // 必传，且为 String 类型
  propC: {
    type: String,
    required: true
  },
  // Number 类型的默认值
  propD: {
    type: Number,
    default: 100
  },
  // 对象类型的默认值
  propE: {
    type: Object,
    // 对象或数组的默认值
    // 必须从一个工厂函数返回。
    // 该函数接收组件所接收到的原始 prop 作为参数。
    default(rawProps) {
      return { message: &#39;hello&#39; }
    }
  },
  // 自定义类型校验函数
  propF: {
    validator(value) {
      // The value must match one of these strings
      return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].includes(value)
    }
  },
  // 函数类型的默认值
  propG: {
    type: Function,
    // 不像对象或数组的默认，这不是一个
    // 工厂函数。这会是一个用来作为默认值的函数
    default() {
      return &#39;Default function&#39;
    }
  }
})
</code></pre>
<h2>组件事件</h2>
<pre><code class="language-vue">&lt;!-- MyComponent --&gt;
&lt;button @click=&quot;$emit(&#39;someEvent&#39;)&quot;&gt;click me&lt;/button&gt;

&lt;MyComponent @some-event=&quot;callback&quot; /&gt;

&lt;MyComponent @some-event.once=&quot;callback&quot; /&gt;
</code></pre>
<p>像组件与 prop 一样，事件的名字也提供了自动的格式转换。注意这里我们触发了一个以 camelCase 形式命名的事件，但在父组件中可以使用 kebab-case 形式来监听。与 <a href="https://cn.vuejs.org/guide/components/props.html#prop-name-casing">prop 大小写格式</a>一样，在模板中我们也推荐使用 kebab-case 形式来编写监听器。</p>
<p>声明触发的事件: <a href="https://cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits"><code>defineEmits()</code></a>  <code>参考文档</code></p>
<h2>v-model</h2>
<p><code>v-model</code> 可以在组件上使用以实现双向绑定。</p>
<p><code>方案一</code> :</p>
<pre><code class="language-vue">&lt;CustomInput
  :model-value=&quot;searchText&quot;
  @update:model-value=&quot;newValue =&gt; searchText = newValue&quot;
/&gt;

&lt;!-- CustomInput.vue --&gt;
&lt;script setup&gt;
defineProps([&#39;modelValue&#39;])
defineEmits([&#39;update:modelValue&#39;])
&lt;/script&gt;

&lt;template&gt;
  &lt;input
    :value=&quot;modelValue&quot;
    @input=&quot;$emit(&#39;update:modelValue&#39;, $event.target.value)&quot;
  /&gt;
&lt;/template&gt;
</code></pre>
<p><code>方案二</code> :使用一个可写的，同时具有 getter 和 setter 的 <code>computed</code> 属性。<code>get</code> 方法需返回 <code>modelValue</code> prop，而 <code>set</code> 方法需触发相应的事件：</p>
<pre><code class="language-vue">&lt;!-- CustomInput.vue --&gt;
&lt;script setup&gt;
import { computed } from &#39;vue&#39;

const props = defineProps([&#39;modelValue&#39;])
const emit = defineEmits([&#39;update:modelValue&#39;])

const value = computed({
  get() {
    return props.modelValue
  },
  set(value) {
    emit(&#39;update:modelValue&#39;, value)
  }
})
&lt;/script&gt;

&lt;template&gt;
  &lt;input v-model=&quot;value&quot; /&gt;
&lt;/template&gt;
</code></pre>
<h2>多个 <code>v-model</code> 绑定</h2>
<pre><code class="language-vue">&lt;UserName
  v-model:first-name=&quot;first&quot;
  v-model:last-name=&quot;last&quot;
/&gt;

defineProps({
  firstName: String,
  lastName: String
})
</code></pre>
<h2>Attributes 继承</h2>
<h3>深层组件继承</h3>
<p>有些情况下一个组件会在根节点上渲染另一个组件。例如，我们重构一下 <code>&lt;MyButton&gt;</code>，让它在根节点上渲染 <code>&lt;BaseButton&gt;</code>：</p>
<pre><code class="language-vue">&lt;!-- &lt;MyButton/&gt; 的模板，只是渲染另一个组件 --&gt;
&lt;BaseButton /&gt;
</code></pre>
<p>请注意：</p>
<ol>
<li>透传的 attribute 不会包含 <code>&lt;MyButton&gt;</code> 上声明过的 props 或是针对 <code>emits</code> 声明事件的 <code>v-on</code> 侦听函数，换句话说，声明过的 props 和侦听函数被 <code>&lt;MyButton&gt;</code>“消费”了。</li>
<li>透传的 attribute 若符合声明，也可以作为 props 传入 <code>&lt;BaseButton&gt;</code>。</li>
</ol>
<p><code>禁用 Attributes 继承</code></p>
<p>如果你<strong>不想要</strong>一个组件自动地继承 attribute，你可以在组件选项中设置 <code>inheritAttrs: false</code>。</p>
<p>从 3.3 开始你也可以直接在 <code>&lt;script setup&gt;</code> 中使用 <a href="https://cn.vuejs.org/api/sfc-script-setup.html#defineoptions"><code>defineOptions</code></a>：</p>
<p>vue</p>
<pre><code class="language-vue">&lt;script setup&gt;
defineOptions({
  inheritAttrs: false
})
// ...setup 逻辑
&lt;/script&gt;
</code></pre>
<p>最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上。通过设置 <code>inheritAttrs</code> 选项为 <code>false</code>，你可以完全控制透传进来的 attribute 被如何使用。</p>
<p>这些透传进来的 attribute 可以在模板的表达式中直接用 <code>$attrs</code> 访问到。</p>
<p><strong>在 JavaScript 中访问透传 Attributes</strong></p>
<h2>v-slot</h2>
<p><strong>具名插槽</strong></p>
<pre><code class="language-vue">&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;


&lt;BaseLayout&gt;
  &lt;template v-slot:header&gt;
    &lt;!-- header 插槽的内容放这里 --&gt;
  &lt;/template&gt;
&lt;/BaseLayout&gt;
</code></pre>
<p><code>v-slot</code> 有对应的简写 <code>#</code>，因此 <code>&lt;template v-slot:header&gt;</code> 可以简写为 <code>&lt;template #header&gt;</code>。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。</p>
<p><strong>动态插槽名</strong></p>
<pre><code class="language-vue">&lt;base-layout&gt;
  &lt;template v-slot:[dynamicSlotName]&gt;
    ...
  &lt;/template&gt;

  &lt;!-- 缩写为 --&gt;
  &lt;template #[dynamicSlotName]&gt;
    ...
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<p><strong>作用域插槽</strong></p>
<p>在上面的<a href="https://cn.vuejs.org/guide/components/slots.html#render-scope">渲染作用域</a>中我们讨论到，插槽的内容无法访问到子组件的状态。</p>
<p>然而在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。</p>
<p>我们也确实有办法这么做！可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes：</p>
<pre><code>
</code></pre>
<h2>异步组件</h2>
<pre><code class="language-vue">const AsyncComp = defineAsyncComponent({
  // 加载函数
  loader: () =&gt; import(&#39;./Foo.vue&#39;),

  // 加载异步组件时使用的组件
  loadingComponent: LoadingComponent,
  // 展示加载组件前的延迟时间，默认为 200ms
  delay: 200,

  // 加载失败后展示的组件
  errorComponent: ErrorComponent,
  // 如果提供了一个 timeout 时间限制，并超时了
  // 也会显示这里配置的报错组件，默认值是：Infinity
  timeout: 3000
})
</code></pre>
<h3>组合式函数--封装</h3>
<pre><code class="language-vue">// event.js
import { onMounted, onUnmounted } from &#39;vue&#39;

export function useEventListener(target, event, callback) {
  // 如果你想的话，
  // 也可以用字符串形式的 CSS 选择器来寻找目标 DOM 元素
  onMounted(() =&gt; target.addEventListener(event, callback))
  onUnmounted(() =&gt; target.removeEventListener(event, callback))
}


// mouse.js
import { ref } from &#39;vue&#39;
import { useEventListener } from &#39;./event&#39;

export function useMouse() {
  const x = ref(0)
  const y = ref(0)

  useEventListener(window, &#39;mousemove&#39;, (event) =&gt; {
    x.value = event.pageX
    y.value = event.pageY
  })

  return { x, y }
}
</code></pre>
<h2>插件</h2>
<h2><code>&lt;Transition&gt;</code> 组件</h2>
<ul>
<li>由 <code>v-if</code> 所触发的切换</li>
<li>由 <code>v-show</code> 所触发的切换</li>
<li>由特殊元素 <code>&lt;component&gt;</code> 切换的动态组件</li>
<li>改变特殊的 <code>key</code> 属性</li>
</ul>
<pre><code class="language-vue">&lt;Transition name=&quot;slide-fade&quot;&gt;
  &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;
&lt;/Transition&gt;
</code></pre>
<pre><code class="language-css">/*
  进入和离开动画可以使用不同
  持续时间和速度曲线。
*/
.slide-fade-enter-active {
  transition: all 0.3s ease-out;
}

.slide-fade-leave-active {
  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
}

.slide-fade-enter-from,
.slide-fade-leave-to {
  transform: translateX(20px);
  opacity: 0;
}
</code></pre>
<p><strong>同时使用 transition 和 animation</strong></p>
<p>Vue 需要附加事件监听器，以便知道过渡何时结束。可以是 <code>transitionend</code> 或 <code>animationend</code>，这取决于你所应用的 CSS 规则。如果你仅仅使用二者的其中之一，Vue 可以自动探测到正确的类型。</p>
<p>然而在某些场景中，你或许想要在同一个元素上同时使用它们两个。举例来说，Vue 触发了一个 CSS 动画，同时鼠标悬停触发另一个 CSS 过渡。此时你需要显式地传入 <code>type</code> prop 来声明，告诉 Vue 需要关心哪种类型，传入的值是 <code>animation</code> 或 <code>transition</code>：</p>
<pre><code>&lt;Transition type=&quot;animation&quot;&gt;...&lt;/Transition&gt;
</code></pre>
<h3>第三方动画库</h3>
<h3>渐进延迟列表动画</h3>
<p>JavaScript钩子  GSAP</p>
<h2>Pinia</h2>
<p>直接解构Pinia中的响应式属性会失去属性的响应式，正确的方式为：</p>
<pre><code class="language-js">const { name, doubleCount } = storeToRefs(store)
</code></pre>
<h1>尚硅谷禹神Vue3教程</h1>
<img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" />



<h2>1.Vue3简介</h2>
<ul>
<li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li>
<li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li>
<li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li>
</ul>
<h2>2.Vue3带来了什么</h2>
<h3>1.性能的提升</h3>
<ul>
<li><p>打包大小减少41%</p>
</li>
<li><p>初次渲染快55%, 更新渲染快133%</p>
</li>
<li><p>内存减少54%</p>
<p>......</p>
</li>
</ul>
<h3>2.源码的升级</h3>
<ul>
<li><p>使用Proxy代替defineProperty实现响应式</p>
</li>
<li><p>重写虚拟DOM的实现和Tree-Shaking</p>
<p>......</p>
</li>
</ul>
<h3>3.拥抱TypeScript</h3>
<ul>
<li>Vue3可以更好的支持TypeScript</li>
</ul>
<h3>4.新的特性</h3>
<ol>
<li><p>Composition API（组合API）</p>
<ul>
<li>setup配置</li>
<li>ref与reactive</li>
<li>watch与watchEffect</li>
<li>provide与inject</li>
<li>......</li>
</ul>
</li>
<li><p>新的内置组件</p>
<ul>
<li>Fragment </li>
<li>Teleport</li>
<li>Suspense</li>
</ul>
</li>
<li><p>其他改变</p>
<ul>
<li>新的生命周期钩子</li>
<li>data 选项应始终被声明为一个函数</li>
<li>移除keyCode支持作为 v-on 的修饰符</li>
<li>......</li>
</ul>
</li>
</ol>
<h2>一、创建Vue3.0工程</h2>
<p><strong>Vetur和Vue Language Features (Volar)<code>v1.</code>冲突</strong></p>
<h3>1.使用 vue-cli 创建</h3>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20230509193818993.png" alt="image-20230509193818993"></p>
<p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p>
<pre><code class="language-bash">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上
vue --version
## 安装或者升级你的@vue/cli
npm install -g @vue/cli
## 创建
vue create vue_test
## 启动
cd vue_test
npm run serve
</code></pre>
<h3>2.使用 vite 创建</h3>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20230509193849736.png" alt="image-20230509193849736"></p>
<p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p>
<p>vite官网：<a href="https://vitejs.cn">https://vitejs.cn</a></p>
<ul>
<li><p>什么是vite？—— 新一代前端构建工具。</p>
</li>
<li><p>优势如下：</p>
<ul>
<li>开发环境中，无需打包操作，可快速的冷启动。</li>
<li>轻量快速的热重载（HMR）。</li>
<li>真正的按需编译，不再等待整个应用编译完成。</li>
</ul>
</li>
</ul>
<h4>文件说明和配置指南：</h4>
<ol>
<li><code>vite.config.ts</code>：<ul>
<li>作用：Vite 的配置文件，用于配置 Vite 在构建和开发过程中的相关设置。</li>
<li>配置选项：可以配置端口号、代理服务器、打包输出路径等等。具体可以参考 <a href="https://cn.vitejs.dev/config/">Vite 官方文档</a>。</li>
</ul>
</li>
<li><code>tsconfig.node.json</code>：<ul>
<li>作用：配置 TypeScript 编译器在 Node.js 程序中编译时所需的相关选项。</li>
<li>配置选项：具体可以参考 <a href="https://www.aidutu.cn/info/link?url=https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">TypeScript 官方文档</a>。</li>
</ul>
</li>
<li><code>tsconfig.json</code>：<ul>
<li>作用：配置 TypeScript 编译器在浏览器环境下编译时所需的相关选项。</li>
<li>配置选项：具体可以参考 <a href="https://www.aidutu.cn/info/link?url=https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">TypeScript 官方文档</a>。</li>
</ul>
</li>
<li><code>package.json</code>：<ul>
<li>作用：用来管理当前项目依赖的库以及其他相关的项目信息，比如项目名称、版本号等等。</li>
<li>配置选项：可以配置项目的脚本命令、依赖库、版本号等等。</li>
</ul>
</li>
<li><code>package-lock.json</code>：<ul>
<li>作用：记录了当前项目中所有已安装依赖库的精确版本号，避免依赖库版本的混乱问题。</li>
</ul>
</li>
<li><code>vite-env.d.ts</code>：<ul>
<li>作用：定义项目中环境变量的类型，有助于在代码中准确地引用和使用环境变量。</li>
<li>配置选项：定义相关的环境变量类型即可，例如 <code>VITE_APP_API_BASE_URL: string</code> 等等。</li>
</ul>
</li>
<li><code>.gitignore</code>：<ul>
<li>作用：配置 Git 对</li>
</ul>
</li>
</ol>
<pre><code class="language-bash">## 创建工程
npm init vite-app &lt;project-name&gt;
## 进入工程目录
cd &lt;project-name&gt;
## 安装依赖
npm install
## 运行
npm run dev
</code></pre>
<h2>二、常用 Composition API</h2>
<p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p>
<h3>1.拉开序幕的setup</h3>
<ol>
<li>理解：Vue3.0中一个新的配置项，值为一个函数。</li>
<li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li>
<li>组件中所用到的：数据、方法等等，均要配置在setup中。</li>
<li>setup函数的两种返回值：<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li>
</ol>
</li>
<li>注意点：<ol>
<li>尽量不要与Vue2.x配置混用<ul>
<li>Vue2.x配置（data、methos、computed...）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed...）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
</ol>
</li>
</ol>
<h3>2.ref函数</h3>
<ul>
<li>作用: 定义一个响应式的数据</li>
<li>语法: <code>const xxx = ref(initValue)</code> <ul>
<li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li>
<li>JS中操作数据： <code>xxx.value</code></li>
<li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;{{xxx}}&lt;/div&gt;</code></li>
</ul>
</li>
<li>备注：<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>
</ul>
</li>
</ul>
<h3>3.reactive函数</h3>
<ul>
<li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li>
<li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li>
<li>reactive定义的响应式数据是“深层次的”。</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>
</ul>
<h3>4.Vue3.0中的响应式原理</h3>
<h4>vue2.x的响应式</h4>
<ul>
<li><p>实现原理：</p>
<ul>
<li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<pre><code class="language-js">Object.defineProperty(data, &#39;count&#39;, {
    get () {}, 
    set () {}
})
</code></pre>
</li>
</ul>
</li>
<li><p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h4>Vue3.0的响应式</h4>
<ul>
<li><p>实现原理: </p>
<ul>
<li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p>
</li>
<li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p>
</li>
<li><p>MDN文档中描述的Proxy与Reflect：</p>
<ul>
<li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
</li>
<li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
<pre><code class="language-js">new Proxy(data, {
    // 拦截读取属性值
    get (target, prop) {
        return Reflect.get(target, prop)
    },
    // 拦截设置属性值或添加新属性
    set (target, prop, value) {
        return Reflect.set(target, prop, value)
    },
    // 拦截删除属性
    deleteProperty (target, prop) {
        return Reflect.deleteProperty(target, prop)
    }
})

proxy.name = &#39;tom&#39;   
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>Proxy</h4>
<pre><code class="language-js">let person = {
                name:&#39;张三&#39;,
                age:18
            }
            
    const p = new Proxy(person,{
                //有人读取p的某个属性时调用
                get(target,propName){
                    console.log(target,propName);
                    console.log(`有人读取了p身上的${propName}属性`)
                    return Reflect.get(target,propName)
                },
                //有人修改p的某个属性、或给p追加某个属性时调用
                set(target,propName,value){
                    console.log(target,propName,value);
                    console.log(`有人修改了p身上的${propName}属性，我要去更新界面了！`)
                    Reflect.set(target,propName,value)
                },
                //有人删除p的某个属性时调用
                deleteProperty(target,propName){
                    console.log(`有人删除了p身上的${propName}属性，我要去更新界面了！`)
                    return Reflect.deleteProperty(target,propName)
                }
            })
</code></pre>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20230506165647779.png" alt="image-20230506165647779"></p>
<h3>5.reactive对比ref</h3>
<ul>
<li>从定义数据角度对比：<ul>
<li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li>
<li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li>
<li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li>
</ul>
</li>
<li>从原理角度对比：<ul>
<li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li>
</ul>
</li>
<li>从使用角度对比：<ul>
<li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li>
<li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li>
</ul>
</li>
</ul>
<h3>6.setup的两个注意点</h3>
<ul>
<li><p>setup执行的时机</p>
<ul>
<li><strong>在beforeCreate之前执行一次，this是undefined。</strong></li>
</ul>
</li>
<li><p>setup的参数</p>
<ul>
<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>
<li>context：上下文对象<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>7.计算属性与监视</h3>
<h4>1.computed函数</h4>
<ul>
<li><p>与Vue2.x中computed配置功能一致</p>
</li>
<li><p>写法</p>
<pre><code class="language-js">import {computed} from &#39;vue&#39;

setup(){
    ...
    //计算属性——简写
    let fullName = computed(()=&gt;{
        return person.firstName + &#39;-&#39; + person.lastName
    })
    //计算属性——完整
    let fullName = computed({
        get(){
            return person.firstName + &#39;-&#39; + person.lastName
        },
        set(value){
            const nameArr = value.split(&#39;-&#39;)
            person.firstName = nameArr[0]
            person.lastName = nameArr[1]
        }
    })
}
</code></pre>
</li>
</ul>
<h4>2.watch函数</h4>
<ul>
<li><p>与Vue2.x中watch配置功能一致</p>
</li>
<li><p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<pre><code class="language-js">这种方式是无法获得oldvalue的值的，
    watch(person,(newvalue,oldvalue)=&gt;{console.log(&quot;person被改变了&quot;,newvalue,oldvalue)},
    // {deep:false}
    )

watch(()=&gt;person.MyInventory.Myweapon.Mymelee,
      (newvalue,oldvalue)=&gt;{console.log(&quot;person.MyInventory.Myweapon.Mymelee被改变了&quot;,newvalue,oldvalue)},
      {deep:true}
    )
    
()=&gt;person.MyInventory.Myweapon.Mymelee 加上[]则会获取不到newvalue,oldvalue

监视reactive所定义的一个响应式数据中的某个属性，要用箭头函数来写：
    watch(()=&gt;person.gamename,(newvalue,oldvalue)=&gt;{console.log(&quot;person.gamename被改变了&quot;,newvalue,oldvalue)},
    // {deep:false}
    )
</code></pre>
<pre><code class="language-js">//情况一：监视ref定义的响应式数据
watch(sum,(newValue,oldValue)=&gt;{
    console.log(&#39;sum变化了&#39;,newValue,oldValue)
},{immediate:true})

//情况二：监视多个ref定义的响应式数据
watch([sum,msg],(newValue,oldValue)=&gt;{
    console.log(&#39;sum或msg变化了&#39;,newValue,oldValue)
}) 

/* 情况三：监视reactive定义的响应式数据
            若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！
            若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 
*/
watch(person,(newValue,oldValue)=&gt;{
    console.log(&#39;person变化了&#39;,newValue,oldValue)
},{immediate:true,deep:false}) //此处的deep配置不再奏效

//情况四：监视reactive定义的响应式数据中的某个属性
watch(()=&gt;person.job,(newValue,oldValue)=&gt;{
    console.log(&#39;person的job变化了&#39;,newValue,oldValue)
},{immediate:true,deep:true}) 

//情况五：监视reactive定义的响应式数据中的某些属性
watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;{
    console.log(&#39;person的job变化了&#39;,newValue,oldValue)
},{immediate:true,deep:true})

//特殊情况
watch(()=&gt;person.job,(newValue,oldValue)=&gt;{
    console.log(&#39;person的job变化了&#39;,newValue,oldValue)
},{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效
</code></pre>
</li>
</ul>
<h4>3.watchEffect函数</h4>
<ul>
<li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>
</li>
<li><p>watchEffect有点像computed：</p>
<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
<pre><code class="language-js">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。
watchEffect(()=&gt;{
    const x1 = sum.value
    const x2 = person.age
    console.log(&#39;watchEffect配置的回调执行了&#39;)
})
</code></pre>
</li>
</ul>
<h4>8.生命周期</h4>
<p>注意：</p>
<pre><code>用v-if &lt;MySecond v-if=&quot;isshow&quot;/&gt;似乎是真正的挂载卸载
</code></pre>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20230506214458483.png" alt="image-20230506214458483"></p>
<pre><code>但是用v-show &lt;MySecond v-show=&quot;isshow&quot;/&gt;并没有触发相应的生命周期购子
</code></pre>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20230506214659881.png" alt="image-20230506214659881"></p>
<ul>
<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul>
<li><code>beforeCreate</code>===&gt;<code>setup()</code></li>
<li><code>created</code>=======&gt;<code>setup()</code></li>
<li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>=======&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> =======&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<h4>9.自定义hook函数</h4>
<ul>
<li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>
</li>
<li><p>类似于vue2.x中的mixin。</p>
</li>
<li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
</li>
</ul>
<h4>10.toRef</h4>
<pre><code>不要写成下面的！！！！！！！！！
let name_toRef = toRef(person.name, &quot;name&quot;);  错误
let name_toRef = toRef(person, &quot;name&quot;);   正确
</code></pre>
<ul>
<li><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p>
</li>
<li><p><strong>语法：<code>const name = toRef(person,&#39;name&#39;)</code></strong></p>
</li>
<li><p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p>
</li>
<li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p>
</li>
</ul>
<h2>三、其它 Composition API</h2>
<h3>1.shallowReactive 与 shallowRef</h3>
<ul>
<li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>
</li>
<li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li><p>什么时候使用?</p>
<ul>
<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li>
<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h3>2.readonly 与 shallowReadonly</h3>
<ul>
<li>readonly: 让一个响应式数据变为只读的（深只读）。</li>
<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li>
<li>应用场景: 不希望数据被修改时。</li>
</ul>
<h3>3.toRaw 与 markRaw</h3>
<ul>
<li>toRaw：<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>markRaw：<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>
<li>应用场景:<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3>4.customRef</h3>
<ul>
<li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
</li>
<li><p>实现防抖效果：</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;
    &lt;h3&gt;{{keyword}}&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
    import {ref,customRef} from &#39;vue&#39;
    export default {
        name:&#39;Demo&#39;,
        setup(){
            // let keyword = ref(&#39;hello&#39;) //使用Vue准备好的内置ref
            //自定义一个myRef
            function myRef(value,delay){
                let timer
                //通过customRef去实现自定义
                return customRef((track,trigger)=&gt;{
                    return{
                        get(){
                            track() //告诉Vue这个value值是需要被“追踪”的
                            return value
                        },
                        set(newValue){
                            clearTimeout(timer)
                            timer = setTimeout(()=&gt;{
                                value = newValue
                                trigger() //告诉Vue去更新界面
                            },delay)
                        }
                    }
                })
            }
            let keyword = myRef(&#39;hello&#39;,500) //使用程序员自定义的ref
            return {
                keyword
            }
        }
    }
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h3>5.provide 与 inject</h3>
<img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" />

<ul>
<li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p>
</li>
<li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li><p>具体写法：</p>
<ol>
<li><p>祖组件中：</p>
<pre><code class="language-js">setup(){
    ......
    let car = reactive({name:&#39;奔驰&#39;,price:&#39;40万&#39;})
    provide(&#39;car&#39;,car)
    ......
}
</code></pre>
</li>
<li><p>后代组件中：</p>
<pre><code class="language-js">setup(props,context){
    ......
    const car = inject(&#39;car&#39;)
    return {car}
    ......
}
</code></pre>
</li>
</ol>
</li>
</ul>
<h3>6.响应式数据的判断</h3>
<ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<h2>四、Composition API 的优势</h2>
<h3>1.Options API 存在的问题</h3>
<p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p>
<div style="width:600px;height:370px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" />
</div>
<div style="width:300px;height:370px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> 
</div>
















<h3>2.Composition API 的优势</h3>
<p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p>
<div style="width:500px;height:340px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>
<div style="width:430px;height:340px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>














<h2>五、新的组件</h2>
<h3>1.Fragment</h3>
<ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<h3>2.Teleport</h3>
<ul>
<li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p>
<pre><code class="language-vue">&lt;teleport to=&quot;移动位置&quot;&gt;
    &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;
        &lt;div class=&quot;dialog&quot;&gt;
            &lt;h3&gt;我是一个弹窗&lt;/h3&gt;
            &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/teleport&gt;
</code></pre>
</li>
</ul>
<h3>3.Suspense</h3>
<ul>
<li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li><p>使用步骤：</p>
<ul>
<li><p>异步引入组件</p>
<pre><code class="language-js">import {defineAsyncComponent} from &#39;vue&#39;
const Child = defineAsyncComponent(()=&gt;import(&#39;./components/Child.vue&#39;))
</code></pre>
</li>
<li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;div class=&quot;app&quot;&gt;
        &lt;h3&gt;我是App组件&lt;/h3&gt;
        &lt;Suspense&gt;
            &lt;template v-slot:default&gt;
                &lt;Child/&gt;
            &lt;/template&gt;
            &lt;template v-slot:fallback&gt;
                &lt;h3&gt;加载中.....&lt;/h3&gt;
            &lt;/template&gt;
        &lt;/Suspense&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2>六、其他</h2>
<h3>1.全局API的转移</h3>
<ul>
<li><p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li><p>例如：注册全局组件、注册全局指令等。</p>
<pre><code class="language-js">//注册全局组件
Vue.component(&#39;MyButton&#39;, {
  data: () =&gt; ({
    count: 0
  }),
  template: &#39;&lt;button @click=&quot;count++&quot;&gt;Clicked {{ count }} times.&lt;/button&gt;&#39;
})

//注册全局指令
Vue.directive(&#39;focus&#39;, {
  inserted: el =&gt; el.focus()
}
</code></pre>
</li>
</ul>
</li>
<li><p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong style="color:#DD5145">移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3>2.其他改变</h3>
<ul>
<li><p>data选项应始终被声明为一个函数。</p>
</li>
<li><p>过度类名的更改：</p>
<ul>
<li><p>Vue2.x写法</p>
<pre><code class="language-css">.v-enter,
.v-leave-to {
  opacity: 0;
}
.v-leave,
.v-enter-to {
  opacity: 1;
}
</code></pre>
</li>
<li><p>Vue3.x写法</p>
<pre><code class="language-css">.v-enter-from,
.v-leave-to {
  opacity: 0;
}

.v-leave-from,
.v-enter-to {
  opacity: 1;
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li><p>父组件中绑定事件</p>
<pre><code class="language-vue">&lt;my-component
  v-on:close=&quot;handleComponentEvent&quot;
  v-on:click=&quot;handleNativeClickEvent&quot;
/&gt;
</code></pre>
</li>
<li><p>子组件中声明自定义事件</p>
<pre><code class="language-vue">&lt;script&gt;
  export default {
    emits: [&#39;close&#39;]
  }
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li><p>......</p>
</li>
</ul>
<h1>源码手写笔记</h1>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20230927104825149.png" alt="image-20230927104825149"></p>
<pre><code>4b14e4d
8cf0323
750a970
f011ae7
c06eb24
09fc6f3
17bb9a4
2f6891e
</code></pre>
<h2>叙述</h2>
<h3>CSDN博客模板：</h3>
<p> 写在前面的话</p>
<p>b站无意发现了一个讲解Vue2源码的up主，讲的非常细致，功力深厚，于是乎我准备跟着up主的视频将Vue2的大致功能手敲一遍，此为我自己记录的笔记，可读性不高，建议配合代码使用，如果不结合代码来看，应该是看不懂我在说什么，emmm</p>
<p>作为一个前端菜鸟，难免会有错误，如有错误，恳请指正</p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/85f0e064a0c64699ad982698e75c0c66.gif" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>里面也有一些我自己没怎么搞清楚的点，(尤其是计算属性的收集渲染watcher那块的dep和watcher的相互收集)，代码已上传github，目前还只看到了P15，大致一课一提交，github地址：</p>
<pre><code>https://github.com/wr40000/vuesourecode.git
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>b站up主:不会cv</p>
<p>视频链接：</p>
<pre><code>【【vue+vuex+VueRouter源码】从零手写自己的vue】 https://www.bilibili.com/video/BV1JW4y1j7yE/?share_source=copy_web&amp;vd_source=b13bf39ff616b673337790b360357231
</code></pre>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3><strong>数据代理&amp;数据劫持</strong></h3>
<p><strong>Vue.prototype._init</strong>将用户options赋值给<code>vm.$options</code>，这里的vm是vue实例，</p>
<p>接着将该实例vm交给<strong>initState</strong>(vm)进行处理，initState里判断<code>vm.$options.data</code>是否存在，有用户数据存在，则将vm交给<strong>initData</strong>处理</p>
<p>**initData(vm)**中，会根据用户数据是函数式还是对象式，Vue官方推荐的data表形式是函数式，将vm.$options.data赋值给vm._data,然后将data交给observe(data)进行数据劫持,所以:</p>
<pre><code>用户的data === vm.$options.data === vm._data //似乎没有考虑到 mixin的情况
</code></pre>
<p><strong>observe</strong>(data)中首先会判断数据类型，因为只对对象进行数据劫持，判断为对象，则</p>
<p><code>return new Observe(data)</code></p>
<p><strong>Observe</strong>(data)<code>[注: Observe是个类]</code>中有walk方法，其实就是通过defineProperties重新定义属性，性能不好，</p>
<pre><code class="language-js">walk(data){
        // 重新定义属性  性能不太行
        Object.keys(data).forEach(key =&gt; defineReactive(data,key,data[key]))
    }
   
export function defineReactive(target, key, value) {
    observe(value);
    Object.defineProperties(target, {
        [key]: {
            get() {
                console.log(&quot;用户取值了&quot;);
                return value;
            },
            set(newValue) {
                console.log(&quot;用户更改值了&quot;);
                if (value === newValue) return;
                value = newValue;
            }
        }
    });
}   
</code></pre>
<p>之所以可以通过<code>vm.属性名</code>的方式直接访问属性是因为，做了一层代理<code>(不做的话要通过 vm._data.属性名 来访问)</code>，</p>
<pre><code class="language-js">for(let key in data){
    proxy(vm, &quot;_data&quot;, key)
}
// vm._data 用vm 代理 使得读取vm._data.name可以简化为vm.name
function proxy(vm, target, key){
    Object.defineProperties(vm,{
        [key]:
        {
            get(){
                return vm[target][key]
            },
            set(newvalue){                
                if(vm[target][key] === newvalue) return
                vm[target][key] = newvalue
            }
        }
    })
}
</code></pre>
<p>但是要考虑到data中有数组的情况，Vue中，除了那七个方法之外，不对数组的基本数据类型做监测，现在要实现那七个方法的新增数据的数据劫持，就要重写那七个方法，现在在类Observe的constructor中：</p>
<pre><code class="language-js">// 这里是为了在重写数组方法时可以访问到Observe上的方法
Object.defineProperties(data,{
    [&#39;__ob__&#39;]: 
    {
        value: this,
        enumerable: false
    }
})
</code></pre>
<p>在给data定义一个属性，目的是加上walk observeArray等方法，但是要设置为不可枚举，否则陷入死循环，接下来判断data是否为数组，是就执行:</p>
<pre><code class="language-js">data.__proto__ = newArrayproto
// 这里我们要重新重写数组的7个方法，但同时保留其他的方法
this.observeArray(data)
//observeArray是遍历数元素，对每个元素observe(item)，目的是将对象全部劫持
</code></pre>
<p>那么怎么重写数组的七个方法, 这里用到了切片编程:</p>
<pre><code class="language-js">let oldArrayproto = Array.prototype;

export let newArrayproto = Object.create(oldArrayproto);

let methods = [
    &quot;shift&quot;,
    &quot;unshift&quot;,
    &quot;pop&quot;,
    &quot;push&quot;,
    &quot;reverse&quot;,
    &quot;sort&quot;,
    &quot;splice&quot;
]// concat slice不会改变原数组

methods.forEach((method) =&gt; {
    newArrayproto[method] = function(...args){  // 重写数组的方法
        const result = oldArrayproto[method].call(this,...args);   // 内部调用原来的方法，函数劫持 切片编程
        console.log(method);

        // 对对新增的数据再次观测
        let inserted;
        let ob = this.__ob__;  //外部data调用方法，所以this就指向data
        switch(method){
            case &#39;push&#39;:
            case &quot;unshift&quot;:     //vm.arr.unshift({a: 100})
                inserted = args;
                break;
            case &quot;splice&quot;:      //vm.arr.splice(0, 1, 55,56,57)
                inserted = args.slice(2);
                break;
        }
        console.log(inserted);
        if(inserted){
            ob.observeArray(inserted)
        }
        return result;
    }
})
</code></pre>
<p>其实很简单，首先创建一个新的原型对象<code>newArrayproto</code>，他和 <code>Array.prototype</code> 完全一样，然后重写newArrayproto上的七个方法，内部还是调用了 Array.prototype的那七个方法，只不过将新增的数据，也就是</p>
<p><code>inserted</code>通过<code>this.__ob__</code>上的方法在进行数据劫持，result为方法结果，不处理。</p>
<p><strong>当调用数组的这些方法时，Vue 2 就能够在内部进行依赖收集，并在数据发生变更时通知相关的观察者。</strong></p>
<h3>模板编译</h3>
<p>在Vue.prototype._init中，判断用户的el配置是否存在，有就将el交给<code>vm.$mount(options.el)</code>处理</p>
<p>Vue.prototype.$mount首先查找有无render,没有就:没写template用外部的template,或者写了template用自己的的template，接下来将模板交给compileToFunction</p>
<p>compileToFunction中首先执行parseHTML(html)，parseHTML通过正则表达式和栈的数据结构将html代码转为ast语法树，接着将ast通过codegen(ast)转为</p>
<pre><code class="language-js">_c(&#39;div&#39;,{id:&quot;app&quot;,key:&quot;app&quot;,style:{&quot;color&quot;:&quot;red&quot;,&quot;background-color&quot;:&quot;yellow&quot;}},_c(&#39;div&#39;,{style:{&quot;color&quot;:&quot;red&quot;},key:&quot;div&quot;},_v(_s(arr[3].JNTM)+&quot;Terraria&quot;+_s(arr[1])+&quot;Terraria&quot;)),_c(&#39;span&#39;,{key:&quot;span&quot;},_v(_s(tool[&#39;铁皮药剂&#39;]))))
</code></pre>
<p>然后将生成的代码封装成函数返回</p>
<pre><code class="language-js">code = `with(this){return ${code}}`;   //with作用是使代码可以访问传进来的this的属性
let render = new Function(code);    //根据代码生成render函数
</code></pre>
<p>再将compileToFunction返回的render函数赋值给vm.$options.render</p>
<h3>执行render函数</h3>
<p>完成render函数后，将执行mountComponent(vm, el)挂载组件，这里的el是个真实的dom元素，mountComponent中中，先将el赋值给vm.$el, 然后执行</p>
<pre><code class="language-js">vm._updata(vm._render());   //虚拟节点扩展为真实节点

//其中 
//vm._render();   //vm.$options.render() 虚拟节点
</code></pre>
<p>在执行之前，先向Vue的原型上增加几个方法，在根目录index.js中initLifeCycle(Vue);增加</p>
<pre><code>_updata，_c, _s, _v, _render
</code></pre>
<p>_render方法  <code>也用到了createElementVNode createTextVNode来处理不同的_s _v _c函数 不细讲了</code>:</p>
<pre><code class="language-js">Vue.prototype._render = function(){        
    const vm = this;
    // 让with中的this 指向 vm
    // 当渲染的时候会去实例上取值，我们就可以将属性和视图绑定在一起
    return vm.$options.render.call(vm)    // 通过ast语法转义后的render方法
}
</code></pre>
<p>返回的的是虚拟节点，在虚拟节点里，这里实际上会直接去vm上取值，也就是将{{arr[1]}}更换为了具体的用户数据，拿到虚拟节点后，执行_updata方法，更换真实节点，</p>
<p>_updata中，将树形结构的虚拟节点通过递归，创建真实的dom节点，并将属性添加到相应的节点上，接着判断老dom是不是真实元素，这里主要是区分初渲染流程，是的话直接将新的插入，老的删除，否则进行diff算法对比</p>
<p>好了，至此，只要每次数据更新调用<code>vm._updata(vm._render());</code>即可更新模板，但是如何实现自动更新，发现通过数据的get 和 set可以完善这套逻辑</p>
<p>现在将<code>vm._updata(vm._render())</code>封装到一个函数<strong>updataComponent</strong>中，在创建一个类watcher，一个watcher对应一个组件, 将vm, updataComponent传给watcher</p>
<pre><code class="language-js">const watcher = new Watcher(vm, updataComponent, true) //true表示是否为渲染函数
</code></pre>
<p>这时，要进行的工作就是依赖收集，我们要确定一个组件中，使用了几个属性</p>
<p>但是，相对的，一个属性也要确定被几个组件使用了，同时也要注意收集依赖时去重</p>
<p>这里每一个属性都对应了一个类Dep，区分不同的属性使用Dep里的id, watcher同理</p>
<p>同时要做的一件事是，只更新需要更新的组件，也就是更新时，数据的Dep会通知对应的watcher执行重新渲染</p>
<p>因此，使用defineProperties初始化数据时，执行<code>let dep = new Dep();</code>,并且在get时：</p>
<pre><code class="language-js">if(Dep.target){
    dep.depend();//让这个属性收集器记住当前的watch
}
</code></pre>
<p>set时重新render:<code>dep.notify()</code>, notify方法会将当前Dep上收集的所有watcher触发更新**updata()**函数，这个在处理异步更新时会说到</p>
<pre><code class="language-js">notify(){
    this.subs.forEach(watcher=&gt;watcher.updata())
}
</code></pre>
<p>watcher中的<code>Dep.target = this： </code></p>
<pre><code>//GPT
    在 Vue 的响应式系统中，每个数据属性都有一个对应的 Dep 对象，而 Dep 对象管理着这个数据属性的依赖项（即依赖该数据属性的 Watcher 实例）。

当一个 Watcher 实例初始化时，它会在内部创建一个依赖项列表，用来存储它所依赖的数据属性的 Dep 对象。在 get 方法中，Watcher 实例会访问数据属性，这会触发数据属性的 get 操作，然后 Dep 对象会将当前的 Watcher 实例添加到自己的依赖项列表中，建立依赖关系。

这样，每个 Watcher 实例都会与它所依赖的数据属性的 Dep 对象建立联系。当数据属性发生变化时，Dep 对象会通知它的依赖项列表中的 Watcher 实例执行更新操作，确保只有相关的 Watcher 会被触发更新，而不会浪费不必要的计算和渲染。
</code></pre>
<p>watcher中有了<code>Dep.target = this;</code>就可以在watcher和Dep中建立双向关系, </p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <strong>难点分析：</strong></li>
</ul>
<p>这一点不完善，没有考虑到计算属性这种情况，应为有计算watcher这种东西，对于后文中比较完善的写法，以 <strong>Dep.target</strong>指向watcher栈顶元素的写法， 其解释为：</p>
<ul>
<li>是的，你理解得基本正确。在 Vue 中，<code>Dep.target</code> 是一个全局变量，用于存储当前正在进行依赖收集的 <code>Watcher</code> 对象。当一个属性被访问时，它的 <code>Dep</code> 对象的 <code>depend</code> 方法中会使用 <code>Dep.target</code> 建立起与当前依赖收集的 <code>Watcher</code> 之间的关系。</li>
</ul>
<p>具体来说，当 <code>pushTarget(watcher)</code> 被调用时，<code>watcher</code> 被推入一个栈（<code>stack</code> 数组）中，然后 <code>Dep.target</code> 被设置为当前的 <code>watcher</code>。在进行依赖收集时，如果一个属性的 <code>Dep</code> 对象的 <code>depend</code> 方法被调用，那么它会将当前的 <code>Dep.target</code>（也就是当前正在进行依赖收集的 <code>watcher</code>）添加到 <code>subs</code> 数组中，建立起两者之间的关系。</p>
<p>而在依赖收集完成后，通过 <code>popTarget</code> 将当前 <code>watcher</code> 出栈，同时将 <code>Dep.target</code> 恢复为栈顶的 <code>watcher</code>。这样做的目的是确保在进行嵌套的依赖收集时，<code>Dep.target</code> 始终能够正确地指向当前的 <code>watcher</code>，以保持正确的上下文关系。</p>
<p>所以，你可以认为在当前 <code>watcher</code> 中，处理的属性在经过 <code>Dep.target = watcher</code> 后，该属性对应的 <code>Dep</code> 对象的 <code>target</code> 就指向了当前的 <code>watcher</code>。这确保了依赖关系的正确建立。</p>
<p>dep.depend()中可以访问到当前的watcher实例Dep.target并调用当前watcher上的addDep方法;</p>
<pre><code class="language-js">depend(){
    // 不希望放重复的watcher 而且刚才只是一个单向的关系  dep =&gt; Watcher
    // this.subs.push(Dep.target);
    Dep.target.addDep(this) //让watcher记住dep  双向
    // watcher和Dep是一个多对多的关系(一个属性可以再多个组件中使用dep -&gt; 多个watcher)
    // 一个组件中由多个属性组成(一个watcher对应多个dep)
}
</code></pre>
<p>addDep会将该Dep添加到当前的实例watcher上，同时watcher上的addDep(dep)又触发了Dep实例上的addSub方法：</p>
<pre><code class="language-js">addDep(dep){    //一个事件对应着多个属性 重复的属性也不用记录
    let id = dep.id;
    if(!this.depsId.has(id)){
        this.deps.push(dep);
        this.depsId.add(id);
        dep.addSub(this);   //watcher已经记住了dep,此时让dep也记住watcher
    }
}
</code></pre>
<p>Dep上的addSub方法又将实例watcher添加到当前的Dep上:</p>
<pre><code class="language-js">addSub(watcher){
    this.subs.push(watcher)
}
</code></pre>
<p>建立了依赖关系后，现在发现有个浪费性能的问题，对同一属性的更改最好是只在最后一次触发属性，有点类似防抖，而目前的情况是无论修改同一属性多少次，我们将触发更新相同的次数，解决的手段是将更新事件放到队列里</p>
<p>所以现在将updata()函数写为:</p>
<pre><code class="language-js">updata(){
    // this.get()  //重新更新 浪费性能的写法
    queueWatcher(this)  //把当前watcher存起来  放到一个队列里
};
</code></pre>
<h3>异步刷新</h3>
<p>目前维护了一个队列queue, 一个用于防抖目的的对象has，queueWatcher()函数以watcher的ID为辨识，对同一id，has对象只会将对应的watcher在第一次时放进queue,，然后将has[id] = true,将watcher放入queue的条件是(!has[id])，只有当下次watcher的id不同时，才会继续向queue里放watcher, 刷新就执行<strong>nextTick</strong>函数，这个过程为了保证异步刷新，**timeFunc()**采取了优雅降级的策略，稍微有些复杂</p>
<p>queue刷新的操作是flushSchedulerQueue，nextTick(flushSchedulerQueue, 0)</p>
<p>flushSchedulerQueue是清空队列，执行刷新的函数,nextTick 中会使 <strong>callbacks</strong> 收集这些待执行任务，timeFunc()是用于顺序执行这些啥刷新任务的</p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20240108112811070.png" alt="image-20240108112811070"></p>
<p><strong>nextTick方法不仅用在此处</strong>，作为export的属性，并且被放在了Vue的原型上<code>Vue.prototype.$nextTick = nextTick</code></p>
<pre><code class="language-js">//主要功能是在下一个事件循环中执行回调函数，它通常用于保证清空刷新任务的异步回调函数按照特定的顺序执行。
export function nextTick(cb){//cb就是flushSchedulerQueue
    //cb是每个待执行的任务
    callbacks.push(cb); //维护nextTick中的callback方法
    if(!waiting){
        timeFunc();
        waiting = true;
    }
}
</code></pre>
<p>将cb当到队列里，timeFunc()一般来说是用Promise,如果浏览器不支持就一步一步降级下去，以Promise为例：</p>
<pre><code class="language-js">let timeFunc;       //初始化文件时确定了该函数
if(Promise){
    timeFunc = ()=&gt;{
        Promise.resolve().then(flushCallbacks)
    }
</code></pre>
<p>flushCallbacks会执行callbacks队列里的每个刷新任务，timeFunc 选择执行flushCallbacks的策略， Promise保证了flushSchedulerQueue任务的顺序进行</p>
<pre><code>GPT
问: nextTick的功能是不是保证清空刷新任务的顺序执行?
是的，`nextTick` 的主要功能是在下一个事件循环中执行回调函数，它通常用于保证清空刷新任务的异步回调函数按照特定的顺序执行。在 Vue.js 和其他前端框架中，`nextTick` 通常用于以下几个方面：

1. 异步更新 DOM：在前端开发中，有些 DOM 操作可能需要在下一个事件循环中执行，以确保当前的渲染周期完成。例如，当你修改了数据并希望等待 Vue 更新 DOM 后再执行某些操作时，可以将这些操作放在 `nextTick` 的回调函数中。

2. 批量更新：有时候，多个操作需要触发 DOM 更新，但你希望将它们合并成一个批量更新，以提高性能。`nextTick` 可以用于将多个更新操作放在同一个事件循环中执行，而不是每次都触发更新。

3. 异步回调：如果你有一些需要在 DOM 更新后执行的异步回调函数，例如延迟加载图片或执行动画，`nextTick` 也可以派上用场。

`nextTick` 的具体实现方式可以根据环境的不同而有所不同。在现代浏览器环境中，通常会使用 `Promise`、`MutationObserver`、`setImmediate` 或 `setTimeout` 来实现异步回调。其主要目标是确保回调函数在下一个事件循环中执行，从而保证了 DOM 更新的一致性和可预测性。
</code></pre>
<h3>Mixin</h3>
<p>初始化时在Vue上增加一个方法initGlobalAPI，用于将用户的选项和全局的options进行合并</p>
<pre><code class="language-js">export function initGlobalAPI(Vue) {
  Vue.options = {};
  Vue.mixin = function (mixin) {
    // 我们希望将用户的选项和全局的options进行合并
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
</code></pre>
<p>mergeOptions作为一个方法，采用策略模式来避免if / else, </p>
<pre><code class="language-js">// 通过遍历，将选项合并
for (let key in parent) {
    mergeField(key);
  }
</code></pre>
<pre><code class="language-js">// 策略模式
// 静态方法
const strats = {};
const LIFECYCLE = [&quot;beforeCreate&quot;, &quot;created&quot;];
LIFECYCLE.forEach((hook) =&gt; {
  strats[hook] = function (p, c) {
    if (c) {
      if (p) {
        return p.concat(c);
      } else {
        return [c]; //儿子有父亲没有
      }
    } else {
      return p; //如果儿子没有则用父亲即可
    }
  };
});
function mergeField(key) {
    // 策略模式，目的是减少if / else
    if (strats[key]) {
        options[key] = strats[key](parent[key], child[key]);
    } else {
        // 如果不在策略中
        options[key] = child[key] || parent[key]; // 优先采用儿子
    }
}
</code></pre>
<p>parent的格式类似这样<code>{created: Array(2), a: 1}</code>数组里是函数</p>
<p>mergeField在Vue.prototype._init方法执行时，通过<code>vm.$options = mergeOptions(this.constructor.options, options); </code>将用户的选项和全局的options进行合并</p>
<p>在lifecycle.js中暴露了方法callHook,</p>
<pre><code class="language-js">export function callHook(vm, hook){ // 调用钩子函数
    const handlers = vm.$options[hook];
    console.log(&quot;handlers: &quot;,handlers);
    if(handlers){
        handlers.forEach((handler)=&gt;{
            handler.call(vm)
        })
    }
}
</code></pre>
<h3>数组更新原理</h3>
<p>目前还有一个问题，形如：</p>
<pre><code class="language-js">data() {
    return {
        name: &quot;随风&quot;,
        work: &quot;盗贼&quot;,
        tool: {
            &quot;超亮火把&quot;: 689,
            &quot;铁皮药剂&quot;: 30
        },
        arr: [&quot;FSX&quot;, &quot;TONE&quot;, &quot;DEAD&quot;, { &quot;JNTM&quot;: &quot;XHZ&quot; },[1,2]],
        a:{a:100}
    }
},
</code></pre>
<p>当我们更改arr[&quot;JNTM&quot;]时是可以监控的，但是当我们直接更改<code>arr = 500</code>是无法监控到的，原因是arr是没有自己的dep的，所以现在也要同样收集数组的依赖，在<strong>Observe</strong>里加上<strong>this.dep = new Dep();</strong></p>
<p>给所有对象也加上dep，接下来，在重新定义data里的属性时，收集数组的依赖**childDep.dep.depend();**但是不止于此，如果数组里面的子元素还有数组，这种写法是无法嵌套收集依赖的，所以判断value是数组后，使用dependArray嵌套收集依赖:</p>
<pre><code class="language-js">function dependArray(value){
    for(let i = 0;i&lt;value.length; i++){
        let current = value[i];
        current.__ob__ &amp;&amp; current.__ob__.dep.depend();
        if(Array.isArray(current)){
            dependArray(current)
        }
    }
}
</code></pre>
<p>至此，已经完成数组以及数组嵌套依赖的收集</p>
<h3>计算属性实现</h3>
<p>用户配置的计算属性位于<code>opts.computed</code>，如果其存在，则将vm传入<strong>initComputed</strong>,初始化计算属性，</p>
<p>在initComputed中</p>
<pre><code class="language-js">let computed = vm.$options.computed
// 将计算属性的getter保存到vm上,使在vm上可以访问到计算属性的watcher,方便访问
const watchers = vm._createComputedGetter = {} 
</code></pre>
<p>然后遍历<strong>computed</strong>，对于每个计算属性，都新建一个watcher与之对应，这里传入</p>
<pre><code class="language-js">watchers[key] = new Watcher(vm, fn, {lazy:true})
</code></pre>
<p><code>tips</code> ： <strong>{lazy:true}是不希望上来就执行fn 像一般的渲染watcher会直接执行get(),也就是渲染函数</strong></p>
<p> <strong>将属性和watcher对应起来</strong></p>
<p>所以watcher里调用get方法触发渲染函数的地方修改为</p>
<pre><code class="language-js">this.lazy ? 
    undefined : 
    this.get()  //意味着这个函数发生取值操作
</code></pre>
<p>，同时<strong>dirty</strong>是在访问计算属性时，确保只有第一次走初始化逻辑，避免重复操作，因此第一次取值后就更改为false,至此，只是初始化了计算属性的watcher，然后要做的是定义计算属性的get,set,这里只有get需要注意一下，也就是<strong>createComputedGetter</strong>:</p>
<pre><code class="language-js">function defineComputed(target, key, userDef){
    const setter = userDef.set || (() =&gt; {})
    Object.defineProperty(target,key, {
            get:createComputedGetter(key),
            set:setter
    })
}
</code></pre>
<p>createComputedGetter接收一个key,即具体计算属性的键值，返回一个函数，</p>
<p>**特别注意 ： **该函数初始化时并没有执行，只有渲染页面触发计算属性的get才会执行，</p>
<pre><code class="language-js">function createComputedGetter(key){
    // 监测是否要执行这个getter
    return function(){
        // 获取到对应的watcher
        const watcher = this._createComputedGetter[key]
        if(watcher.dirty){
            // 求值后dirty为true, 下次就不求了
            watcher.evaluate()
        }
        if(Dep.target){     //渲染watcher                       
            watcher.depend();   //计算属性出栈后，应该让计算属性watcher里面的watcher
            // 月收集上一层的watcher
        }
        return watcher.value
    }
}
</code></pre>
<p>页面渲染到计算属性时，触发其get时，<code>const watcher = this._createComputedGetter[key]</code>会直接定位到该计算属性对应的watcher,因为是第一次渲染(在之前初始化时，因为lazy为true,所以并没有触发渲染函数，也并没有修改lazy的值)，执行:</p>
<pre><code class="language-js">if(watcher.dirty){
    // 求值后dirty为true, 下次就不求了
    watcher.evaluate()
}
//这个watcher里的getter是: 
    this.getter = exprOrFn;//getter意味着这个函数可以发生取值操作
</code></pre>
<p>本章还做了一件事，之前dep.js新建了方法pushTarget，popTarget，</p>
<pre><code class="language-js">let stack = []
export function pushTarget(watcher){
    stack.push(watcher);
    Dep.target = watcher
}
export function popTarget(){
    stack.pop();
    Dep.target = stack[stack.length - 1]
</code></pre>
<p><strong><code>Dep.target</code>始终为栈结构的末尾元素，这样的结构可以层层收集watcher</strong></p>
<p>用于替换get中的<code>Dep.target = this;</code>和<code>Dep.target = null;</code>现在watcher里的get方法修改为</p>
<pre><code class="language-js">get(){
    // this:更新函数所在的那个watcher  类中的this都是实例 这里的this=&gt; Watcher
    // Dep.target = this;  //静态属性就是只有一份  实现计算属性时替换为pushTarget(this)
    pushTarget(this)
    let value = this.getter.call(this.vm);//会去vm上取值   
    // Dep.target = null;   //实现计算属性时替换为popTarget()
    popTarget()
    return value
}
</code></pre>
<p><code>getter是Watcher传入的fn,对于渲染watcher来说就是渲染函数，对于计算watcher来说就是配置的get</code>，这里实践中发现this.getter()会丢失this,所以通过call将vm绑定给他，这里的vm是新建watcher是传入的vm;同时将get,也就是getter，亦或说fn的执行结果返回并赋值给value,</p>
<p>watcher.evaluate()具体做的就是执行计算属性的get,得到value,并将dirty修改为false</p>
<p>至此，页面上的计算属性可以显示经过计算后的值，也就是get正常工作，<strong>但是set失效</strong>，形如下面的代码，定时器触发时是不会刷新页面的:</p>
<pre><code class="language-js">//HTML
{{funllName}}
//vm.options
const vm = new Vue({
            data() {
                return {
                    name: &quot;随风&quot;,
                    work: &quot;盗贼&quot;,
                    tool: {
                        &quot;超亮火把&quot;: 689,
                        &quot;铁皮药剂&quot;: 30
                    },
                    arr: [&quot;FSX&quot;, &quot;TONE&quot;, &quot;DEAD&quot;, { &quot;JNTM&quot;: &quot;XHZ&quot; },[1,2]],
                    a:{a:100}
                }
            },
            computed:{
                funllName:{
                    get(){
                        console.log(&quot;run&quot;);
                        return this.name + this.arr[1]
                    },
                    set(newValue){
                        console.log(newValue);
                        // return newValue
                    }
                }
            }
        })
//js
setTimeout(()=&gt;{
    console.log(&quot;111&quot;);
    vm.name = 123
},1000)
</code></pre>
<p>其实在控制台打印vm.funllName是可以看到已经更改为了<code>&#39;123TONE&#39;</code>,问题就出在没有相应的刷新逻辑</p>
<p>为什么，计算属性和用户data的重新定义不在一套逻辑里，计算属性是由<code>defineComputed</code>通过<code>defineProperty</code>定义的，但是因为计算属性收集的依赖只有计算watcher,</p>
<p><code>tips</code>:	<strong>执行<code>watcher.evaluate()</code>会使计算watcher进栈出栈，出栈后的末尾元素即为上层watcher,这里的就是渲染watcher</strong>,也就是说此时的<code>Dep.target</code>是渲染<strong>watcher</strong>，让此时的计算watcher去收集渲染watcher即可，其实说法有些不准确，准确的说法是: <strong>计算watcher不会收集依赖，只会让自己的属性去收集依赖</strong></p>
<pre><code class="language-js">//将渲染watcher加入
if(Dep.target){     //渲染watcher                       
    watcher.depend();    //计算属性出栈后，应该让计算属性watcher里面的属性也去收集上层watcher
    // 收集上一层的watcher
}
</code></pre>
<p>watcher里的depend()会使计算属性也收集渲染watcher</p>
<pre><code class="language-js">depend(){
    let i = this.deps.length;
    while(i--){
        // this.deps[i]是Dep
        this.deps[i].depend()   //让计算属性watcher也收集渲染watcher
    }
}
</code></pre>
<p>计算属性不会收集依赖，只会让自己的属性去收集依赖</p>
<p><code>个人理解</code>	：watcher.depend(); 的watcher是计算watcher,其中的depend()方法的</p>
<p><code> while(i--){this.deps[i].depend()}</code>的目的是让计算属性watcher也收集渲染watcher，这里的deps[i]是Dep,代表的计算属性watcher所依赖的属性，Dep调用depend()方法，执行<code>Dep.target.addDep(this)</code>,这里的Dep.target应该是渲染watcher,且是计算属性watcher外层的渲染watcher, this是Dep,</p>
<p><code>疑问</code>:   既然this.deps[i]是Dep，那么就代表了一个属性，this.deps[i].depend()是不是建立计算watcher和渲染watcher的联系</p>
<p>Dep里的let stack = []，存放的是不是当前属性所依赖的watcher</p>
<h3>watch的实现</h3>
<p>watch的实现比较简单，和computed的实现一样，底层其实都是基于<strong>Watcher</strong></p>
<p>首先watch有三种写法</p>
<pre><code class="language-js">watch:{
    // 写法1: 直接写一个函数
    worker(newValue, oldValue){
        console.log(&quot;写法1-newValue: &quot;,newValue);
        console.log(&quot;写法1-oldValue: &quot;,oldValue);
    }
    // &#39;worker&#39;:(newValue, oldValue)=&gt;{
    //     console.log(&quot;写法1-newValue: &quot;,newValue);
    //     console.log(&quot;写法1-oldValue: &quot;,oldValue);
    // }
    // 写法2: 数组
    // worker: [                    
    //     (newValue, oldValue) =&gt; {
    //         console.log(&quot;newValue: &quot;,newValue);
    //     },
    //     (newValue, oldValue) =&gt; {
    //         console.log(&quot;newValue: &quot;,newValue);
    //     }
    // ]
}

// watch写法3: $watch
// 底层其实调用的就是$watch的方法，即使方法1或者方法2，最终都是调用$watch
vm.$watch(
    () =&gt; vm.worker,
    // function exprOrFn(){return vm.worker},
    // &#39;worker&#39;,    // 或者写成这样            
    function cb(newValue, oldValue){
        console.log(&quot;$watch-newValue: &quot;,newValue);
        console.log(&quot;$watch-oldValue: &quot;,oldValue);
    })
</code></pre>
<p>虽然底层最终都是用$watch实现的，但是要写判断逻辑来对应上</p>
<p><strong>initState</strong>中，在完成<strong>data</strong>和<strong>computed</strong>的初始化后，再判断用户是否配置了watch，初始化watch，逻辑比较简单，判断是数组写法，还是字符串，最终都是用$watch实现</p>
<pre><code class="language-js">function initWatch(vm){
    let watch = vm.$options.watch
    for(let key in watch){
        const handler = watch[key]; //字符串 数组 函数
        if(Array.isArray(handler)){
            for(let i=0; i&lt; handler.length; i++){
                createWatcher(vm, key, handler[i])
            }
        }else{
            createWatcher(vm, key, handler)
        }
    }
}
function createWatcher(vm, key, handler){
    // 字符串 函数
    if(typeof handler === &#39;string&#39;){//考虑methods里的方法
        handler = vm[handler];
    }
    return vm.$watch(key, handler)
}
</code></pre>
<p>因此，需要在<code>Vue.prototype</code>上新增<code>$watch</code>方法，</p>
<pre><code class="language-js">Vue.prototype.$watch = function(exprOrFn, cb, options = {}){
    new Watcher(this, exprOrFn, {user: true}, cb)	//user: true表示是用户自己的watcher
}
</code></pre>
<p>exprOrFn就是key,也就是监视的属性，是一个字符串，所以要做个判断以区别渲染watcher的渲染函数，</p>
<pre><code class="language-js">if(typeof exprOrFn === &#39;string&#39;){
    this.getter = function(){
        return vm[exprOrFn]
    }
}else{
    this.getter = exprOrFn;//getter意味着这个函数可以发生取值操作
}
</code></pre>
<p>字符串则<code>this.getter</code>返回值会直接去取vm上对应的属性，否则exprOrFn就是个渲染函数，直接将<code>exprOrFn</code>赋给<code>this.getter</code></p>
<p>更新的<code>run方法也要重写</code></p>
<pre><code class="language-js">//旧run方法
run(){
    this.get()
}
//新run
run(){
    let oldValue = this.value;
    let newValue = this.get();
    if(this.user){
        this.cb.call(this.vm, newValue, oldValue)
    }
}
</code></pre>
<h3>diff算法</h3>
<p>patch(oldVNode, vnode)，是用来更新dom的，初渲染流程用不到diff算法，判断一下oldVNode是不是真实dom,如果是，就代表是初渲染流程，就执行</p>
<pre><code class="language-js">if(isRealELement){
        const elm = oldVNode;
        const parentElm = elm.parentNode;
        // console.log(parentElm, vnode);
        let newElm = createElm(vnode);
        parentElm.insertBefore(newElm, elm.nextSibling);
        parentElm.removeChild(elm);

        return newElm
</code></pre>
<p>这代表了直接把原真实dom删除，由以真实dom生成的ast语法树经过模板编译后生成的真实dom替代，</p>
<p><strong>否则进行diff算法对比虚拟dom：</strong>
先<code>isSameVnode</code>判断新旧是否一样，比较的是<code>vnode1.tag === vnode2.tag &amp;&amp; vnode1.key === vnode2.key</code>不是一个虚拟dom则直接替换，否则说明外层容器是同一个虚拟节点, 然后对比文本，先复用老的文本，如果新旧文本不一，则用新的，然后通过<code>patchProps</code>处理样式，新有旧无，新无旧有等情况，接下来就是对比儿子节点，当双方儿子数都不为0<code>updateChildren</code>更新孩子，或者新的大于0且旧的为0直接加入，或者旧的大于0且新的为0直接删除，之后<code>updateChildren</code>对比过程中使用多种策略进行提速，</p>
<p>头头对比 尾尾对比 交叉对比  乱序对比</p>
<p>添加方法获得每个孩子的唯一key:  这里用了<code>while</code>循环处理</p>
<pre><code class="language-js">//处理因为索引表导致当前索引对应的旧节点出现undefined，需要跳过的情况
function makeIndexByKey(children){
    let map = {}
    children.forEach((child, index)=&gt;{
        map[child.key] = index
    })
    return map
}
let map = makeIndexByKey(oldChildren)
</code></pre>
<p>除了乱序对比，其他不赘述了，乱序对比：</p>
<pre><code class="language-js">// 乱序比对
let moveIndex = map[newStartVnode.key];
//判断老节点的孩子中是否有key为newStartVnode.key的child
if(moveIndex !== undefined){
    let moveVnode = oldChildren[moveIndex];//有就找到对应的虚拟儿子节点
    //直接将该孩子插入老节点的第一位，因为取的是新虚拟节点拍在第一位的节点
    el.insertBefore(moveVnode.el, oldStartVnode.el);
    //将该孩子原位置设为undefined，表示这个节点已经移走了，key正是为了这种情况创立的
    oldChildren[moveIndex] = undefined;
    patchVnode(moveVnode, newStartVnode);//比较属性和子节点
}else{
    //表示老节点的孩子中没有key为newStartVnode.key的child，那么直接创建一个并且插入到旧虚拟节点的第一位
    el.insertBefore(createElm(newStartVnode), oldStartVnode.el);
}
newStartVnode = newChildren[++newStartIndex]
</code></pre>
<p> 经过之上的while循环之后，无非就剩下了两种情况：</p>
<p>1&gt; 要么新节点还有多的，</p>
<p>2&gt; 或者旧结点有多余的</p>
<p>根目录index.js测试代码:</p>
<pre><code class="language-js">let render1 = compileToFunction(`&lt;ul a=&quot;1&quot; key=&quot;a&quot; style=&quot;color:#0000ff;background-color: #ff0000&quot;&gt;    
&lt;li key=&quot;a&quot;&gt;1&lt;/li&gt;
&lt;li key=&quot;b&quot;&gt;2&lt;/li&gt;
&lt;li key=&quot;c&quot;&gt;3&lt;/li&gt;  
&lt;li key=&quot;d&quot;&gt;4&lt;/li&gt;    
&lt;/ul&gt;`);
let vm1 = new Vue({data:{name:&#39;第一次&#39;}});
let preVnode = render1.call(vm1)

let el = createElm(preVnode);
document.body.appendChild(el)

// let render2 = compileToFunction(&#39;&lt;span&gt;{{name}}&lt;/span&gt;&#39;);
let render2 = compileToFunction(`&lt;ul a=&quot;1&quot; key=&quot;a&quot; style=&quot;color:#0000ff;background-color: #00ff00&quot;&gt;
&lt;li key=&quot;b&quot;&gt;2&lt;/li&gt;
&lt;li key=&quot;m&quot;&gt;5&lt;/li&gt;
&lt;li key=&quot;a&quot;&gt;1&lt;/li&gt;
&lt;li key=&quot;p&quot;&gt;6&lt;/li&gt;
&lt;li key=&quot;c&quot;&gt;3&lt;/li&gt;  
&lt;li key=&quot;q&quot;&gt;7&lt;/li&gt;        
&lt;/ul&gt;`);
let vm2 = new Vue({data:{name:&#39;第二次&#39;}});
let nextVnode = render2.call(vm2)
// console.log(nextVnode);

setTimeout(()=&gt;{    
    patch(preVnode, nextVnode)
}, 1000)
</code></pre>
<p>在initLifeCycle里的_updata:</p>
<pre><code class="language-js">const vm = this;
const el = vm.$el;
let elm = patch(el, vnode);
vm.$el = elm
</code></pre>
<p>这些逻辑被封装到了updataComponent，在实例化watcher是就会调用，也就是说页面加载时即执行</p>
<p><code>tips</code>:	P17代码敲完后，有个地方似乎有问题,initLifeCycle里的_updata里：
    <code>let elm = patch(el, vnode);</code>中，patch始终返回的是真实dom,也就是<code>const el = vm.$el;</code>也是个真实dom, 那么会导致始终是走的初渲染流程，因为<code>patch(oldVNode, vnode)</code>的oldVNode始终是真实dom</p>
<p>因此修改为：</p>
<pre><code class="language-js">Vue.prototype._updata = function(vnode){
    const vm = this;
    const el = vm.$el;

    const preVnode = vm._vnode;
    vm._vnode = vnode;//组件第一次的渲染的虚拟节点保存到_vnode上

    if(preVnode){//之前渲染过了
        vm.$el = patch(preVnode, vnode)
    }else{
        vm.$el = patch(el, vnode)
    }
}
</code></pre>
<h3>组件的虚拟节点</h3>
<p>自定义组件的写法：</p>
<pre><code class="language-js">// 1&gt;
const vm = new Vue({
    data() {
        return {
            name: &quot;随风&quot;,
            work: &quot;盗贼&quot;,
            worker: &quot;self&quot;,
            tool: {
                &quot;超亮火把&quot;: 689,
                &quot;铁皮药剂&quot;: 30
            },
            arr: [&quot;FSX&quot;, &quot;TONE&quot;, &quot;DEAD&quot;, { &quot;JNTM&quot;: &quot;XHZ&quot; },[1,2]],
            a:{a:100}
        }
    },
    components:{ //js原型链 自己没有再向外找
        &quot;my-button&quot;: Vue.extend({
            template: &#39;&lt;button&gt;内部&lt;/button&gt;&#39;
        })
    }
})
// 2&gt;
Vue.component(&quot;my-button&quot;,{
    template: &#39;&lt;button&gt;全局button&lt;/button&gt;&#39;
})
// or
Vue.component(&quot;my-button&quot;, Sub)
// 3&gt;
let Sub = Vue.extend({
    template: &quot;&lt;button&gt;子组件&lt;my-button&gt;&lt;/my-button&gt;&lt;/button&gt;&quot;,
    components: {&quot;my-button&quot;: {
        template: &#39;&lt;button&gt;子组件自己生命的button&lt;/button&gt;&#39;
    }}
})
new Sub().$mount(&#39;#root&#39;)
</code></pre>
<p>其实最终调用的都是<code>Vue.extend</code>, <code>initGlobalAPI</code>新增方法<code>Vue.extend</code>和配置</p>
<pre><code class="language-js"> Vue.options = {
    _base: Vue
  };
</code></pre>
<pre><code class="language-js">Vue.extend = function(options){
    // 就是实现根据用户的参数，返回一个构造函数而已
    function Sub(options = {}){ //最终使用一个组件，就是new一个实例
        this._init(options);  //就是默认对子类进行初始化操作
    }
    Sub.prototype = Object.create(Vue.prototype); //Sub.prototype._proto_ === Vue.prototype
    Sub.prototype.constructor = Sub;
    // 将用户传递的选项的参数和全局的合并
    Sub.options = mergeOptions(Vue.options, options);  //保存用户传递的选项
    // debugger
    return Sub
}
</code></pre>
<p>其实就是返回了一个类，上拥有Vue的方法，以方便后面的组件虚拟节点化，并且在这个过程，合并了全局和用户的选项，主要是处理component,全局组件和自定义组件的优先级是自定义更高，所以<code>mergeOptions</code>稍加修改</p>
<pre><code class="language-js">//添加
strats.components = function(parentVal, childVal){
  const res = Object.create(parentVal);
  
  if(childVal){
    for(let key in childVal){      
      // 返回的是构造的对象 可以拿到富强原型上的属性，并且将儿子的都拷贝到自己身上
      res[key] = childVal[key];
    }
  }

  return res;
}
</code></pre>
<p><code>childVal 和 parentVal</code>的形式是这样的：</p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231101105451226.png" alt="image-20231101105451226"></p>
<pre><code class="language-js">// 这段代码执行完Sub.prototype.constructor就是Vue了，所以要手动纠正
Sub.prototype = Object.create(Vue.prototype); //Sub.prototype._proto_ === Vue.prototype
//添加
Sub.prototype.constructor = Sub;
</code></pre>
<p><code>Sub.prototype.constructor如果变成Vue</code>会导致</p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231101110630431.png" alt="image-20231101110630431"></p>
<pre><code class="language-js">Vue.prototype._init = function(options){
    const vm = this;
    // 用户数据挂载到实例上  并合并
    vm.$options = mergeOptions(this.constructor.options, options); 

    callHook(vm, &#39;beforeCreate&#39;)
    // 初始状态
    initState(vm);
    callHook(vm, &#39;created&#39;)

    if(options.el){
        vm.$mount(options.el)
    }
}
</code></pre>
<p>没有el,所以不走$mount,后面自己会手动调用</p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231226155745114.png" alt="image-20231226155745114"></p>
<p>对于全局组件</p>
<pre><code class="language-js">  Vue.options.components = {}; //全局的指令
  Vue.component = function(id, definition){
    // 如果definition已经是一个函数了，说明用户自己调用了Vue.extend
    definition = typeof definition === &#39;function&#39; ? definition : Vue.extend(definition);
    Vue.options.components[id] = definition
  }
</code></pre>
<p>在模板编译也要新增对应的组件的相关配置</p>
<p>通过</p>
<pre><code class="language-js">const isReservedTag = (tag) =&gt; {
    return [&#39;a&#39;, &#39;div&#39;, &#39;p&#39;, &#39;button&#39;, &#39;ul&#39;, &#39;li&#39;, &#39;span&#39;].includes(tag)
}
</code></pre>
<p>判断当前的标签是否是组件</p>
<p>并在<code>createElementVNode(vm,tag, data, ...children)</code>新增</p>
<pre><code class="language-js">if(isReservedTag(tag)){        
    return vnode(vm,tag,key,data,children)
}else{
    let Ctor = vm.$options.components[tag];  // 对应的Sub函数
    return createComponentVnode(vm, tag, key, data, children, Ctor)
}
</code></pre>
<p><code>Ctor</code> ： 其实就是模板</p>
<pre><code class="language-js">function createComponentVnode(vm, tag, key, data, children, Ctor){    
    // console.log(vm.$options._base); //拿到Vue       
    if(typeof Ctor === &#39;object&#39;){
        //如果Ctor是个对象就要给转成一个类
        Ctor = vm.$options._base.extend(Ctor);
    } 
    data.hook = {
        init(vnode){
            let instance = vnode.componentInstance = new vnode.componentOptions.Ctor
            instance.$mount();
        }
    }
    return vnode(vm,tag,key,data,children,null, {Ctor})
}
</code></pre>
<p><code>如果Ctor是个对象就要给转成一个类</code></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231101112152681.png" alt="image-20231101112152681"></p>
<p><code>init方法</code>   <code>new vnode.componentOptions.Ctor</code> 先实例化一个Sub再赋值给</p>
<p><code>instance</code> 和 <code>vnode.componentInstance</code>并且<code>instance.$mount();</code>将组件的虚拟节点转为了真实DOM</p>
<pre><code class="language-js">data.hook = {
    init(vnode){
        let instance = vnode.componentInstance = new vnode.componentOptions.Ctor
        instance.$mount();
    }
}
</code></pre>
<p><code>$mount</code>会调用<code>patch</code>，但是组件的挂载没有el,也就是$el,这两个是一个东西，也就是<code>patch(oldVNode, vnode)</code>没有oldVNode，没有oldVNode就说明是组件的挂载，<code>patch(oldVNode, vnode)</code>最开始添加逻辑</p>
<pre><code class="language-js">if(!oldVNode){ // 这就是组件的挂载        
    return createElm(vnode); // vm.$el  对应的就是组件渲染的结果了
}
</code></pre>
<p><code>createElm(vnode)</code>稍加修改</p>
<pre><code class="language-js">if(typeof tag === &#39;string&#39;){    //标签
    // 创建真实元素，也要区分是组件还是元素
    //《=新增
    if(createComponent(vnode)){ // 组件 vnode.componentInstance.$el
        return vnode.componentInstance.$el;
    }
    //新增=》
    vnode.el = document.createElement(tag); //这里将真实节点和虚拟节点对应起来，后续如果修改属性
    patchProps(vnode.el, {}, data)
    children.forEach((child) =&gt; {
        // console.log(vnode);
        vnode.el.appendChild(createElm(child))  //递归，不断地向vnode.el里添加html元素
    })        
}
</code></pre>
<p><code>createComponent</code>:</p>
<pre><code class="language-js">function createComponent(vnode){
    let i = vnode.data;
    if((i = i.hook) &amp;&amp; (i = i.init)){
        i(vnode); // 初始化组件 ， 找到init方法
    }
    if(vnode.componentInstance){
        return true; // 说明是组件
    }
}
</code></pre>
<p><code>vnode.componentInstance.$el</code>  其实就是一个真实节点</p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231101114634397.png" alt="image-20231101114634397"></p>
<h3>Vue v2.6.14版本源码相关</h3>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231101192005449.png" alt="image-20231101192005449"></p>
<h2>开发环境搭建</h2>
<pre><code>pnpm i rollup

pnpm i rollup rollup-plugin-babel @babel/core @babel/preset-env --save-dev
</code></pre>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;rollup -cw&quot;
  },
</code></pre>
<h3>打包基本结构</h3>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20230911102804474.png" alt="image-20230911102804474"></p>
<p><strong>在global上加上一个Vue的配置对象，global.Vue也就是exports,将exports传给factory,将我们的导出的内容加在expoers的属性上</strong></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20230916153212247.png" alt="image-20230916153212247"></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231009194117212.png" alt="image-20231009194117212"></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231009212009492.png" alt="image-20231009212009492"></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231018200048847.png" alt="image-20231018200048847"></p>
<h3>珠峰源码Vue2分析</h3>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231212220436025.png" alt="image-20231212220436025"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214195656511.png" alt="image-20231214195656511"></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231212220551284.png" alt="image-20231212220551284"></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214195158335.png" alt="image-20231214195158335"></p>
<p>sources map</p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214195636785.png" alt="image-20231214195636785"></p>
<p>有错误</p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214195509890.png" alt="image-20231214195509890"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214203345398.png" alt="image-20231214203345398"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214203914860.png" alt="image-20231214203914860"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214210536410.png" alt="image-20231214210536410">取值的时候更新依赖，设值的时候更新视图<img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214211707481.png" alt="image-20231214211707481"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214212002413.png" alt="image-20231214212002413"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214213644254.png" alt="image-20231214213644254"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214213815881.png" alt="image-20231214213815881"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214214955579.png" alt="image-20231214214955579"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231226145847027.png" alt="image-20231226145847027"></p>
<p>data写成对象式，那么在c1改变a的之后，c2也会受到影响，改为函数式后每次new Child都会返回新的对象，而不会互相影响</p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214215030875.png" alt="image-20231214215030875"> <img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231223151504495.png" alt="image-20231223151504495"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231226151302116.png" alt="image-20231226151302116"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231226161507441.png" alt="image-20231226161507441"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231226161526083.png" alt="image-20231226161526083"> <img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231226161952824.png" alt="image-20231226161952824"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231226163313735.png" alt="image-20231226163313735"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231226163710742.png" alt="image-20231226163710742"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231226164115773.png" alt="image-20231226164115773"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231226194128342.png" alt="image-20231226194128342"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231226201450585.png" alt="image-20231226201450585"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231226202304710.png" alt="image-20231226202304710"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231226210710500.png" alt="image-20231226210710500"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231228151605765.png" alt="image-20231228151605765"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231226210649117.png" alt="image-20231226210649117">Vue的methods处理事件的时候会绑定this<img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231228152934948.png" alt="image-20231228152934948"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231228152942972.png" alt="image-20231228152942972"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231228184432927.png" alt="image-20231228184432927"></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231228185300022.png" alt="image-20231228185300022"></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231228185758257.png" alt="image-20231228185758257"></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214203639972.png" alt="image-20231214203639972"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214210423280.png" alt="image-20231214210423280"></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214210611265.png" alt="image-20231214210611265"></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214204357473.png" alt="image-20231214204357473"></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231214210827082.png" alt="image-20231214210827082"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231223151125162.png" alt="image-20231223151125162"></p>
<p>nexttick不会立刻执行，放到队列里顺序执行<img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231223151314303.png" alt="image-20231223151314303"></p>
<h1>尚品汇-前台项目--基于Vue2</h1>
<pre><code>1:尚品汇源码Gitee地址
https://gitee.com/jch1011/shangpinhui_0415.git
2：后台管理系统源码Gitee地址
https://gitee.com/jch1011/guigu.git
</code></pre>
<ul>
<li>仓库中复杂数据的读取使用getters简化，注意异步请求数据数据为undefined的问题，  解决： || []<ul>
<li>对用户的输入格外的小心，必须在传输据前对用户的数据进行校验-- <strong>数据格式是否合法</strong> <strong>数据范围是否合法</strong> <strong>数据如果不合适要适当纠正，比如需要整数，用户输入带小数的数据，就要用parseInt</strong></li>
<li>一定要注意在发请求时，后端需要的数据格式，比如购物车页面的isCheck</li>
<li>注意 <strong>return</strong> 的问题</li>
</ul>
</li>
</ul>
<h2>路由跳转与传参相关问题</h2>
<pre><code class="language-js">gosearch() {
    // (1)路由传参
    this.$router.push(&#39;/search/&#39; + this.keyword +
                      &quot;?k=&quot; + this.keyword.toUpperCase())
    // (2)模板字符串 路由传参  ``用Tab上面的键打出来
    this.$router.push(`search/${this.keyword}?k=${this.keyword.toUpperCase()}`)
    // 面试题：：：解决对于params参数可传可不传时路径异常（search路径丢失）的问题，
    this.$router.push({name:&quot;search&quot;,params:{keyword:&quot;&quot; || undefined},query:{k:this.keyword.toUpperCase()}})
    // 面试题------params不可以和path一起使用
    this.$router.push({path:&#39;/search&#39;,params:{keyword:this.keyword},
                       query:{k:this.keyword.toUpperCase()}})
    // 路由可不以传递props参数--------可以，但是只可以传递props参数
    // (3)对象传参------常用
    // this.$router.query即使没有也是个{}，可以执行if内的语句
    if (this.$route.query) {
        //判断是否有query参数，将query参数和params都push过去
        let location = {
            name: &quot;search&quot;,
            params: { keyword: this.keyword || undefined },
        };
        location.query = this.$route.query;
        this.$router.push(location);
    }
},
</code></pre>
<ol>
<li><p>跳转路由的 2 种基本方式
 声明式: <router-link to="">
 编程式: <strong>this.$router.push()/replace()</strong></p>
</li>
<li><p>跳转路由携带参数的 2 种方式
 <strong>params</strong> 参数
 <strong>query</strong> 参数</p>
</li>
<li><p>面试问题 1: 
 描述: 编程式路由跳转到当前路由(参数不变), 会抛出 <strong>NavigationDuplicated</strong> 的警告错误
 解决 1: 在跳转时指定成功或失败的回调函数, 通过 catch 处理错误
 解决 2: 修正 Vue 原型上的 push 和 replace 方法 (优秀)</p>
</li>
<li><p>面试问题 2: 如何指定 params 参数可传可不传? 
 <strong>path: &#39;/search/:keyword?&#39;</strong>  加问号即可</p>
</li>
<li><p>面试问题 3: 指定 params 参数时可不可以用 path 和 params 配置的组合?
 不可以用 path 和 params 配置的组合, 只能用 name 和 params 配置的组合
 query 配置可以与 path 或 name 进行组合使用</p>
</li>
<li><p>面试问题 4: 如果指定 name 与 params 配置, 但 params 中数据是一个&quot;&quot;, 无法跳转
 解决 1: 不指定 params
 解决 2: 指定 params 参数值为 undefined</p>
<pre><code class="language-js">params: { keyword: this.keyword || undefined },
</code></pre>
</li>
<li><p>面试问题 5: 路由组件能不能传递 props 数据?
 可以: 可以将 query 或且 params 参数映射/转换成 props 传递给路由组件对象
 实现: props: (route)=&gt;({keyword1:route.params.keyword, keyword2: route.query.keyword })</p>
</li>
</ol>
<h3>路由元信息</h3>
<p>路由元信息来控制footer的显示与否</p>
<pre><code class="language-js">{
    name:&quot;search&quot;,
    path:&quot;/search/:keyword?&quot;,    //加上？,则params参数可传可不传
    component:Search,
    meta:{show:true},
    //路由可不以传递props参数?
    // props:true,
    //还可以用props:{a:1,b:2}的形式给组件传递信息
    //不过最常用的是函数形式
    props:($route)=&gt;{
        return {keyword:$route.params.keyword,k:$route.query.k};
    }
},
</code></pre>
<h3>解决路由跳转时的 NavigationDuplicated 错误</h3>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231204203607251.png" alt="image-20231204203607251"></p>
<p><strong>问题</strong>:  编程式路由跳转到当前路径且参数没有变化时会抛出 NavigationDuplicated 错误 </p>
<p><strong>原因分析</strong>:  vue-router3.1.0之后, 引入了push()的promise的语法, 如果没有通过参数指定回调函数就返回一个 promise 来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数 都没有变化, 会抛出一个失败的 promise</p>
<pre><code class="language-js">//1) 问题:编程式路由跳转到当前路径且参数没有变化时会抛出 NavigationDuplicated 错误
//2) 原因分析:vue-router3.1.0之后, 引入了push()的promise的语法, 如果没有通过参数指定回调
//函数就返回一个 promise 来指定成功/失败的回调, 且内部会判断如果要跳转的路径和参数
//都没有变化, 会抛出一个失败的 promise

// 缓存原型上的 push 函数
const originPush = VueRouter.prototype.push
const originReplace = VueRouter.prototype.replace
// 给原型对象上的 push 指定新函数函数
VueRouter.prototype.push = function (location, onComplete, onAbort) {
 // 判断如果没有指定回调函数, 通过 call 调用源函数并使用 catch 来处理错误
 if (onComplete===undefined &amp;&amp; onAbort===undefined) {
 return originPush.call(this, location, onComplete, onAbort).catch(() =&gt; {})
 } else { // 如果有指定任意回调函数, 通过 call 调用源 push 函数处理
 originPush.call(this, location, onComplete, onAbort)
 }
}
VueRouter.prototype.replace = function (location, onComplete, onAbort) {
 if (onComplete===undefined &amp;&amp; onAbort===undefined) {
 return originReplace.call(this, location, onComplete, onAbort).catch(() =&gt;
{})
 } else {
 originReplace.call(this, location, onComplete, onAbort)
 }
}
</code></pre>
<p>其实就是判断用户有没有制定Promise失败或者成功回调，没有我给他补上</p>
<h3>路由鉴权</h3>
<ul>
<li>全局路由守卫</li>
<li>独享路由守卫</li>
<li>组件路由守卫</li>
</ul>
<h2>二次封装Axios</h2>
<p>一般来说，在项目中/api文件夹下，有个文件专门用于二次封装Axios。还有一个文件。一般来说是<code>index.js</code>，用于统一管理接口api,所有的请求操作都放在该文件夹</p>
<p>可以搭配<code>nProgress</code>使用，注意引入<strong>nProgress</strong>的样式，该样式是可以修改的</p>
<pre><code class="language-js">//对axios二次封装
import axios from &quot;axios&quot;;
import nProgress from &quot;nprogress&quot;;
import &quot;nprogress/nprogress.css&quot;;

const requests = axios.create({
    baseURL:&quot;/api&quot;,
    timeout:5000,
    // data:{GameName:&quot;随风&quot;}
});

requests.interceptors.request.use((config)=&gt;{
    nProgress.start();
    return config;
});

requests.interceptors.response.use((res)=&gt;{
    nProgress.done();
    return res.data;
},(error)=&gt;{
    return Promise.reject(new Error(&#39;falie&#39;));
});

export default requests;
</code></pre>
<h2>Vue的配置代理</h2>
<p>jsonp  cros  代理跨域</p>
<p><code>vue.config.js</code></p>
<pre><code class="language-js">devServer: {
    proxy: {
        &#39;/api&#39;: { // 只对请求路由以/api 开头的请求进行代理转发
            target: &#39;http://182.92.128.115&#39;, // 转发的目标 url
            changeOrigin: true // 支持跨域
        }
    }
},
</code></pre>
<h2>使用Vuex模块化开发</h2>
<p>各个模块其实就主要：</p>
<pre><code class="language-js">export default {
    state,
    mutations,
    actions,
    getters
};
</code></pre>
<p>也不涉及什么Api</p>
<ul>
<li>state的数据初始格式注意和后端返回的数据保持统一</li>
<li>actions不进行数据的更改，但是可以进行异步操作，向后端请求数据，通过<code>this.commit(&#39;GETSEARCHLIST&#39;,result.data)</code>通知mutations</li>
<li>mutations负责更改state</li>
<li>getters简化数据的读取</li>
</ul>
<p>疑惑</p>
<pre><code class="language-js">const actions = {
    async getSearchList({commit},params){
        let result = await reqGetSearchInfo(params);
        if(result.code == 200){
            this.commit(&#39;GETSEARCHLIST&#39;,result.data);
        }
    }
};
</code></pre>
<p><strong>原因</strong>：
在Vue.js的<code>actions</code>中，<code>{commit}</code> 是通过ES6的解构赋值语法从<code>context</code>中提取<code>commit</code>方法。<code>context</code>是一个包含了<code>commit</code>、<code>dispatch</code>等方法的对象，但你可以只提取你需要的方法，这样可以简化代码并提高可读性。</p>
<p>在你的例子中，<code>getSearchList</code>是一个异步action，<code>commit</code>是用于触发mutation的方法。通过解构赋值，你直接从<code>context</code>中提取了<code>commit</code>方法，而不需要使用<code>context.commit</code>。</p>
<p>所以，这个写法是为了方便在<code>getSearchList</code>中直接调用<code>commit</code>方法，而不需要每次都写<code>context.commit</code>。这样的写法更为简洁，也更容易理解和维护。</p>
<p>在<code>./store/indedx.js</code>文件中引入时。模块化开发就只需要由<strong>modules</strong></p>
<pre><code class="language-js">import Vue from &#39;vue&#39;;
import Vuex from &#39;vuex&#39;;

Vue.use(Vuex);

import home from &#39;./home&#39;;
import search from &#39;./search&#39;;
import terraria from &#39;./terraria&#39;;
export default new Vuex.Store({
    modules:{
        home,
        search,
        terraria
    }
})
</code></pre>
<h3>命名空间namespace的作用及好处</h3>
<h2>home页搭建</h2>
<h3>整体结构</h3>
<ul>
<li>TypeNav: 3 级分类导航</li>
<li>ListContainer: 包含轮播列表的容器</li>
<li>TodayRecommend: 今日推荐</li>
<li>Rank: 排行</li>
<li>Like: 猜你喜欢</li>
<li>Floor: 楼层</li>
<li>Brand: 品牌</li>
</ul>
<h3>TypeNav</h3>
<p>重难点说明</p>
<ol>
<li>组件与 vuex 交互</li>
<li>事件控制二三级分类列表的显示与隐藏</li>
<li>优化高频事件触发处理: 利用 lodash 进行函数节流处理</li>
<li>优化减小打包文件: 对 lodash 库实现按需引入</li>
<li>解决快速移出后可能显示第一个分类的子分类列表的 bug</li>
<li>优化减少组件对象数量: 使用编程式导航代替声明式导航</li>
<li>优化事件处理效率: 利用<strong>事件委托</strong></li>
<li>利用标签自定义属性携带动态数据</li>
<li>控制一级列表的显示与隐藏</li>
<li>一级列表显示隐藏的过渡效果</li>
<li>优化请求执行的位置, 减少请求次数</li>
<li>合并分类 query 参数与搜索的关键字 params 参数</li>
</ol>
<p>mapState读取仓库state</p>
<pre><code class="language-js">computed: {
    ...mapState({
        categoryList: (state) =&gt; {
            return state.home.categoryList;
        },
    }),
},
</code></pre>
<p><code>tips</code>	读取getter:    <code>$store.getters.bigSum</code></p>
<h4>事件控制二三级分类列表的显示与隐藏</h4>
<p>​	+事件委派</p>
<p>​	+节流防抖</p>
<p>​	+合并路由参数</p>
<p>​	+Vue过渡及动画</p>
<p>因为这是一个三级列表，借助<code>v-for</code>实现，所以在一级分类标签中引入mouseenter，在该事件中同步<strong>currentIndex</strong>，该值的初始值为index取不到的数即可，通过<code>:class=&quot;{ cur: currentIndex == index }&quot;</code>控制鼠标移入的高亮，同时二三级分类列表的显示与隐藏也是通过该属性实现的：<code>:style=&quot;{ display: currentIndex == index ? &#39;block&#39; : &#39;none&#39; }&quot;</code></p>
<p>上述实现了显示，对于隐藏，使用mouseleave，将<strong>currentIndex</strong>置为index取不到的数即可，但是因为业务的关系，这里需要用到事件委派，将该操作交给其父元素</p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231205115046552.png" alt="image-20231205115046552"></p>
<p>但是这里目前的问题是，有时候用户操作太快，就不是很好，所以需要加上节流防抖</p>
<ul>
<li>节流 规定时间只触发一次</li>
<li>防抖 频繁触发只会触一次，前面的都会取消</li>
</ul>
<p>使用<strong>lodash</strong></p>
<pre><code class="language-js">import throttle from &quot;lodash/throttle.js&quot;;

// 这里使用ES的写法
changeIndex: throttle(function (index) {
    this.currentIndex = index;
}, 50),
</code></pre>
<h4>三级分类列表的路由跳转方式</h4>
<p>对于这个问题，可以对每个a标签使用<router-link>来完成该逻辑，但是<router-link>作为一个组件，这代表着将要在页面上挂载成百上千个Vue实例对象，这肯定会造成很大的负载，所以这里采取事件委派+编程式路由导航+自定义属性完成业务</p>
<p>给与一级列表父容器点击事件，这里使用<strong>HTMLElement.dataset</strong>，同时赋予一二三级分类标签自定义属性<code>category1id, category2id, category3id</code></p>
<p><strong>关于dataset</strong></p>
<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement"><code>HTMLElement</code></a> 接口的只读属性 <strong><code>dataset</code></strong> 提供了对元素上<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/data-*">自定义数据属性</a>（<code>data-*</code>）读/写访问。它暴露了一个字符串映射（<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMStringMap"><code>DOMStringMap</code></a>），其中包含每个 <code>data-*</code> 属性条目。</p>
</li>
<li><p>为什么明明自定义属性名为data-categoryName的形式，但是可以通过下述方式解构出来</p>
<pre><code class="language-js">const { categoryname, category1id, category2id, category3id } = event.target.dataset;
</code></pre>
<p>这是因为在DOM中，<code>dataset</code> 对象的属性名会自动将短横线形式转换为驼峰命名法。这是一种规范化的行为，旨在使JavaScript中的属性名更符合通用的驼峰命名规范。</p>
<p>在HTML中，我们可以使用短横线分隔的形式，如 <code>data-category-name</code>。然而，当我们在JavaScript中使用 <code>dataset</code> 获取属性时，属性名会被转换为驼峰命名法。例如：</p>
<pre><code class="language-js">const element = document.getElementById(&#39;yourElementId&#39;);
console.log(element.dataset.categoryName); // 这里是驼峰命名法
</code></pre>
<p>因此，虽然在HTML中使用了 <code>data-categoryName</code>，但在JavaScript中，你使用 <code>dataset</code> 时应该使用 <code>categoryName</code> 而不是 <code>data-categoryName</code>。</p>
<p>这个转换是自动进行的，无需手动添加 <code>data-</code> 前缀。Vue.js在处理这些自定义属性时会遵循相同的规则。这种设计有助于使JavaScript代码更符合通用的命名约定。</p>
</li>
</ul>
<p>当点击事件触发时，解构出</p>
<pre><code class="language-js">const { categoryname, category1id, category2id, category3id } = event.target.dataset;
</code></pre>
<p>如果有<code>categoryname</code>有值，显然点击的是<code>a</code>标签，因为只有a标签才被赋予了自定义属性，所以通过这样，点击事件可以获取点击的是哪个a标签，再将需要的值赋予自定义属性</p>
<pre><code class="language-js">if (categoryname) {
    // console.log(categoryname);
    var location = { name: &quot;search&quot; };
    var query = { categoryName: categoryname };
    if (category1id) {
        // console.log(category1id);
        query.category1Id = category1id;
    } else if (category2id) {
        query.category2Id = category2id;
    } else if (category3id) {
        query.category3Id = category3id;
    }
}
</code></pre>
<p>至此，即可完成query参数的收集</p>
<h4>合并params,query参数</h4>
<p>三级分类携带的是query参数，Header组件的搜索栏携带的是params参数，现在的问题是，点击这两个无论哪个，另外一个的内容都为空，也就是就是携带不上，这里只需要在路由跳转时，带上相应的参数即可</p>
<p>三级分类带上params:</p>
<pre><code class="language-js">//判断是否有params参数，将query参数和params都push过去
if(this.$route.params){
    location.params = this.$route.params;
}
</code></pre>
<p>Header组件带上query：</p>
<pre><code class="language-js">// this.$router.query即使没有也是个{}，可以执行if内的语句
if (this.$route.query) {
    console.log(this.$route.query);
    //判断是否有query参数，将query参数和params都push过去
    let location = {
        name: &quot;search&quot;,
        params: { keyword: this.keyword || undefined },
    };
    location.query = this.$route.query;
    this.$router.push(location);
}
</code></pre>
<ul>
<li>this.$router.query即使没有也是个{}，可以执行if内的语句</li>
</ul>
<h3>swiper</h3>
<h4>遇到的一些问题</h4>
<p>swiper要求必须先有结构，再new实例</p>
<p>遇到的问题是： 组件还没有数据，结构不完整（这时的项目进度是在组件自身派发action）</p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231205160145636.png" alt="image-20231205160145636"></p>
<p>修改仓库数据之后才有数据，在此之前初始化swiper实例是一定不行的</p>
<ul>
<li>mounted之后，html结构不一定完整，如果结构是根据数据动态生成的，而数据是向服务器异步获取的，就可能出现mounted后，结构并不一定完整</li>
<li>使用watch + this.$nextick解决</li>
<li><strong>this.$nextick</strong>：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</li>
<li>为什么需要<code>this.$nextick</code>, 即使监听到<code>list</code>发生变化，也就是有数据了，但是<code>v-for</code>遍历也是需要时间的，页面还是不一定有结构，所以使用this.$nextick保证在下次dom更新后页面一定有结构</li>
<li>即使封装该组件，数据由父组件通过props传过来，也就是该有的数据都有，但是还是需要<strong>this.$nextick</strong>，因为v-for动态渲染结构我们还是没有办法确定的，因此还是需要用nextTick，而且需要<code>immediate:true</code>，因为watch监听不到List的变化：因为这个数据从来没有发生变化（数据是父亲给的，父亲给的时候就是一个对象，对象里面该有的数据都是有的</li>
</ul>
<pre><code class="language-js">  watch:{
    list: {
      //监听不到List的属性，因为是Home父组件传过来的，
      // Vue: 但是没关系，就当时为了我，对他使用immediate：TRUE吧，上来立即监听一次
      //道理同Listcontainer一样，需要使用nextTick属性
      //this.$refs.mySwiper =&gt;  &quot;.swiper-container&quot;
      immediate:true,
      handler(){
        this.$nextTick(()=&gt;{
            var mySwiper = new Swiper(&quot;.swiper-container&quot;, {
            direction: &quot;horizontal&quot;, // 垂直切换选项
            loop: true, // 循环模式选项
            .......
          });
        })
      }
    }
  }
</code></pre>
<h2>Mock--本地模拟接口</h2>
<ul>
<li><p><code>npm i mockjs</code></p>
</li>
<li><p>服务器返回的Json字符串<code>src/mock/banners.json</code>，该文件里如果链接了静态资源，图片之类的，将图片放在<code>/public</code>下，</p>
</li>
<li><p><code>src/mock/mockServer.json</code>:</p>
<pre><code class="language-js">//webpack默认对外暴露的有JSON数据格式，图片
import Mock from &#39;mockjs&#39;
import banners from &#39;./banners.json&#39;
import floors from &#39;./floors.json&#39;

Mock.mock(&quot;/mock/banners&quot;,{code:200,data:banners});
Mock.mock(&quot;/mock/floors&quot;,{code:200,data:floors});
</code></pre>
<p>该文件至少要执行一次，所以在<code>main.js</code>中: </p>
<pre><code class="language-js">//引入MockServer.js  ----mock数据
import &#39;@/mock/mockServer&#39;
</code></pre>
</li>
<li><p>剩下的就是请求，向<code>/mock/banners</code>请求，发出的Ajax会被在本地拦截，</p>
</li>
</ul>
<h2>search页面搭建</h2>
<p>首先，search页面数据如下，代表了当前搜索相关的信息，所以在改页面的操作必须密切关注其改变或者对其操作：</p>
<pre><code class="language-js">  data() {
    return {
      searchParams: {
        category1Id: &quot;&quot;,
        category2Id: &quot;&quot;,
        category3Id: &quot;&quot;,
        categoryName: &quot;&quot;,
        keyword: &quot;&quot;,
        //初始状态：综合:降序
        order: &quot;1:desc&quot;,
        pageNo: 1,
        pageSize: 3,
        props: [],
        trademark: &quot;&quot;,
      },
    };
  },
</code></pre>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231207134825125.png" alt="image-20231207134825125"><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231207135131650.png" alt="image-20231207135131650"></p>
<h3>解决header搜索栏失效</h3>
<ul>
<li><p>search页面如果由home跳转，那么应该要基于其携带的路由参数获得要展示的数据</p>
</li>
<li><p>可以选择在组件挂载阶段派发异步action获取数据，但是因为后面肯定还要不断地更新搜索页面，所以这里，我们将派发异步action获取数据的操作包装到methods的<strong>getdata</strong>,在mounted阶段调用，完成初次渲染</p>
</li>
<li><p>上一步还需要注意的是，在beforeMount阶段合并路由参数</p>
<pre><code class="language-js">beforeMount() {
    Object.assign(this.searchParams, this.$route.query, this.$route.params);
},
</code></pre>
</li>
<li><p>合并参数至 <strong>searchParams</strong> 后，在 <strong>mounted</strong> 调用 <strong>getdata</strong> 派发 <strong>action</strong> 即可</p>
</li>
<li><p>但是这里导致的问题是，后续再次<strong>在Header组件搜索是不再次派发异步action获取数据的</strong>，因为，组件只会在mounted阶段执行getdata，header再次搜索仅仅只会改变路由信息，而不会触发getdata方法</p>
</li>
<li><p>其实很简单，只需要将$route作为监听属性即可，当$$route信息发生变化，带着路由信息并且调用getdata方法重新派发异步action获取数据即可</p>
<p><strong>注意合并路由信息</strong></p>
<pre><code class="language-js">Object.assign(this.searchParams, this.$route.query, this.$route.params);
</code></pre>
<p>注意在更新页面后清除三级分类列表的数据，这三个每次都只会有一个有值，所以不清除就会出现同时有两个，三个有值，categoryName不用，他就一个，每次都会替换</p>
</li>
</ul>
<p><strong>总结</strong>	beforeMount阶段合并路由参数 =&gt; 在mounted阶段调用getdata，完成初次渲染</p>
<p>​	 =&gt; 将$route作为监听属性即可，当$$route信息发生变化，带着路由信息并且调用getdata</p>
<h3>展示数据</h3>
<ul>
<li><p>Vuex的getter是不分模块的，以数组形式调用即可</p>
<pre><code class="language-js">computed:{
    ...mapGetters([&#39;trademarkList&#39;,&#39;attrsList&#39;])
},
</code></pre>
</li>
</ul>
<h3>面包屑清除操作</h3>
<ul>
<li><p>每一次去除都要重新发送请求获取数据</p>
</li>
<li><p>有的属性位于子组件--品牌信息，用到了自定义事件</p>
<ul>
<li><p>父组件给子组件自定义事件</p>
<pre><code class="language-vue">&lt;SearchSelector @trademarkInfo=&quot;trademarkInfo&quot; @attrInfo=&quot;attrInfo&quot; /&gt;

trademarkInfo(trademark) {
    this.searchParams.trademark = `${trademark.tmId}:${trademark.tmName}`;
    this.getdata();
}
</code></pre>
</li>
<li><p>子组件触发并携带数据</p>
<pre><code class="language-js">attrHandler(attr,attrvalue){
    this.$emit(&#39;attrInfo&#39;,attr,attrvalue)
}
</code></pre>
</li>
</ul>
</li>
<li><p>header组件的搜索内容也作为面包屑--keyword，清除该条信息时，显然也要将header搜索栏的文字置空，这里使用了全局事件总线，注意，自定义事件不在标签中写则应该在mounted阶段发布事件</p>
<ul>
<li>需要数据的地方派发事件</li>
</ul>
<pre><code class="language-js">this.$bus.$on(&#39;clearkeyword&#39;,()=&gt;{
    this.keyword = &quot;&quot;;
})
</code></pre>
<ul>
<li>需要更改数据的时候触发即可</li>
</ul>
<pre><code class="language-js">this.$bus.$emit(&quot;clearkeyword&quot;);
</code></pre>
</li>
<li><p>移除categoryName时有个小细节</p>
<ul>
<li><p>发送数据和清除面包屑前：</p>
<pre><code class="language-js">//即使为空&#39;&#39;，请求依旧会携带空字符串，设置为undefined，则不会携带过去,提升性能
this.searchParams.categoryName = undefined;
this.searchParams.category1Id = undefined;
this.searchParams.category2Id = undefined;
this.searchParams.category3Id = undefined;
</code></pre>
</li>
<li><p>发送数据和清除面包屑后更新路由信息，</p>
<pre><code>this.getdata();
</code></pre>
<p>显然只有与三级分类和搜索栏相关的才需要该操作，移除其他面包屑只需要将对应属性置为undefined即可</p>
<p><strong>注意因为有params和query,清除一个，不要忘记将另外一个遗漏，这一步不可以遗漏</strong></p>
<pre><code class="language-js">if (this.$route.params) {
    this.$router.push({ name: &quot;search&quot;, params: this.$route.params });
}
</code></pre>
<p><strong>遗漏的后果(这里展示的是去除三级列表面包屑后应该只携带params的逻辑)：</strong></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231207134012299.png" alt="image-20231207134012299"></p>
<p><strong>下面是正确的跳转结果(应该只携带params才对)：</strong>
<img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231207134214611.png" alt="image-20231207134214611"></p>
</li>
</ul>
</li>
<li><p>props是一个数组，代表商品参数，信息由v-for遍历生成面包屑结构，添加时，需要去重</p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231207134809861.png" alt="image-20231207134809861"></p>
<pre><code class="language-js">//组合标签属性获取
attrInfo(attr, attrvalue) {
        let props = `${attr.attrId}:${attrvalue}:${attr.attrName}`;
        //去重，不然一直往里加 ,等于-1表示不重复
        if(this.searchParams.props.indexOf(props) == -1 ){
        this.searchParams.props.push(props);
    }
    this.getdata();
},
</code></pre>
<p>删除：<strong>this.searchParams.props.splice(index,1);</strong></p>
</li>
</ul>
<h3>排序业务的完成</h3>
<p>参数： 1:desc   1代表综合 desc代表降序</p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231206163802442.png" alt="image-20231206163802442"></p>
<ul>
<li>icon组件库的使用</li>
<li>总共就两个按钮，点击事件绑定相同的函数，通过传入的参数不同判断点击的是综合还是价格，判断之后，对于本身已是筛选条件的按钮的再次点击，显然是将原有的升序降序取反即可，点击不同按钮，将数字取另一个，排序默认降序即可</li>
</ul>
<pre><code class="language-js">if (flag == orginsFlag) {
    newOrder = `${orginsFlag}:${originSort == &quot;desc&quot; ? &quot;asc&quot; : &quot;desc&quot;}`;
} else {
    //点击不是同一个按钮
    newOrder = `${flag}:${&quot;desc&quot;}`;
}
</code></pre>
<h3>重要--手写分页器组件</h3>
<ul>
<li><p>前端三大件:轮播图、分页、日历。这属于前端开发常见三种业务</p>
</li>
<li><p>为什么很多项目中都采用分页功能?</p>
<ul>
<li><p>比如电商平台：搜索一个奶粉，奶粉的产品有10000+，一次渲染10000+条数据，可能慢。</p>
<p>数据多的时候，可以选择分页，比如每一次只是展示10</p>
</li>
</ul>
</li>
<li><p>拆分分页组件（静态组件），注册为全局组件，因为其他模块也在使用分页功能。</p>
</li>
<li><p>分页器组件需要知道我一共展示多少条数据 ----total【100条数据】</p>
</li>
<li><p>每一个需要展示几条数据------pageSize【每一页3条数据】</p>
</li>
<li><p>需要知道当前在第几页-------pageNo[当前在第几页]</p>
</li>
<li><p>需要知道连续页码数【起始数字、结束数字：连续页码数市场当中一般5、7、9】奇数，对称好看 continues</p>
</li>
</ul>
<p>这里我们要计算两个数据continues的start和end,</p>
<p>分页器的逻辑先考虑可能出现的情况</p>
<ul>
<li><p><strong>if (continues &gt; totalPage)</strong> 总页数比较少，continues的连续页码数比总页数还多，这显然start就是1，end就是totalPage</p>
</li>
<li><p><strong>else</strong>就是： 由pageNo计算出左右的continues的start和end</p>
<pre><code class="language-js">//正常现象【连续页码5，但是你的总页数一定是大于5的】
//起始数字
start = pageNo - parseInt(continues / 2);
//结束数字
end = pageNo + parseInt(continues / 2);
</code></pre>
<p>这里要当心。当页码靠前，start会变为负数，所以</p>
<pre><code class="language-js">//把出现不正常的现象【start数字出现0|负数】纠正
if (start &lt; 1) {
    start = 1;
    end = continues;
}
</code></pre>
<p>或者continues的end比totalPage还大</p>
<pre><code class="language-js">//把出现不正常的现象[end数字大于总页码]纠正
if (end &gt; totalPage) {
    end = totalPage;
    start = totalPage - continues + 1;
}
</code></pre>
</li>
</ul>
<p>至此就结束了start和end的计算，下面完成对分页器... 和 首尾页的显示逻辑，当start 为1时，显然就不应该有1 ... 1 2 3这种结构</p>
<p>解决方法</p>
<pre><code class="language-vue">&lt;button
        v-if=&quot;startNumAndEndNum.start &gt; 1&quot;
        @click=&quot;$emit(&#39;getPageNo&#39;, 1)&quot;
        :class=&quot;{ active: pageNo == 1 }&quot;
        &gt;
    1
&lt;/button&gt;
&lt;button v-if=&quot;startNumAndEndNum.start &gt; 2&quot;&gt;···&lt;/button&gt;
</code></pre>
<p>同理在当前页划到末尾页面时：<strong>注意...显示与否条件为：startNumAndEndNum.end &lt; totalPage - 1</strong></p>
<pre><code class="language-vue">&lt;button v-if=&quot;startNumAndEndNum.end &lt; totalPage - 1&quot;&gt;···&lt;/button&gt;
&lt;button
    v-if=&quot;startNumAndEndNum.end &lt; totalPage&quot;
    @click=&quot;$emit(&#39;getPageNo&#39;, totalPage)&quot;
    :class=&quot;{active:pageNo==totalPage}&quot;
    &gt;
    {{ totalPage }}
&lt;/button&gt;
</code></pre>
<p>首先是通过<strong>v-for</strong>完成对于continues的展示：<strong>使用v-for遍历数字</strong></p>
<p><code>v-if=&quot;page &gt;= startNumAndEndNum.start&quot;</code>page大于等于start的才展示</p>
<pre><code class="language-vue">&lt;button
    v-for=&quot;(page, index) in startNumAndEndNum.end&quot;
    :key=&quot;index&quot;
    v-if=&quot;page &gt;= startNumAndEndNum.start&quot;
    @click=&quot;$emit(&#39;getPageNo&#39;, page)&quot;
    :class=&quot;{ active: pageNo == page }&quot;
    &gt;
    {{ page }}
&lt;/button&gt;
</code></pre>
<p>​	+还有就是对首页和末尾页禁用上一页和下一页的按钮</p>
<p>点击事件将页码通过全局事件总线传给search组件,更新searchParams的pageNo搜索参数，发送Ajax请求</p>
<h3>处理滚动行为</h3>
<p>从 <code>search</code>  跳转到<code>detail</code> 发现浏览器滚轮y轴并不在0的位置， <strong>解决办法</strong></p>
<pre><code class="language-js">//对外暴露VueRouter类的实例
let router = new VueRouter({
  //配置路由
  //第一:路径的前面需要有/(不是二级路由)
  //路径中单词都是小写的
  //component右侧V别给我加单引号【字符串：组件是对象（VueComponent类的实例）】
  routes,
  //滚动行为
  scrollBehavior(to, from, savedPosition) {
    //返回的这个y=0，代表的滚动条在最上方
    return { y: 0 };
  },
});
</code></pre>
<h2>Detail详情页</h2>
<p>这里我觉得比较重要的是，关于异步操作，数据没有及时返回，控制台飘红，这个不影响页面的显示，可以通过良好的编码习惯避免</p>
<h3>数据为undefined导致的控制台飘红</h3>
<ul>
<li><p>场景一：detail的Vuex仓库</p>
<p>当组件取到数据比如<strong>state.goodInfo.categoryView</strong>并读取其身上的某个属性，如果不写 <strong>|| {}</strong>，那么在一开始还没有数据<strong>state.goodInfo</strong>的时候读取<strong>categoryView</strong>属性返回的就是undefined,这是导致飘红的原因，这里加上 **|| {}**至少可以避免报错。</p>
<pre><code class="language-js">//简化数据而生
const getters = {
  //路径导航简化的数据
  categoryView(state) {
    //比如:state.goodInfo初始状态空对象，空对象的categoryView属性值undefined
    //当前计算出的 categoryView属性值至少是一个空对象，假的报错不会有了。
    return state.goodInfo.categoryView || {};
  },
  //简化产品信息的数据
  skuInfo(state) {
    return state.goodInfo.skuInfo || {};
  },
  //产品售卖属性的简化
  spuSaleAttrList(state) {
    return state.goodInfo.spuSaleAttrList || [];
  },
};
</code></pre>
</li>
<li><p>场景二：嵌套形式，虽然场景一保证了读取不报错，但是在还没有数据时读取<strong>categoryView</strong>下的属性，那么依然会报错的</p>
<pre><code class="language-js">// detail传给放大器组件skuImageList，同时在自身已经做了 || []防止飘红
skuImageList() {
    //如果服务器数据没有回来，skuInfo这个对象是空对象
    return this.skuInfo.skuImageList || [];
},
//传给放大器组件skuImageList
&lt;Zoom :skuImageList=&quot;skuImageList&quot; /&gt;
    
// 放大器组件中要使用的是skuImageList[this.currentIndex]，这显然是下一层了
// 这里的解决方法为:
computed:{
   imgObj(){
      return this.skuImageList[this.currentIndex]||{}
     }
},
</code></pre>
</li>
</ul>
<p>图片轮播业务还是swiper组件</p>
<p>​	+点击其中图片通过全局事件总线将点击的图片索引传给放大器组件</p>
<h3>放大镜</h3>
<p>给容器绑定 <strong>mousemove事件，监听鼠标位置</strong></p>
<p>​	+offsetX</p>
<p>​	+offsetWidth</p>
<pre><code class="language-js">handler(event) {
    let mask = this.$refs.mask;
    let big = this.$refs.big;
    let left = event.offsetX - mask.offsetWidth / 2;
    let top = event.offsetY - mask.offsetHeight / 2;
    //约束范围
    if (left &lt;= 0) left = 0;
    if (left &gt;= mask.offsetWidth) left = mask.offsetWidth;
    if (top &lt;= 0) top = 0;
    if (top &gt;= mask.offsetHeight) top = mask.offsetHeight;
    //修改元素的left|top属性值
    mask.style.left = left + &quot;px&quot;;
    mask.style.top = top + &quot;px&quot;;
    big.style.left = -2 * left + &quot;px&quot;;
    big.style.top = -2 * top + &quot;px&quot;;
},
</code></pre>
<h2>加入购物车成功页面</h2>
<p>点击之后只带着购买的个数跳转到<strong>加入购物车成功路由</strong>,其他的都没有带，购买个数放在路由跳转的query参数上</p>
<ul>
<li><p>跳转肯定是向后台发请求，且跳转前还要校验是否成功，在点击加入购物车这个按钮的时候，做的第一件事情，将参数带给服务器（发请求），通知服务器加入购车的产品是谁</p>
<p>**this.$store.dispatch(&#39;addOrUpdateShopCart&#39;),**说白了，它是在调用vuex仓库中的这个addOrUpdateShopCart函数。</p>
</li>
<li><p>你需要知道这次请求成功还是失败，</p>
<p>具体来说就是在派发的action中做个判断，失败就返回失败的Promise</p>
<pre><code class="language-js">//加入购物车的||修改某一个产品的个数
async addOrUpdateShopCart({ commit }, { skuId, skuNum }) {
    //发请求:前端带一些参数给服务器【需要存储这些数据】，存储成功了，没有给返回数据
    //不需要在三连环（仓库存储数据了）
    //注意:async函数执行返回的结果一定是一个promise【要么成功，要么失败】
    let result = await reqAddOrUpdateShopCart(skuId, skuNum);
    if (result.code == 200) {
        //返回的是成功的标记
        return &quot;ok&quot;;
    } else {
        //返回的是失败的标记
        return Promise.reject(new Error(&quot;faile&quot;));
    }
},
</code></pre>
<p>如果成功进行路由跳转，如果失败，需要给用户提示</p>
</li>
<li><p>上述都没有问题则进行路由跳转</p>
</li>
<li><p>在路由跳转的时候还需要将产品的信息带给下一级的路由组件，这里只有skuNum，通过query形式给路由组件传递过去，产品信息的数据【比较复杂:skuInfo】,通过会话存储（不持久化,会话结束数据在消失）本地存储|会话存储，一般存储的是字符串</p>
</li>
</ul>
<p><strong>本地存储用户购物商品信息</strong></p>
<pre><code class="language-js">sessionStorage.setItem(&quot;SKUINFO&quot;,JSON.stringify(this.skuInfo));
</code></pre>
<p><strong>路由跳转</strong>：</p>
<pre><code class="language-js">this.$router.push({name:&#39;addcartsuccess&#39;,query:{skuNum:this.skuNum}});
</code></pre>
<p>现在是加入购物车成功的组件：</p>
<p>该页面只需读取刚刚本地存储的sessionStorage字段	<strong>作为计算属性即可</strong>	：</p>
<pre><code class="language-js">computed: {
    skuInfo() {
        return JSON.parse(sessionStorage.getItem(&quot;SKUINFO&quot;));
    },
},
</code></pre>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231207101352184.png" alt="image-20231207101352184"></p>
<p>查看详情直接带着商品id跳转到detail路由即可，现在的工作是去购物车结算的业务</p>
<h2>购物车页面搭建</h2>
<p>现在如果直接点<strong>去购物车结算</strong>跳转路由是行不通的，根本无法获取到数据，因为这是个向后台服务器获取数据的操作，服务器根本不知道你是谁，应该显示谁的数据，所以下一步工作就是用uuid创建令牌，作为服务器识别的标识，</p>
<h3>uuid完成用户识别</h3>
<p>新增模块 <strong>/src/utils/uuid_token.js</strong> 用于生成令牌，做个判断，已有则直接读取本地的，没有则创建在返回</p>
<pre><code class="language-js">import { v4 as uuidv4 } from &#39;uuid&#39;;
//要生成一个随机字符串，且每次执行不能发生变化，游客身份持久存储
export const getUUID = ()=&gt;{
   //先从本地存储获取uuid（看一下本地存储里面是否有）
   let uuid_token = localStorage.getItem(&#39;UUIDTOKEN&#39;);
   //如果没有
   if(!uuid_token){
       //我生成游客临时身份
      uuid_token = uuidv4();
      //本地存储存储一次
      localStorage.setItem(&#39;UUIDTOKEN&#39;,uuid_token);
   }
   //切记有返回值,没有返回值undefined
   return uuid_token;
}
</code></pre>
<ul>
<li><p>记住一定要return,之前在完成购物车界面，用到了Array.prototype.reduce方法，其中的回调函数必须要返回一个值作为下一次调用前的输入值</p>
</li>
<li><p>在store初始化时，detail仓库新增数据：	<strong>uuid_token:getUUID()</strong>	</p>
</li>
<li><p>在二次封装Axios的方法的请求拦截器将上面的token令牌获取，在请求头新增字段，值即为上面的令牌，字段为后端已经约定好的，带着这个字段服务器就可以识别用户</p>
<pre><code class="language-js">import store from &#39;@/store&#39;;
let requests = axios.create({
  //基础路径
  baseURL: &quot;/api&quot;,
  //请求不能超过5S
  timeout: 5000,
});
//请求拦截器----在项目中发请求（请求没有发出去）可以做一些事情
requests.interceptors.request.use((config) =&gt; {
  //现在的问题是config是什么?配置对象
  //可以让进度条开始动
  if(store.state.detail.uuid_token){
    //请求头添加一个字段(userTempId):和后台老师商量好了
    config.headers.userTempId = store.state.detail.uuid_token;
  }
  //需要携带token带给服务器
  if(store.state.user.token){
    config.headers.token = store.state.user.token;
  }
  nprogress.start();
  return config;
});
</code></pre>
</li>
</ul>
<p>如果上述操作成功，那么带来的影响是：</p>
<ul>
<li>所有的请求将会带着这个令牌向后台服务器发送Ajax请求</li>
<li>之前的将商品加入购物车的action <strong>async addOrUpdateShopCart({ commit }, { skuId, skuNum })</strong> 该操作会使后端根据你的令牌，将商品及其数量加入数据库</li>
<li>接下来再点击 <strong>去购物车结算</strong> 就可以正常拉取数据并展示</li>
</ul>
<h3>购物车详情页</h3>
<ul>
<li>注意，该页面 <strong>所有的操作都是先修改后台数据，</strong> 后台修改成功之后再向后台发送请求同步本地数据</li>
<li>都是先派发action去向后台发送请求，后台根据请求的不同来修改数据库数据</li>
<li>之后如果请求成功，也就是后台通知数据库数据已完成修改，那么<ul>
<li>再次派发action向服务器发送请求获取数据</li>
<li>接着commit该action</li>
<li>再同步store的数据，数据的更改引起页面的重新渲染</li>
</ul>
</li>
</ul>
<p>获取数据后，将数据绑定到页面</p>
<p>.......</p>
<h3>修改商品数量</h3>
<p>有三处可以修改购物车界面的商品数量</p>
<ul>
<li><code>+</code>   点击加号对数据加一即可</li>
<li>input框</li>
<li><code>-</code>  点击减号对数据减一，但是要注意会减到小于一的数，做数据校验</li>
</ul>
<p>使用同一个函数来完成业务，</p>
<ul>
<li>通过调用时传不同的字段即可区分是谁在调用</li>
<li>通过传入 <strong>v-for</strong> 生成的商品信息区分当前操作的是哪个商品</li>
<li>加和减号都只对数据进行加一减一的操作，获取input框的值通过 <strong>$event.target.value * 1</strong> 注意转换为 <strong>number</strong> 类型</li>
<li>使用<strong>loadsh</strong>节流，防止用户操作过快造成的页面卡顿</li>
<li>之后派发action，后台修改成功后，再次向后台请求购物车信息</li>
</ul>
<pre><code class="language-js">//修改某一个产品的个数[节流]
handler: throttle(async function(type, disNum, cart) {
//type:为了区分这三个元素
//disNum形参:+ 变化量（1）  -变化量（-1）   input最终的个数（并不是变化量）
//cart:哪一个产品【身上有id】
//向服务器发请求，修改数量
    switch (type) {
    //加号
    case &quot;add&quot;:
        disNum = 1;
        break;
    case &quot;minus&quot;:
        //判断产品的个数大于1，才可以传递给服务器-1
        //如果出现产品的个数小于等于1，传递给服务器个数0（原封不动）
        disNum = cart.skuNum &gt; 1 ? -1 : 0;
        break;
    case &quot;change&quot;:
        // //用户输入进来的最终量，如果非法的（带有汉字|出现负数），带给服务器数字零
        if (isNaN(disNum) || disNum &lt; 1) {
            disNum = 0;
        } else {
            //属于正常情况（小数：取证），带给服务器变化的量 用户输入进来的 - 产品的起始个数
            disNum = parseInt(disNum) - cart.skuNum;
        }
        // disNum = (isNaN(disNum)||disNum&lt;1)?0:parseInt(disNum) - cart.skuNum;
        break;
    }
    //派发action
    try {
        //代表的是修改成功
        await this.$store.dispatch(&quot;addOrUpdateShopCart&quot;, {
        skuId: cart.skuId,
        skuNum: disNum,
        });
        //再一次获取服务器最新的数据进行展示
        this.getData();
    } catch (error) {
        alert(error.message)
    }
}, 500),
</code></pre>
<p><strong>删除某一个产品的操作 修改某个产品的勾选状态</strong> 基本都是一个套路，通过try...catch...派发action,根据返回的code判断操作是否成功，成功就再次 <strong>this.getData()</strong>, 再次派发请求购物车数据的action,然后更新仓库数据，引起页面重新渲染</p>
<h3>store中在action中派发action完成业务</h3>
<p><strong>删除全部选中的产品</strong>  <strong>以及修改全部产品的选中状态</strong>  也是一个套路</p>
<ul>
<li>派发请求，不同的是在action里的操作，这里只有 <strong>修改全部产品的选中状态的业务</strong> 在派发action时携带了一个参数，代表全部勾选还是全部取消勾选</li>
</ul>
<p>主要是在<strong>context</strong>中解构出 <strong>dispatch</strong> <strong>store</strong> </p>
<ul>
<li><p>使得可以访问其他的action,实现在action里派发action</p>
</li>
<li><p>通过 <strong>store</strong> 可以访问购物车数据，进而判断哪些数据被选中，并在派发action时携带相应参数</p>
</li>
<li><p>使用了 <strong>Promise.all</strong> 方法来判断所有的操作是否都成功</p>
</li>
</ul>
<pre><code class="language-js">//删除全部勾选的产品
deleteAllCheckedCart({ dispatch, getters }) {
    //context:小仓库，commit【提交mutations修改state】 getters【计算属性】 dispatch【派发action】 state【当前仓库数据】
    //获取购物车中全部的产品（是一个数组）
    let PromiseAll = [];
    getters.cartList.cartInfoList.forEach((item) =&gt; {
        let promise =
        item.isChecked == 1
        ? dispatch(&quot;deleteCartListBySkuId&quot;, item.skuId)
        : &quot;&quot;;
        //将每一次返回的Promise添加到数组当中
        PromiseAll.push(promise);
    });
    //只要全部的p1|p2....都成功，返回结果即为成功
    //如果有一个失败，返回即为失败结果
    return Promise.all(PromiseAll);
},
</code></pre>
<h2>Register注册页面</h2>
<ul>
<li><p>收集表单数据，通过 <strong>prevent</strong> 来取消默认行为</p>
</li>
<li><p>先获得验证码</p>
</li>
<li><p>再收集注册的表单数据派发注册的action </p>
</li>
<li><p>注册成功则跳转到 <strong>/login</strong></p>
</li>
</ul>
<h2>Login登录页面</h2>
<p>这里在注册成功之后，如果在登录页账号密码无误，在派发登录的action之后，服务器会返回token,</p>
<ul>
<li><p>现在需要将axios二次封装的业务再次提起，需要向请求头加入获得的<strong>token</strong>值</p>
</li>
<li><p>获得 <strong>token</strong> 后，需要将其放在本地<strong>localStorage</strong> 持久化存储，且 <strong>user</strong> 的仓库的 <strong>state</strong> 的token就要去本地去取，且每次登录后都要做两件事</p>
<ul>
<li>获得token，将其在本地持久化存储</li>
<li>更新仓库的token</li>
</ul>
</li>
<li><p>有 <strong>token</strong> 即代表登录成功，<strong>但是不代表此时就有用户信息！！！</strong></p>
</li>
<li><p><strong>用户信息需要额外派发action，该接口不携带参数，请求头携带正确的token即可</strong></p>
</li>
</ul>
<h3><strong>Header</strong> 组件注入用户信息</h3>
<p><strong>Header</strong> 组件无论去哪个路由都会有</p>
<p>现在有一个很大的问题是<strong>如何获取用户信息</strong>，当然，这个直接派发一个action即可，但是注意：</p>
<ul>
<li><p>用户信息是存储在仓库里的，也就是无法持久化存储，只要一刷新， <strong>Header上的信息立刻就会丢失</strong> </p>
</li>
<li><p>当然我们可以在每个路由组件挂载时就派发一次请求但是这样<strong>代码编写太麻烦</strong>了，这里采用<strong>路由前置守卫</strong>来解决该问题</p>
</li>
</ul>
<h3>路由前置守卫解决Header个人信息丢失</h3>
<p><strong>(to, from, next)</strong></p>
<p>具体的逻辑是：</p>
<ul>
<li><p>这套逻辑会使如果你有token的话，在页面初次渲染时就会去派发获得用户信息的action，后面即使页面刷新，也走的是初渲染流程，还是会带着token去派发action</p>
<ul>
<li>如果派发action失败，那么应该是token过期，这样需要清除用户信息，派发相应的清除用户信息的action,并可以跳转到 <strong>/login</strong> 重新登录</li>
<li>派发成功就更新用户信息更新仓库数据</li>
</ul>
</li>
<li><p>如果当前 <strong>token</strong> 存在，显然是已登录状态，这里有个误区，<strong>已登录状态 ！===有用户数据</strong> ，这个时候可以阻止用户跳转到登录页和注册页</p>
</li>
<li><p>不会同时出现有<strong>token</strong>且页面上有这个东西：<img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231207194445400.png" alt="image-20231207194445400">的情况，除非是token过期跳转到login页，只要你有 <strong>token</strong> 就会在页面渲染的时候判断有有无用户信息，没有就会再路由跳转前自动派发action, 然后肯定是有数据的，除非 <strong>token有问题</strong></p>
</li>
</ul>
<pre><code class="language-js">//全局守卫：前置守卫（在路由跳转之间进行判断）
router.beforeEach(async (to, from, next) =&gt; {
   //to:获取到要跳转到的路由信息
   //from：获取到从哪个路由跳转过来来的信息
   //next: next() 放行  next(path) 放行  
   //方便测试 统一放行
  //  next();
  //获取仓库中的token-----可以确定用户是登录了
   let token  = store.state.user.token;
   let name = store.state.user.userInfo.name;
   //用户登录了
   if(token){
     //已经登录而且还想去登录------不行
     if(to.path==&quot;/login&quot;||to.path==&#39;/register&#39;){
        next(&#39;/&#39;);
     }else{
       //已经登陆了,访问的是非登录与注册
       //登录了且拥有用户信息放行
       if(name){
         next();
       }else{
         //登陆了且没有用户信息
         //在路由跳转之前获取用户信息且放行
         try {
          await store.dispatch(&#39;getUserInfo&#39;);
          next();
         } catch (error) {
           //token失效从新登录
           await store.dispatch(&#39;userLogout&#39;);
           next(&#39;/login&#39;)
         }
       }
     }
   }else{
      //未登录：不能去交易相关、不能去支付相关【pay|paysuccess】、不能去个人中心
      //未登录去上面这些路由-----登录
      let toPath = to.path;
      if(toPath.indexOf(&#39;/trade&#39;)!=-1 || toPath.indexOf(&#39;/pay&#39;)!=-1||toPath.indexOf(&#39;/center&#39;)!=-1){
        //把未登录的时候向去而没有去成的信息，存储于地址栏中【路由】
        next(&#39;/login?redirect=&#39;+toPath);
      }else{
         //去的不是上面这些路由（home|search|shopCart）---放行
         next();
      }
    
   }
});
</code></pre>
<h2>支付页面及相关业务</h2>
<p>点击 <strong>结算应该跳转到订单页面</strong>，这里挂载时派发 <strong>action</strong> ,略有不同的是，但是仓库的信息是通过计算属性拿到的</p>
<pre><code class="language-js">  computed: {
    ...mapState({
      addressInfo: (state) =&gt; state.trade.address,
      orderInfo: (state) =&gt; state.trade.orderInfo,
    }),
  },
</code></pre>
<h3>提交订单</h3>
<p>这里使用了 <strong>Element-UI</strong> </p>
<ul>
<li><p>注册全局组件</p>
</li>
<li><p>按需引入</p>
<ul>
<li><p>方式一，使用 <strong>Vue.component</strong></p>
<pre><code class="language-js">import { Button,MessageBox} from &#39;element-ui&#39;;
//全局组件：第一个参数 组件名字  第二个参数：那个组件
//注册全局组件
Vue.component(Button.name,Button);
</code></pre>
</li>
<li><p>方式二，直接挂载到<strong>Vue的原型</strong>上：</p>
<pre><code class="language-js">import { Button,MessageBox} from &#39;element-ui&#39;;
//ElementUI注册组件的时候，还有一种写法，挂在原型上
Vue.prototype.$msgbox = MessageBox;
Vue.prototype.$alert = MessageBox.alert;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3>$API</h3>
<p>不再派发 <strong>action</strong>,也就是不在使用 <strong>Vuex</strong>, 直接以全局事件总线的方式，将所有接口挂载在 <strong>Vue的原型</strong></p>
<pre><code class="language-js">import * as API from &#39;@/api&#39;;

new Vue({
  render: (h) =&gt; h(App),
  //全局事件总线$bus配置
  beforeCreate() {
    Vue.prototype.$bus = this;
    Vue.prototype.$API = API;
  },
  //需要把router进行注册
  //可以让全部的组件（非路由|路由组件）都可以获取到$route|$router属性
  //$route(路由)：可以获取到路由信息（path、query、params）
  //$router:进行编程式导航路由跳转push||replace
  router,
  //在入口文件这里注册store,在每一个组件的身上都拥有一个$store这个属性
  store,
}).$mount(&quot;#app&quot;);
</code></pre>
<p>获取相应的数据后 由 <strong>$API</strong>发送请求，获取订单号， <strong>code == 200</strong> 则跳转去支付页面</p>
<h3>微信支付业务</h3>
<ul>
<li><p>跳转到支付页面，首先在挂载阶段，带着传过来的订单号发请求，获取支付相关信息，里面包含<strong>支付二维码的链接</strong>，获取失败做相应的处理</p>
</li>
<li><p>当用户点击支付按钮后：</p>
<ul>
<li>弹窗，使用 <strong>qrcode</strong>解析 <strong>支付二维码的链接</strong> 获取二维码的图片地址</li>
<li>开启一个定时器，一直向后台发请求，在获得支付已成功的信息后，关闭定时器，保存 <strong>code</strong>,这个在用户主动点击 <strong>支付成功时用得上</strong>  ，再跳转到支付成功页面，这是在关闭弹窗的第一种方式</li>
<li>弹窗上的两个按钮<ul>
<li>对于按钮 <strong>支付遇到问题</strong> ，处理一下问题，关闭弹窗,关闭定时器</li>
<li>对于按钮 <strong>支付成功</strong>，如何判断用户支付成功，这里是使用 <strong>code</strong>,成功则关闭定时器，关闭弹窗，跳转路由</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js">//弹出框
async open() {
    //生成二维(地址)
    let url = await QRCode.toDataURL(this.payInfo.codeUrl);
    this.$alert(`&lt;img src=${url} /&gt;`, &quot;请你微信支付&quot;, {
        dangerouslyUseHTMLString: true,
        //中间布局
        center: true,
        //是否显示取消按钮
        showCancelButton: true,
        //取消按钮的文本内容
        cancelButtonText: &quot;支付遇见问题&quot;,
        //确定按钮的文本
        confirmButtonText: &quot;已支付成功&quot;,
        //右上角的叉子没了
        showClose: false,
        //关闭弹出框的配置值
        beforeClose: (type, instance, done) =&gt; {
            //type:区分取消|确定按钮
            //instance：当前组件实例
            //done:关闭弹出框的方法
            if (type == &quot;cancel&quot;) {
                alert(&quot;请联系管理员豪哥&quot;);
                //清除定时器
                clearInterval(this.timer);
                this.timer = null;
                //关闭弹出框
                done();
            } else {
                //判断是否真的支付了
                //开发人员：为了自己方便，这里判断先不要了
                // if (this.code == 200) {
                clearInterval(this.timer);
                this.timer = null;
                done();
                this.$router.push(&quot;/paysuccess&quot;);
                // }
            }
        },
    });
    //你需要知道支付成功|失败
    //支付成功，路由的跳转，如果支付失败，提示信息
    //定时器没有，开启一个新的定时器
    if (!this.timer) {
        this.timer = setInterval(async () =&gt; {
            //发请求获取用户支付状态
            let result = await this.$API.reqPayStatus(this.orderId);
            //如果code==200
            if (result.code == 200) {
                //第一步：清除定时器
                clearInterval(this.timer);
                this.timer = null;
                //保存支付成功返回的code
                this.code = result.code;
                //关闭弹出框
                this.$msgbox.close();
                //跳转到下一路由
                this.$router.push(&quot;/paysuccess&quot;);
            }
        }, 1000);
    }
},
</code></pre>
<h2>个人中心</h2>
<ul>
<li><p>搭建二级路由</p>
</li>
<li><p>获取信息，还是将方法封装成函数，挂载时调用，使用 <strong>$API</strong></p>
</li>
<li><p>表格数据绑定的一些细节</p>
</li>
<li><p>这里使用了我们自己搭建的分页器组件，复习一下分页器组件</p>
<pre><code class="language-Vue">&lt;!-- 分页器 --&gt;
&lt;!-- continues 连续页码 --&gt;
&lt;!-- getPageNo 使用自定义事件获取子组件点击后的页码 --&gt;
&lt;Pagination
    :pageNo=&quot;page&quot;
    :pageSize=&quot;limit&quot;
    :total=&quot;myOrder.total&quot;
    :continues=&quot;5&quot;
    @getPageNo=&quot;getPageNo&quot;
/&gt;
</code></pre>
</li>
</ul>
<h2>完善路由鉴权</h2>
<ul>
<li><p>对于支付成功页面，要进一步约束，即使你已经登录且由用户信息，但是，你只可以通过 <strong>/paysuccess</strong> 路由进入该页面</p>
</li>
<li><p>对于加入购物车成功页面，游客身份也是可以进入该页面的，但是必须要有<strong>产品信息的数据</strong>的 <strong>SKUINFO</strong> ,该 <strong>SKUINFO</strong>是在游客在 <strong>/detail</strong> 点击加入购物车时才会创建的，所以对于该路由，在跳转到它之前，必须同时有</p>
<ul>
<li>代表 <strong>产品信息的数据</strong> 的 <strong>SKUINFO</strong></li>
<li>加入购物车的商品的 <strong>skuNum</strong></li>
</ul>
</li>
<li><p>支付页面也只能通过在购物车点击结算按钮跳转</p>
</li>
<li><p>对于 <strong>/paysuccess</strong> 的跳转也可以使用组件路由守卫</p>
<ul>
<li><pre><code class="language-js">//组件内守卫
beforeRouteEnter(to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
    if (from.path == &quot;/pay&quot;) {
        next();
    } else {
        next(false);
    }
},
    beforeRouteUpdate(to, from, next) {
        // 在当前路由改变，但是该组件被复用时调用
        // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
        // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
        // 可以访问组件实例 `this`
        console.log(&quot;12313131311313&quot;);
    },

        beforeRouteLeave(to, from, next) {
            // 导航离开该组件的对应路由时调用
            // 可以访问组件实例 `this`
            next();
        },
</code></pre>
</li>
</ul>
</li>
</ul>
<h2>路由 图片 懒加载</h2>
<p>对于图片：</p>
<p><strong>/main.js</strong></p>
<pre><code class="language-js">//引入插件
import VueLazyload from &#39;vue-lazyload&#39;;
//注册插件
Vue.use(VueLazyload,{
  //懒加载默认的图片
  loading:atm
});

// 使用
&lt;img v-lazy=&quot;good.defaultImg&quot; /&gt;
</code></pre>
<h3>插件</h3>
<pre><code class="language-js">//引入自定义插件
import myPlugins from &#39;@/plugins/myPlugins&#39;;
Vue.use(myPlugins,{
    name:&#39;upper&#39;
});

// myPlugins.js
//Vue插件一定暴露一个对象
let myPlugins = {};

myPlugins.install = function(Vue,options){
    //全局指令
    Vue.directive(options.name,(element,params)=&gt;{
       element.innerHTML = params.value.toUpperCase();
       console.log(params);
    });

}
//对外暴露组件对象
export default myPlugins;
</code></pre>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231209141933840.png" alt="image-20231209141933840"></p>
<p><strong>params</strong> 似乎是包装过后的 <strong>options</strong></p>
<h3>路由懒加载</h3>
<p><strong>component: () =&gt; import(&#39;@/pages/Search&#39;)</strong></p>
<ul>
<li><p><strong>import(modulePath)</strong>: 动态<strong>import</strong>引入模块, 被引入的模块会被单独打包</p>
</li>
<li><p>组件配置的是一个函数, 函数中通过<strong>import</strong>动态加载模块并返回, </p>
<p>初始时函数不会执行, 第一次访问对应的路由才会执行, 也就是说只有一次请求对应的路由路径才会请求加载单独打包的js</p>
</li>
</ul>
<p>作用: 用于提高首屏的加载速度</p>
<p>就是改为动态引入</p>
<pre><code class="language-js">component: () =&gt; import(&#39;@/pages/Home&#39;)
</code></pre>
<h2>表单校验</h2>
<p>使用插件  <strong>vee-validate</strong></p>
<p>这块 略过 这个插件还没看怎么用的</p>
<h1>尚硅谷--后台项目--基于Vue3</h1>
<h2>GPT：</h2>
<h3>TS 类型推断</h3>
<p>使用泛型表示期望函数返回值不是这样写的吗： </p>
<pre><code class="language-js">function test&lt;T, K&gt;(a: T, b: K): K{    return b; }
</code></pre>
<p> 为什么</p>
<pre><code>request.get&lt;any, userInfoReponseData&gt;(API.USERINFO_URL);
</code></pre>
<p>没有   <strong>():userInfoReponseData</strong>   也可以表示期望返回userInfoReponseData类型</p>
<p>你的疑问是很合理的，这涉及到 TypeScript 中的一些类型推断和泛型使用的规则。在 TypeScript 中，当你在函数调用时使用泛型并提供了泛型参数，TypeScript 会尝试根据参数和上下文来推断泛型的类型。</p>
<p>在这个特定的情况下：</p>
<pre><code class="language-typescript">request.get&lt;any, userInfoReponseData&gt;(API.USERINFO_URL);
</code></pre>
<p>这里使用了 Axios 中的泛型参数 <code>&lt;T, R&gt;</code>，其中 <code>T</code> 表示请求的数据类型，而 <code>R</code> 表示响应的数据类型。在你的代码中，使用了 <code>any</code> 表示请求的数据类型是不确定的，但为了响应数据类型，你使用了 <code>userInfoReponseData</code>。</p>
<p>对于 Axios 的 <code>get</code> 方法，它返回一个 <code>Promise</code>，并且 Promise 的 <code>then</code> 方法中的回调函数会接收到响应数据。在这个过程中，TypeScript 会尝试推断出响应数据的类型，而不需要显式地指定。</p>
<p>因此，虽然你没有写成 <code>(data: userInfoReponseData) =&gt; ...</code>，TypeScript 会尝试根据上下文自动推断出响应数据的类型。这种推断通常很方便，因为你不必显式指定每个泛型参数的类型。</p>
<p>如果你确实想要显式指定返回值类型，你可以这样写：</p>
<pre><code class="language-typescript">request.get&lt;userInfoReponseData&gt;(API.USERINFO_URL).then((response) =&gt; {
  // 在这里，TypeScript 已经推断 response 的类型为 userInfoReponseData
});
</code></pre>
<p>这样，你就显式地指定了 <code>userInfoReponseData</code> 类型作为响应数据类型。</p>
<h1>B站小满Vue3教程</h1>
<p><strong>Vue3 + vite + Ts + pinia + 实战 + 源码 + electron</strong></p>
<p><img src="Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20240108191138575.png" alt="image-20240108191138575"></p>

</body>
</html>