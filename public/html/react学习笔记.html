<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="http://139.159.253.241:3000/stylesheets/github.css">
    <title>Document</title>
</head>
<body>
    <p>[TOC]</p>
<h1>知乎日报Demo</h1>
<h2>前期准备</h2>
<h3>配置less：less/less-loader@8</h3>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231115201930970.png" alt="image-20231115201930970"></p>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231115202312731.png" alt="image-20231115202312731"></p>
<h3>配置别名 @ 代表 src 目录「选配」</h3>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231115202454147.png" alt="image-20231115202454147"></p>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231115203026298.png" alt="image-20231115203026298"></p>
<h2>配置好REM响应式布局 &amp;&amp; 样式处理</h2>
<p>​    lib-flexible 设置REM和PX换算比例的
​    + 根据设备宽度的变化自动计算
​        + html.style.fontSize=设备的宽度/10+&#39;px&#39;;
​        + 750设计稿中  1REM=75PX : 初始换算比例
​        + 375设备上 1REM=37.5PX</p>
<p>​       postcss-pxtorem 可以把我们写的PX单位，按照当时的换算比例，自动转换为REM，不需要我们自己算了</p>
<p>@1 假设设计稿还是750的，我们测出来多少尺寸，我们写样式的时候，就写多少尺寸，并且不需要手动转换为REM「我们在webpack中，针对postcss-pxtorem做配置，让插件帮我们自动转换」</p>
<pre><code class="language-js">const px2rem = require(&#39;postcss-pxtorem&#39;);
px2rem({
    rootValue: 75, // 基于lib-flexible,750设计稿,就会设置为1REM=75PX；此时在webpack编译的时候，我们也需要让px2rem插件，按照1REM=75PX，把我们测出来的并且编写的PX样式，自动转换为REM；
    propList: [&#39;*&#39;] // 对所有文件中的样式都生效{AntdMobile组件库中的样式}
})
</code></pre>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231116155447208.png" alt="image-20231116155447208"></p>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231116155401775.png" alt="image-20231116155401775"></p>
<p>@2 在入口中，我们导入lib-flexible，确保在不同的设备上，可以等比例的对REM的换算比例进行缩放！！
@3 手动设置：设备宽度超过750PX后，不再继续放大！！</p>
<pre><code class="language-js">/* 处理最大宽度 */
(function () {
  const handleMax = function handleMax() {
    let root = document.getElementById(&quot;root&quot;);
    let html = document.documentElement;
    let deviceW = html.clientWidth;
    root.style.maxWidth = &quot;750px&quot;;
    if (deviceW &gt;= 750) {
      html.style.fontSize = 75 + &quot;px&quot;;
    }
  };
  handleMax();
})();
</code></pre>
<p><code>手动实现rem和px换算:</code></p>
<pre><code class="language-js">/* 计算当前设备下，REM和PX的换算比例 */
(function () {
    const computed = () =&gt; {
        let html = document.documentElement,
            deviceW = html.clientWidth, //单位是 &#39;px&#39;
            designW = 750;
        // console.log(&quot;deviceW: &quot;, deviceW)
        if (deviceW &gt;= designW) {
            html.style.fontSize = &#39;100px&#39;;
            return;
        }
        // 750下是100，那么现在需要求出deviceW下的缩放比例
        let ratio = deviceW * 100 / designW;
        html.style.fontSize = ratio + &#39;px&#39;;
    };
    computed();
    window.addEventListener(&#39;resize&#39;,
                            computed
                            // ()=&gt;{                
                            //     console.log(&quot;clientWidth: &quot;, document.documentElement.clientWidth)
                            //     return computed
                            // }
                           );
})();
</code></pre>
<h2>本地端口代理，处理跨域请求</h2>
<p><code>./src/setupProxy.js</code></p>
<pre><code class="language-js">const { createProxyMiddleware } = require(&#39;http-proxy-middleware&#39;);
module.exports = function (app) {
    app.use(
        createProxyMiddleware(&quot;/api&quot;, {
            target: &quot;http://127.0.0.1:7100&quot;,
            // target: &quot;139.159.253.241:7100&quot;,
            changeOrigin: true,
            ws: true,
            pathRewrite: { &quot;^/api&quot;: &quot;&quot; }
        })
    );
};
</code></pre>
<p>具体来说，这个配置的主要选项如下：</p>
<ul>
<li><code>createProxyMiddleware(&quot;/api&quot;, ...)</code>: 表示对以 <code>/api</code> 开头的请求进行代理。</li>
<li><code>target: &quot;http://127.0.0.1:7100&quot;</code>: 将请求代理到目标地址 <code>http://127.0.0.1:7100</code>。</li>
<li><code>changeOrigin: true</code>: 设置 <code>changeOrigin</code> 为 <code>true</code>，以便正确地处理跨域请求。</li>
<li><code>ws: true</code>: 允许 WebSocket 请求。</li>
<li><code>pathRewrite: { &quot;^/api&quot;: &quot;&quot; }</code>: 对路径进行重写，将请求中的 <code>/api</code> 前缀移除，以确保目标服务器能够正确解析请求路径。</li>
</ul>
<p>这样，当你在前端应用中发起以 <code>/api</code> 开头的请求时，它会被代理到 <code>http://127.0.0.1:7100</code>，从而避免了跨域问题。这在开发阶段尤其有用，因为通常在本地开发时前端和后端服务运行在不同的端口上，可能导致跨域请求问题。代理配置帮助你在开发时更容易地调试和测试应用。</p>
<ul>
<li><p><strong>该写法是约定俗成的</strong></p>
<p>​	<code>react-scripts</code> 的开发服务器会自动检测项目根目录下是否存在这个文件，并在需要时应用其中的代理配置。这种约定俗成的写法使得开发者能够方便地配置代理，解决开发过程中的跨域问题，而无需手动配置复杂的代理规则。</p>
<p>这种约定的好处在于，开发者能够专注于业务逻辑而无需过多关心底层的配置细节。这也是许多现代开发框架和工具的设计原则之一，通过约定来提高开发效率和降低配置的复杂性。</p>
</li>
<li><p>文件为什么会生效</p>
<p>​	在 Create React App 项目中，<code>setupProxy.js</code> 文件的生效是由 <code>react-scripts</code> 提供的工具链支持的。<code>react-scripts</code> 是 Create React App 中的一个关键依赖，它负责处理项目的构建、启动本地开发服务器等任务。</p>
<p><code>setupProxy.js</code> 文件会在启动开发服务器时被自动加载，无需手动引入。当你使用 <code>npm start</code> 启动本地开发服务器时，<code>react-scripts</code> 会检测项目根目录下是否存在 <code>setupProxy.js</code> 文件，并在需要时应用其中的代理配置。</p>
<p>这意味着，只要符合 Create React App 的约定，你无需手动引入 <code>setupProxy.js</code> 文件或在其他文件中显式使用它。代理配置会自动应用于启动的开发服务器，确保前端应用能够正确地代理请求到后端服务，解决跨域问题。</p>
</li>
<li><p><strong>app</strong></p>
<p>​	在这个函数中，<code>app</code> 是 Express 应用程序的实例。在 Create React App 中，用于启动开发服务器的 <code>react-scripts</code> 使用了 Express 来处理和代理网络请求。</p>
<p>在这个特定的上下文中，<code>app.use(...)</code> 用于将中间件添加到 Express 应用程序的处理管道中。在这里，添加的中间件是由 <code>http-proxy-middleware</code> 提供的代理中间件，用于将以 <code>/api</code> 开头的请求代理到目标地址。</p>
<p>所以，简而言之，这个函数接受一个 Express 应用程序实例作为参数，然后通过 <code>app.use(...)</code> 将代理中间件添加到应用程序中。这个代理中间件的作用是在开发阶段将以 <code>/api</code> 开头的请求代理到指定的后端服务地址。</p>
</li>
</ul>
<h2>路由搭建</h2>
<p>其实就是由对象组成的数组，这里需要注意的就是</p>
<p>​	+应用了React的懒加载 <strong>Lazy</strong> 	<code>import {lazy} from &quot;react&quot;</code></p>
<pre><code class="language-js">{
    path: &#39;/detail/:id&#39;,
    name: &#39;detail&#39;,
    component: lazy(()=&gt;import(&#39;../views/Detail&#39;)),
    meta:{
        title:&#39;新闻详情-知乎日报&#39;
    }
}
</code></pre>
<p>​	+路由传参时，在跳转时的链接不需要加上 ( : ), 形式为<code>/detail/5625</code>,	但是在编写路由规则时需要<code>/detail/:id</code></p>
<h3>遮罩层</h3>
<p>在编写路由组件时，使用了<code>antd-mobile</code>的加载中遮罩层，所以使用了Suspense,以及使用<code>antd-mobile</code>来搭建Loading模块：</p>
<pre><code class="language-jsx">fallback={&lt;Mask visible={true} opacity=&quot;thick&quot;&gt;
            &lt;DotLoading color=&quot;white&quot;&gt;&lt;/DotLoading&gt;
        &lt;/Mask&gt;}
</code></pre>
<p>使用<Routes>标签包裹<Route>:
由路由规则数组生成：</p>
<pre><code class="language-jsx">export default function RouterView() {
  return (
    &lt;Suspense fallback={&lt;Mask visible={true} opacity=&quot;thick&quot;&gt;
        &lt;DotLoading color=&quot;white&quot;&gt;&lt;/DotLoading&gt;
    &lt;/Mask&gt;}&gt;
      &lt;Routes&gt;
        {routes.map((item) =&gt; {
          let { path, name } = item;
          return (
            &lt;Route
              key={name}
              path={path}
              element={&lt;Element {...item} /&gt;}
            &gt;&lt;/Route&gt;
          );
        })}
      &lt;/Routes&gt;
    &lt;/Suspense&gt;
  );
}
</code></pre>
<h3>二次封装路由组件</h3>
<p>为了在路由组件中更好地完成业务，选择加一层Element组件，在展示前再做一层处理</p>
<p>使用函数<code>hook</code>传参：</p>
<ul>
<li>下面的代码只是粗略版本，后面随着业务功能的增加会进一步完善</li>
</ul>
<pre><code class="language-jsx">// 统一路由配置
const Element = function Element(props) {
  const { path, name, component: Component, meta } = props;
  let { title = &quot;知乎日报-WebAPP&quot; } = meta || {};
  document.title = title;
  const navigate = useNavigate();
  const location = useLocation();
  const parms = useParams();
  const [usp] = useSearchParams();

  return (
    &lt;Component
      navigate={navigate}
      location={location}
      parms={parms}
      usp={usp}
    /&gt;
  );
};
</code></pre>
<h2>登录态校验--业务逻辑</h2>
<p>​		在整个路由跳转的流程中，有些路由跳转前是无需鉴权的，比如<code>/detail</code>,<code>/login</code>但是当访问<code>/personal</code>,<code>/update</code>等就必须要判断当前是否登录。</p>
<h3>判断当前要跳转的路由是否需要登录态校验</h3>
<p>新建方法<code>isCheckLogin</code>以判断当前要跳转的路由是否需要登录态校验:</p>
<pre><code class="language-js">// 登录态校验 判断当前跳转路由是否需要登录态校验
// redux中有没有个人信息且要跳转的路径是需要登录态校验的路由则需要鉴权
const isCheckLogin = (path) =&gt; {
  let {
    base: { info },
  } = store.getState();
  let checkList = [&quot;/personal&quot;, &quot;/update&quot;, &quot;/store&quot;];
  return !info &amp;&amp; checkList.includes(path);
};

let isShow = isCheckLogin(path);
</code></pre>
<p>如果<code>isShow</code>为true，则需要登录态校验，否则正常显示路由，这套逻辑在二次封装的路由组件中的<code>useEffect</code>中完成，且包装在自执行函数里。</p>
<ul>
<li><p><code>isShow</code>为true，先异步同步当前redux中的信息，如果没有个人信息，则<code>Toast--显示未登录</code>，然后跳转到登录页并通过<code>path</code>将路由信息携带过去，之后登录页登陆成功后再次跳转到该路由，这套逻辑做完记得return</p>
<p>有个人信息则派发action,同步，这里设置了一个<code>let [_, setRandom] = useState(0);</code>,每次做完这逻辑<code>setRandom(+new Date());</code>以更新页面</p>
</li>
<li><p><code>isShow</code>为false则直接return</p>
</li>
</ul>
<h2>收藏功能的逻辑</h2>
<p>​		逻辑概述： 在<code>/detail</code>页面,需要根据用户是否收藏该文章来决定星标是否高亮，同时在点击星标后要 <strong>收藏/取消收藏</strong> 该文章。</p>
<p>​		在detail页面挂载后，先判断个人信息是否存在，不存在则派发请求，更新redux, 存在个人信息且收藏列表不存在则派发任务同步收藏列表。</p>
<ul>
<li><p>判断当前文章是否收藏</p>
<pre><code class="language-js">// 只有当文章id发生变化或者收藏列表发送变化才更新isStore
let isStore = useMemo(() =&gt; {
    if (!storeList) return false;
    return storeList.some((item) =&gt; {
      return +item.news.id === +params.id;
    });
  }, [storeList, params]);
</code></pre>
</li>
<li><p>收藏星标功能  (异步函数)  ：</p>
<ul>
<li>先判断有无用户信息，没有则提示未登录并跳转到登录页</li>
<li>当前文章已收藏。找到文章的收藏id,向后端发请求删除该文章，并根据返回的code判断是否删除成功，再将redux中的该文章也删除，之后return</li>
<li>当前文章未收藏，同上，向后端发请求并派发请求收藏该文章，之后派发action,向后端同步收藏列表</li>
</ul>
</li>
</ul>
<h2>搭建Home页面</h2>
<p><code>tips</code>	: 注意CSS选择器的权重导致的样式不生效问题。</p>
<h3>jsx导入静态图片资源</h3>
<p><code>导入静态资源图片不生效问题</code>	:经过webpack打包后，项目的结构目录是会发生变化的，相对地址是大概率找不到图片的，不过CSS中是可以找到的，这个webpack打包的时候会处理的</p>
<p>对于jsx的静态资源图片：
    + 服务器静态资源地址，即绝对地址</p>
<ul>
<li>ESModule获取文件</li>
</ul>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231124145145682.png" alt="image-20231124145145682"></p>
<img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231124145202208.png" alt="image-20231124145202208"  />

<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231124145232819.png" alt="image-20231124145232819"></p>
<pre><code class="language-jsx">//服务器静态资源地址
export const IMGADRESS = &#39;http://139.159.253.241/images/%E5%A3%81%E7%BA%B8/%E8%90%A7%E5%AE%B9%E9%B1%BC&amp;%E6%B2%88%E5%B9%BC%E6%A5%9A/IMG_026.jpg&#39;

//服务获取静态资源文件
import { IMGADRESS } from &quot;../../constant&quot;;
//ESModule获取文件
import img from &quot;../../assets/images/SYC_1.jpg&quot;;

&lt;img src={`${IMGADRESS}`} alt=&quot;&quot;&gt;&lt;/img&gt;
&lt;img src={img} alt=&quot;&quot;&gt;&lt;/img&gt;
</code></pre>
<p>骨架屏，轮播图使用<code>antd-mobile</code>搭建</p>
<p>轮播图使用了<code>antd-mobile</code>的<Image>组件实现懒加载：</p>
<pre><code class="language-jsx">&lt;Image src={image} lazy&gt;&lt;/Image&gt;
</code></pre>
<h3>判断元素触底</h3>
<p>关于Loading more模块，如何判断元素触底并触发更新新闻的方法：</p>
<p>通过<code>loadMore = useRef()</code>拿到底部元素实例对象</p>
<pre><code class="language-js">useEffect(() =&gt; {
    let ob = new IntersectionObserver(async (changes) =&gt; {
        // console.log(&quot;Loading More&quot;);
        let { isIntersecting } = changes[0];
        if (isIntersecting) {
            // 加载更多按钮出现在视口中，也就是[触底了]
            try {
                let time = newsList[newsList.length - 1][&quot;date&quot;];
                await api.queryNewsBefore(time).then((data)=&gt;{
                    let res = data.data
                    newsList.push(res);
                    setNewsList([...newsList]);
                });
            } catch (_) {}
        }
    });
    let loadMoreBox = loadMore.current;
    ob.observe(loadMore.current);
    // 在组件销毁时执行, 手动销毁监视器
    return () =&gt; {
        ob.unobserve(loadMoreBox);
        ob = null;
    };
}, []);
</code></pre>
<p>对于元素的控制显示与隐藏：</p>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231123203207615.png" alt="image-20231123203207615"></p>
<h2>搭建Detail页面</h2>
<p>该页面的内容和css都是由请求获取的，现在问题就是如何在正确的时机将这些静态资源正确部署在页面上正常显示。</p>
<h3>两个任务在组件挂载后并行执行</h3>
<p><strong>想让两个任务并行执行：</strong> <code>useEffect</code>执行并行任务，如果在同一个组件中使用了两个 <code>useEffect</code>，它们是并行执行的，而不是同步执行的。</p>
<ol>
<li><strong>同步（Synchronous）：</strong><ul>
<li>在同步执行中，任务是按照顺序一个接一个地执行的，前一个任务完成后才能执行下一个任务。</li>
<li>执行过程是阻塞的，即一个任务的执行会阻止后续任务的开始。</li>
<li>这种方式确保了任务的有序性，但可能导致程序在等待某些操作完成时出现阻塞。</li>
</ul>
</li>
<li><strong>并行（Parallel）：</strong><ul>
<li>在并行执行中，多个任务可以同时执行，它们之间是独立的。</li>
<li>执行过程是非阻塞的，即一个任务的执行不会妨碍其他任务的开始和执行。</li>
<li>这种方式可以提高系统的性能和效率，特别是在多核系统中，多个任务可以在不同核心上同时执行。</li>
</ul>
</li>
</ol>
<h3>插入html代码</h3>
<pre><code class="language-html">&lt;div
    className=&quot;content&quot;
    dangerouslySetInnerHTML={{ __html: info.body }}
&gt;&lt;/div&gt;
</code></pre>
<p>通过<code>useEffect</code>在组件挂载后获取到所需的静态资源后：</p>
<pre><code class="language-jsx">useEffect(() =&gt; {
    api.queryNewsInfo(parms.id).then((data) =&gt; {
        flushSync(() =&gt; {
            //更新状态
            setInfo(data.data);
            // 处理css
            handleStyle(data.data);
        });
        handleImage(data.data);
    });
    return () =&gt; {
        // 退出页面后移除添加的Link标签，防止污染其他页面的样式
        if (link) document.head.removeChild(link);
    };
}, []);
</code></pre>
<h3>flushSync处理顶部图片获取不到HTML节点</h3>
<p>在这里用到了<code>flushSync</code>,因为对于</p>
<pre><code class="language-js">setInfo(data.data);
handleStyle(data.data);
handleImage(data.data);
</code></pre>
<p>来说，是有一个先后顺序的，不然在handleImage中还没有节点imgPlaceHolder，就会出现插入图片失败的情况所以使用flushSync强制刷新页面</p>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231129104902391.png" alt="image-20231129104902391"></p>
<p><code>handleStyle</code>中处理CSS:</p>
<pre><code class="language-js">const handleStyle = (data) =&gt; {
    let css = data.css;
    // 返回的css是在一个数组里，通常用第一个
    if (!Array.isArray(css)) return;
    css = css[0];
    link = document.createElement(&quot;link&quot;);
    link.rel = &quot;stylesheet&quot;;
    link.href = css;
    document.head.appendChild(link);
};
</code></pre>
<p><code>handleImage</code>处理标题图片：</p>
<pre><code class="language-js">  const handleImage = (data) =&gt; {
    let imgPlaceHolder = document.querySelector(&quot;.img-place-holder&quot;);
    let headline = document.querySelector(&quot;.headline&quot;);
    if (!imgPlaceHolder) return;
    let imgContainer = new Image();
    imgContainer.src = data.image;
    imgContainer.onload = () =&gt; {
      imgPlaceHolder.appendChild(imgContainer);
    };
    imgContainer.onerror = () =&gt; {
      let parent = imgPlaceHolder.parentNode;
      parent.parentNode.removeChild(parent);
    };
    // 添加标题
    let title = document.createElement(&quot;div&quot;);
    title.innerHTML = `${data.title}`;
    // 添加样式
    title.style.color = &quot;#EEE&quot;;
    headline.style.position = &quot;relative&quot;;
    title.style.position = &quot;absolute&quot;;
    title.style.margin = &quot;0 10px 0 10px&quot;;
    title.style.fontSize = &quot;24px&quot;;
    title.style.fontFamily = &quot;Simsun&quot;;
    title.style.fontWeight = &quot;200&quot;;
    title.style.bottom = &quot;10px&quot;;
    title.style.letterSpacing = &quot;2px&quot;;
    // 将元素添加到页面的某个容器中
    headline.appendChild(title);
  };
</code></pre>
<h2>二次封装antd的Button组件</h2>
<p>在封装的组件内部内置loading状态</p>
<pre><code class="language-jsx">export default function ButtonAgain(props) {
    // 获取传递过来的参数
    let options = {...props};
    // 结构出文字和点击事件
    let {children, onClick: handle} = options;    
    delete options.children;
    // 删除传递的onClick事件，二次封装到自己的逻辑里配合内置的loading状态使用
    delete options.onClick

    // 内置loading状态
    let [loading, setLoading] = useState(false);
    //二次封装onClick事件
    const onclickHandle = async () =&gt; {
        setLoading(true);
        try{
            await handle();
        }catch(_){}
        setLoading(false)
    }
    //将onClick事件替换为二次封装后的
    if (handle) {
        options.onClick = onclickHandle;
    }

    return (
        &lt;&gt;
        // 将各项配置赋给antd组件
        &lt;Button {...options} loading={loading}&gt;
            {children}
        &lt;/Button&gt;
        &lt;/&gt;
    );
}
</code></pre>
<p>封装后使用方法差不多：</p>
<pre><code class="language-jsx">&lt;ButtonAgain color=&quot;primary&quot; type=&quot;submit&quot; onClick={submit}&gt;
    提交
&lt;/ButtonAgain&gt;
</code></pre>
<h2>搭建Login页面</h2>
<p><code>tips</code>	: 马德，珠峰给的express后端没加解析请求体的中间件，req.body一直为空对象</p>
<h3>表单校验</h3>
<p>首先是表单校验：</p>
<p>手机号和验证码都有自己的校验规则，</p>
<ul>
<li>发送验证码时要校验手机号是否合法</li>
<li>提交表单时也要验证手机号和验证码是否都合法</li>
</ul>
<p>可以获取到表单实例后通过<code>formIns.validateFields([&quot;phone&quot;])</code>校验，不加[]就是全部校验，同时在jsx的antd组件中加上：</p>
<pre><code class="language-jsx">&lt;Form.Item
    name=&quot;phone&quot;
    label=&quot;手机号&quot;
    rules={[{ validator: validate.phone }]}
    &gt;
</code></pre>
<p>validator是自己的自定义校验规则：</p>
<pre><code class="language-js">/* 自定义表单校验规则 */
const validate = {
  phone(_, value) {
    value = value.trim();
    let reg = /^(?:(?:\+|00)86)?1\d{10}$/;
    if (value.length === 0) return Promise.reject(new Error(&quot;手机号是必填项!&quot;));
    if (!reg.test(value)) return Promise.reject(new Error(&quot;手机号格式有误!&quot;));
    return Promise.resolve();
  },
  code(_, value) {
    value = value.trim();
    let reg = /^\d{6}$/;
    if (value.length === 0) return Promise.reject(new Error(&quot;验证码是必填项!&quot;));
    if (!reg.test(value)) return Promise.reject(new Error(&quot;验证码格式有误!&quot;));
    return Promise.resolve();
  },
};
</code></pre>
<p>或者可以通过</p>
<pre><code class="language-js">rules = {[
    {required: true, message: &quot;验证码是必填项&quot;},
    {pattern: /^\d{6}$/, message: &quot;验证码格式错误&quot;}
]}
</code></pre>
<p>使用内置校验规则</p>
<h3>发送验证码按钮</h3>
<p>校验手机码成功后，发送请求，返回的code !== 0 则使用<code>Taost</code>给出提示：</p>
<pre><code class="language-js">if (+code !== 0) {
    Toast.show({
        icon: &quot;fail&quot;,
        content: &quot;发送失败&quot;,
    });
    return;
}
</code></pre>
<p>code==0,即请求验证码成功，则将按钮<code>setDisabled(true);</code>设为不可用，并开启定时器，在规定时间内用户不可再次点，完成防抖功能：</p>
<pre><code class="language-js">  let timer = null;
  let num = 3;
  const countDown = () =&gt; {
    num--;
    if (num === 0) {
      clearInterval(timer);
      timer = null;
      setSendText(`发送验证码`);
      setDisabled(false);
      return; // 不加return就会显示 0s后重发
    }
    setSendText(`${num}s后重发`);
  };
</code></pre>
<p>但也要注意在组件销毁时清除定时器,在<code>useEffect</code>中返回一个清除定时器的逻辑：</p>
<pre><code class="language-js">  useEffect(() =&gt; {
    return () =&gt; {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
    };
  }, []);
</code></pre>
<h3>提交表单按钮</h3>
<p>校验phone和code是否合法后，带着验证码和手机号发送请求，</p>
<ul>
<li>返回的code !==0 则失败，使用<code>Taost</code>提示一下并将验证码置空</li>
<li>code == 0为成功，则返回token和code,下一步就是token存在localStorage，个人信息存储在redux,并<code>Taost</code>提示登录成功，那么登录成功后，跳转到何处？这个由<code>useSearchParams</code>获取到的参数usp决定，这表示用户由由哪个页面跳转到登录页的，那么登陆成功后就返回到该页面，如果没有就直接<code>navigate(-1)</code></li>
</ul>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231129145641075.png" alt="image-20231129145641075"></p>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231129160349614.png" alt="image-20231129160349614"></p>
<h2>组件缓存</h2>
<ul>
<li><strong>了解关于React组件缓存的思路</strong></li>
</ul>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231204110410369.png" alt="image-20231204110410369"></p>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231204104524300.png" alt="image-20231204104524300"></p>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231204104858535.png" alt="image-20231204104858535"></p>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231204105931728.png" alt="image-20231204105931728"></p>
<h2>修改个人信息和图片</h2>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231204111208308.png" alt="image-20231204111208308"><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231204133246705.png" alt="image-20231204133246705"><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231204133651116.png" alt="image-20231204133651116"><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231204134752810.png" alt="image-20231204134752810"></p>
<p>antd-mobile的<code>ImageUploader</code>是用不了，在的项目中报错，所以采用了<code>antd</code>的Upload</p>
<p>对于修改个人信息的图片业务，需要注意的有：</p>
<ul>
<li>上传图片前校验图片是否符合要求，比如大小</li>
<li>上传成功后同步redux</li>
<li>提交按钮先做表单校验，这里的话是图片是否上传，昵称一栏是否为空<code>username.trim() === &quot;&quot;</code>,之后带着图片发送请求，成功后同步redux,	<strong>注意，这里是异步操作</strong>	修改成功后给与相关提示信息并跳转路由至个人中心页面</li>
</ul>
<p>额外知识点：文件长传的格式</p>
<pre><code class="language-js">// 图片上传「要求FormData格式」
const upload = (file) =&gt; {
    let fm = new FormData();
    fm.append(&#39;file&#39;, file);
    return http.post(&#39;/api/upload&#39;, fm);
};
</code></pre>
<h2>redux</h2>
<h3>redux知识点简单回顾</h3>
<ul>
<li><p>对于Action的types，为了防止出现代码编写错误，最好在./store目录下新建action-types.js文件，将types常量放进去，后面通过module形式引入</p>
<pre><code class="language-js">import * as TYPES from &quot;../action-types&quot;;
</code></pre>
</li>
<li><p>创建Action,其实就是一个对象，里面有返回各种Action的函数，每个模块的Action可以分开写，最后通过./action/index.js将之合并.</p>
</li>
<li><p>创建redux,其实就是一个函数，但是必须是一个 <strong>纯函数</strong> ，它接收两个参数(state = initial, action)，initial作为初始状态，通过action的不同type来选择对state的不同处理</p>
<pre><code class="language-js">export default function baseReducer(state = initial, action){
    state = _.clone(state)
    switch (action.type){
        case TYPES.BASE_INFO:
            state.info = action.info;
            break;
        default:
    }
    return state;
};
</code></pre>
<p>最后对于不同模块的redux,可以选择进行合并，这里使用了<code>redux</code>的api: <code>combineReducers</code></p>
<pre><code class="language-js">// 合并reducer
const reducer = combineReducers({
    base: baseReducer,
    store: storeReducer
})

export default reducer;
</code></pre>
</li>
<li><p>最后是store容器，这个一般放在./store/index.js，在此过程使用<code>createStore</code> API，同时使用中间件加强redux，还可以根据开发环境动态选择中间件</p>
<pre><code class="language-js">import { createStore, applyMiddleware } from &#39;redux&#39;
import reduxLogger from &#39;redux-logger&#39;
import reduxThunk from &#39;redux-thunk&#39;
import reduxPromise from &#39;redux-promise&#39;
import reducer from &#39;./reducer/index&#39;

let middleware = [reduxThunk, reduxPromise];
let env = process.env.NODE_ENV;
if(env === &#39;development&#39;){
    middleware.push(reduxLogger);
}

// 创建store容器
const store = createStore(
    reducer,
    applyMiddleware(...middleware)
);

export default store;
</code></pre>
</li>
<li><p>使用store的步骤</p>
<ul>
<li><p>根目录index.js</p>
<pre><code class="language-jsx">//Redux
import { Provider} from &#39;react-redux&#39;
import store from &#39;./store/index&#39;

root.render(
    &lt;Provider store={store}&gt;
        &lt;App /&gt;
    &lt;/Provider&gt;
</code></pre>
</li>
<li><p>组件中使用store,使用<code>react-redux</code>提供的<code>connect</code></p>
</li>
</ul>
</li>
</ul>
<h2>笔记-React Api</h2>
<h3>useEffect</h3>
<p>[]表示渲染后执行一次，不写代表全部监视</p>
<pre><code class="language-jsx">useEffect(() =&gt; {
    (async () =&gt; {
        try {
            api
                .queryNewsLatest()
                .then((data) =&gt; {
                // 在这里处理获取到的数据
                setToday(data.data.date);
                setBannerData(data.data.top_stories);
                newsList.push({
                    date: data.data.date,
                    stories: data.data.stories,
                });
                setNewsList([...newsList]);
            })
                .catch((error) =&gt; {
                console.error(&quot;Error:&quot;, error);
            });
        } catch (_) {}
    })();
}, []);
</code></pre>
<p>在React中，<code>useEffect</code> 中确实不允许直接使用异步函数。<code>useEffect</code> 接受的函数应该是同步的，而不是异步的。如果你想在 <code>useEffect</code> 中使用异步函数，有几种常见的做法：</p>
<ol>
<li><p><strong>使用立即执行函数：</strong></p>
<p>将异步函数包装在一个立即执行函数中。这样可以立即调用该函数，使其返回一个 Promise，而 <code>useEffect</code> 可以在后续渲染中处理这个 Promise。</p>
<pre><code>javascriptCopy codeuseEffect(() =&gt; {
  (async () =&gt; {
    // 异步逻辑
  })();
}, []);
</code></pre>
</li>
<li><p><strong>在 <code>useEffect</code> 内部定义异步函数：</strong></p>
<p>直接在 <code>useEffect</code> 内部定义一个异步函数，然后在 <code>useEffect</code> 中调用它。</p>
<pre><code>javascriptCopy codeuseEffect(() =&gt; {
  const fetchData = async () =&gt; {
    // 异步逻辑
  };

  fetchData();
}, []);
</code></pre>
<p>这种方法可以更清晰地将异步逻辑与 <code>useEffect</code> 分离。</p>
</li>
</ol>
<p>请注意，如果你在 <code>useEffect</code> 中使用异步函数，并且希望在组件卸载时取消异步操作，你可能需要使用一个标记或 <code>AbortController</code> 进行处理，以避免可能的内存泄漏或状态更新问题。</p>
<h4>执行并行任务</h4>
<p><strong>想让两个任务并行执行：</strong> <code>useEffect</code>执行并行任务，如果在同一个组件中使用了两个 <code>useEffect</code>，它们是并行执行的，而不是同步执行的。</p>
<ol>
<li><strong>同步（Synchronous）：</strong><ul>
<li>在同步执行中，任务是按照顺序一个接一个地执行的，前一个任务完成后才能执行下一个任务。</li>
<li>执行过程是阻塞的，即一个任务的执行会阻止后续任务的开始。</li>
<li>这种方式确保了任务的有序性，但可能导致程序在等待某些操作完成时出现阻塞。</li>
</ul>
</li>
<li><strong>并行（Parallel）：</strong><ul>
<li>在并行执行中，多个任务可以同时执行，它们之间是独立的。</li>
<li>执行过程是非阻塞的，即一个任务的执行不会妨碍其他任务的开始和执行。</li>
<li>这种方式可以提高系统的性能和效率，特别是在多核系统中，多个任务可以在不同核心上同时执行。</li>
</ul>
</li>
</ol>
<h3>setState</h3>
<p>不改变原状态是不会触发刷新的，对于对象数组这种数据类型，需要生成新的数据：</p>
<pre><code class="language-js">setNewsList([...newsList]);
</code></pre>
<h3>flushSync</h3>
<p><code>flushSync</code> 允许你强制 React 在提供的回调函数内同步刷新任何更新，这将确保 DOM 立即更新。</p>
<pre><code>flushSync(callback)
</code></pre>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231124194632895.png" alt="image-20231124194632895"></p>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231124195511666.png" alt="image-20231124195511666"></p>
<h3>useMemo--记忆化</h3>
<pre><code class="language-js">const cachedValue = useMemo(calculateValue, dependencies)
</code></pre>
<pre><code class="language-js">let time = useMemo(() =&gt; {
  let [, month, day] = today.match(/^\d{4}(\d{2})(\d{2})$/);
  const area = [
    &quot;零&quot;,
    ......
  ];

  return { month: area[+month] + &quot;月&quot;, day };
}, [today]);
</code></pre>
<p>​		<code>useMemo</code> 会根据 <code>today</code> 的值进行缓存。只有当 <code>today</code> 的值发生变化时，才会重新计算 <code>time</code> 的值。如果 <code>today</code> 的值没有变化，<code>useMemo</code> 将返回上一次计算的结果，而不会重新执行计算。</p>
<p>​		这样做的目的是避免在每次组件渲染时都重新计算 <code>time</code>，尤其是在 <code>today</code> 的值没有变化的情况下。这样可以提高组件的性能，避免不必要的计算开销。</p>
<h3>Ref拿到jsx实例对象的方式</h3>
<h3>redux派发action</h3>
<ul>
<li>通过 <code>connect</code> 函数连接组件时，<code>action</code>的<code>queryUserInfoAsync</code> 函数实际上会被注入到组件的 <code>props</code> 中，同时它已经被包装成了一个能够触发 Redux 的 <code>dispatch</code> 函数。因此，当在组件中通过 <code>props</code> 拿到 <code>queryUserInfoAsync</code> 并执行 <code>await queryUserInfoAsync()</code> 时，它会调用 Redux 的 <code>dispatch</code>，从而触发相应的 action，最终更新 Redux 的状态。</li>
<li>如果通过 import 形式引入 action 文件中的 <code>queryUserInfoAsync</code> 函数，然后直接调用它，它只会返回一个包含 action 对象的 Promise，并不会直接触发 Redux 的 <code>dispatch</code>。</li>
</ul>
<h3>props的类型校验</h3>
<h2>笔记-项目搭建相关技术栈</h2>
<h3>axios</h3>
<pre><code class="language-js">axios({
    method: &quot;get&quot;,
    url: &quot;http://139.159.253.241:7100/news_latest&quot;,
  }).then(function (response) {
    return response;
  })
// 通过Promise的then链式调用处理数据

// 或者通过await直接拿到数据
let data = await axios({
    method: &quot;get&quot;,
    url: &quot;http://139.159.253.241:7100/news_latest&quot;,
  }).then(function (response) {
    return response;
  })
</code></pre>
<p>​	+<code>url</code> : 注意携带<code>http://</code> 否则直接在本地端口后面加上链接了</p>
<h3>antd</h3>
<h3>express</h3>
<ul>
<li>Token</li>
</ul>
<h2>笔记-项目搭建相关前端知识</h2>
<h3>js插入HTML元素以及为其添加样式的一般步骤</h3>
<ol>
<li><p><strong>选择要插入元素的目标位置：</strong></p>
<ul>
<li>使用<code>document.getElementById</code>、<code>document.getElementsByClassName</code>、<code>document.getElementsByTagName</code>等方法获取要插入元素的父元素或目标位置。</li>
</ul>
<pre><code>javascriptCopy code
var parentElement = document.getElementById(&#39;parentElementId&#39;);
</code></pre>
</li>
<li><p><strong>创建新的HTML元素：</strong></p>
<ul>
<li>使用<code>document.createElement</code>创建要插入的新元素。</li>
</ul>
<pre><code>javascriptCopy code
var newElement = document.createElement(&#39;div&#39;);
</code></pre>
</li>
<li><p><strong>设置新元素的属性：</strong></p>
<ul>
<li>使用<code>setAttribute</code>为新元素设置属性，例如ID、类、样式等。</li>
</ul>
<pre><code>javascriptCopy codenewElement.setAttribute(&#39;id&#39;, &#39;newElementId&#39;);
newElement.setAttribute(&#39;class&#39;, &#39;newElementClass&#39;);
</code></pre>
</li>
<li><p><strong>添加文本内容（可选）：</strong></p>
<ul>
<li>使用<code>document.createTextNode</code>创建文本节点，然后将其添加到新元素中。</li>
</ul>
<pre><code>javascriptCopy codevar textNode = document.createTextNode(&#39;This is some text&#39;);
newElement.appendChild(textNode);
</code></pre>
</li>
<li><p><strong>将新元素插入到目标位置：</strong></p>
<ul>
<li>使用<code>appendChild</code>、<code>insertBefore</code>等方法将新元素插入到指定位置。</li>
</ul>
<pre><code>javascriptCopy code
parentElement.appendChild(newElement);
</code></pre>
</li>
<li><p><strong>为新元素添加样式：</strong></p>
<ul>
<li>使用<code>style</code>属性或<code>classList</code>属性为新元素添加样式。</li>
</ul>
<pre><code>javascriptCopy codenewElement.style.color = &#39;blue&#39;;
newElement.classList.add(&#39;customStyle&#39;);
</code></pre>
</li>
</ol>
<p>以上步骤可以根据具体需求进行修改和调整。这是一个基本的模板，实际应用中可能需要根据具体场景进行定制。确保在执行这些操作时，文档已完全加载，可以使用<code>DOMContentLoaded</code>事件或将脚本放在<code>&lt;/body&gt;</code>标签之前。</p>
<p>在知乎日报里，插入服务器传过来的富文本时，标题图片插入不经来，原因是插入标题图片时，内容的结构还没有在页面上，所以使用了flushSync来强制刷新任务队列</p>
<h3>async异步函数使用try...catch...的好处</h3>
<ol>
<li><p><strong>错误捕获：</strong> <code>try...catch</code>允许你捕获和处理异步函数中的错误。如果异步函数中发生错误，它不会像同步代码那样直接抛出并中断程序执行。相反，错误会被传递给异步操作的回调函数或Promise链。</p>
<pre><code>javascriptCopy codeasync function fetchData() {
  try {
    const result = await someAsyncFunction();
    console.log(result);
  } catch (error) {
    console.error(&#39;An error occurred:&#39;, error);
  }
}
</code></pre>
</li>
<li><p><strong>更好的错误追踪：</strong> 异步函数可能包含多个异步操作，这使得确定错误的来源变得更加困难。<code>try...catch</code>可以帮助你精确定位错误的发生位置，而不仅仅是知道发生在异步操作中。</p>
</li>
<li><p><strong>Graceful降级：</strong> 通过<code>try...catch</code>，你可以更优雅地处理错误情况。你可以在<code>catch</code>块中采取一些措施，例如提供默认值、显示用户友好的错误消息，或者执行一些清理操作。</p>
<pre><code>javascriptCopy codeasync function fetchData() {
  try {
    const result = await someAsyncFunction();
    console.log(result);
  } catch (error) {
    console.error(&#39;An error occurred:&#39;, error);
    // Provide a default value or handle the error gracefully
  }
}
</code></pre>
</li>
<li><p><strong>防止未处理的Promise拒绝警告：</strong> 如果在异步函数中发生错误而未使用<code>try...catch</code>块捕获错误，错误将会被当作未处理的Promise拒绝。这可能导致浏览器或Node.js发出警告，提醒你有一个未处理的Promise拒绝。</p>
<pre><code>javascriptCopy codeasync function fetchData() {
  const result = await someAsyncFunction(); // No try...catch
  console.log(result);
}
</code></pre>
</li>
</ol>
<p>总体来说，使用<code>try...catch</code>块可以提高代码的稳定性和可维护性，确保异步函数中的错误得到适当处理，而不会导致未捕获的异常中断应用程序的执行。</p>
<h3>对象的属性是函数的简写形式</h3>
<p>如果一个对象的属性是一个函数，可以省略 <code>function</code> 关键字和冒号 <code>:</code>，直接写函数的参数和主体。</p>
<ul>
<li><p><strong>eg:</strong></p>
<pre><code class="language-js">const baseAction = {
  // 异步获取登录者信息,完成派发
  queryUserInfoAsync: async function queryUserInfoAsync() {
    let info = null;
    try {
      let { code, data } = await api.queryUserTnfo;
      if (+code == 0) {
        info = data;
      }
    } catch (_) {}
    return {
      type: TYPES.BASE_INFO,
      info,
    };
  },
};
// 等价于：
const baseAction = {
  // 异步获取登录者信息,完成派发
  async queryUserInfoAsync() {
    let info = null;
    try {
      let { code, data } = await api.queryUserTnfo;
      if (+code == 0) {
        info = data;
      }
    } catch (_) {}
    return {
      type: TYPES.BASE_INFO,
      info,
    };
  },
};
</code></pre>
</li>
</ul>
<h3>一些api不允许直接传入异步函数的解决办法</h3>
<p>有些时候，我们将一个函数改写成async 异步函数后，他返回的是一个promise实例，但是这不是我们想要的，同时去掉async又会导致函数内部的await无法使用，这个时候可以选择将函数内部的await写成自执行函数形式</p>
<p>eg:</p>
<ul>
<li><p>​	</p>
<pre><code class="language-js">// 原版
let a = await b()
// 修改后
(async () =&gt; let a = await b())()
</code></pre>
</li>
</ul>
<h3>处理链式访问中间某环数据结构对不上出现报错</h3>
<p><code>tips</code> : 这个报错我觉得还是有必要的</p>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231124200143129.png" alt="image-20231124200143129"></p>
<p>在解构赋值中，如果要解构的属性不存在，会导致报错。为了避免这种情况，可以使用默认值或者在解构之前检查属性是否存在。</p>
<p>使用默认值：</p>
<pre><code class="language-js">let {news: {hint, id, images, title, url} = {}, info} = prop
</code></pre>
<h3>return的重要性</h3>
<p>业务逻辑中完成后，无论是失败还是成功，	<strong>return</strong>	务必要注意加上，尤其是一些if场景，逻辑到此结束必须要加上</p>
<h3>文件上传的相关知识</h3>
<h3>前端要掌握的http的相关知识</h3>
<h1>项目踩坑</h1>
<p><code>报错</code>： <code>Parsing error: [BABEL] F:\front-end-study\React\Project-Demo\zhihuribao\src\assets\utils.js: Using </code>babel-preset-react-app<code>requires that you specify</code>NODE_ENV<code>or</code>BABEL_ENV<code> environment variables. Valid values are &quot;development&quot;, &quot;test&quot;, and &quot;production&quot;. Instead, received: undefined. (While processing: &quot;F:\\front-end-study\\React\\Project-Demo\\zhihuribao\\node_modules\\babel-preset-react-app\\index.js&quot;)eslint</code></p>
<p><strong>解决方法：</strong></p>
<p>1&gt; 我这边不生效，但是大家都说好</p>
<pre><code class="language-json">.babelrc

{
    &quot;presets&quot;: [&quot;@babel/preset-react&quot;, [&quot;@babel/preset-env&quot;]],
    &quot;plugins&quot;: [&quot;@babel/plugin-transform-runtime&quot;]
}
</code></pre>
<p>2&gt; 有用</p>
<pre><code class="language-json">package.json中修改eslintConfig配置

&quot;eslintConfig&quot;: {
    &quot;extends&quot;: [
        &quot;react-app&quot;,
        &quot;react-app/jest&quot;
    ],
    &quot;parserOptions&quot;: {
        &quot;babelOptions&quot;: {
        &quot;presets&quot;: [
            [&quot;babel-preset-react-app&quot;,false],
            &quot;babel-preset-react-app/prod&quot;
            ]
        }
    }
},
</code></pre>
<h2>备份</h2>
<p>96 1 29 16</p>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231102191444647.png" alt="image-20231102191444647"></p>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231105143410048.png" alt="image-20231105143410048"></p>
<p><img src="react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20231105143912346.png" alt="image-20231105143912346"></p>

</body>
</html>