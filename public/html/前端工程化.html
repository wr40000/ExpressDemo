<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="http://139.159.253.241:3000/stylesheets/github.css">
    <title>Document</title>
</head>
<body>
    <h1><a href="https://www.webpackjs.com/">Webpack</a></h1>
<pre><code>尚硅谷 Webpack5 文档
https://yk2012.github.io/sgg_webpack5/
</code></pre>
<p><strong>基础配置篇</strong></p>
<p>本章节我们学会了 Webpack 基本使用，掌握了以下功能：</p>
<ol>
<li>两种开发模式</li>
</ol>
<ul>
<li>开发模式：代码能编译自动化运行</li>
<li>生产模式：代码编译优化输出</li>
</ul>
<ol>
<li>Webpack 基本功能</li>
</ol>
<ul>
<li>开发模式：可以编译 ES Module 语法</li>
<li>生产模式：可以编译 ES Module 语法，压缩 js 代码</li>
</ul>
<ol>
<li>Webpack 配置文件</li>
</ol>
<ul>
<li>5 个核心概念<ul>
<li>entry</li>
<li>output</li>
<li>loader</li>
<li>plugins</li>
<li>mode</li>
</ul>
</li>
<li>devServer 配置</li>
</ul>
<ol>
<li>Webpack 脚本指令用法</li>
</ol>
<ul>
<li><code>webpack</code> 直接打包输出</li>
<li><code>webpack serve</code> 启动开发服务器，内存编译打包没有输出</li>
</ul>
<p><strong>高级优化篇</strong></p>
<p>我们从 4 个角度对 webpack 和代码进行了优化：</p>
<ol>
<li>提升开发体验</li>
</ol>
<ul>
<li>使用 <code>Source Map</code> 让开发或上线时代码报错能有更加准确的错误提示。</li>
</ul>
<ol>
<li>提升 webpack 提升打包构建速度</li>
</ol>
<ul>
<li>使用 <code>HotModuleReplacement</code> 让开发时只重新编译打包更新变化了的代码，不变的代码使用缓存，从而使更新速度更快。</li>
<li>使用 <code>OneOf</code> 让资源文件一旦被某个 loader 处理了，就不会继续遍历了，打包速度更快。</li>
<li>使用 <code>Include/Exclude</code> 排除或只检测某些文件，处理的文件更少，速度更快。</li>
<li>使用 <code>Cache</code> 对 eslint 和 babel 处理的结果进行缓存，让第二次打包速度更快。</li>
<li>使用 <code>Thead</code> 多进程处理 eslint 和 babel 任务，速度更快。（需要注意的是，进程启动通信都有开销的，要在比较多代码处理时使用才有效果）</li>
</ul>
<ol>
<li>减少代码体积</li>
</ol>
<ul>
<li>使用 <code>Tree Shaking</code> 剔除了没有使用的多余代码，让代码体积更小。</li>
<li>使用 <code>@babel/plugin-transform-runtime</code> 插件对 babel 进行处理，让辅助代码从中引入，而不是每个文件都生成辅助代码，从而体积更小。</li>
<li>使用 <code>Image Minimizer</code> 对项目中图片进行压缩，体积更小，请求速度更快。（需要注意的是，如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。）</li>
</ul>
<ol>
<li>优化代码运行性能</li>
</ol>
<ul>
<li>使用 <code>Code Split</code> 对代码进行分割成多个 js 文件，从而使单个文件体积更小，并行加载 js 速度更快。并通过 import 动态导入语法进行按需加载，从而达到需要使用时才加载该资源，不用时不加载资源。</li>
<li>使用 <code>Preload / Prefetch</code> 对代码进行提前加载，等未来需要使用时就能直接使用，从而用户体验更好。</li>
<li>使用 <code>Network Cache</code> 能对输出资源文件进行更好的命名，将来好做缓存，从而用户体验更好。</li>
<li>使用 <code>Core-js</code> 对 js 进行兼容性处理，让我们代码能运行在低版本浏览器。</li>
<li>使用 <code>PWA</code> 能让代码离线也能访问，从而提升用户体验。</li>
</ul>
<h2>简单上手</h2>
<p><strong>安装</strong></p>
<pre><code class="language-text">npm i webpack webpack-cli -D
</code></pre>
<p><strong>-D 的作用</strong></p>
<p>在 <code>npm</code> 中，<code>-D</code> 是 <code>--save-dev</code> 的简写。这表示将安装的包添加到 <code>package.json</code> 文件的 <code>devDependencies</code> 部分，而不是 <code>dependencies</code> 部分。</p>
<pre><code>npm i webpack webpack-cli -D
</code></pre>
<p>上述命令会将 <code>webpack</code> 和 <code>webpack-cli</code> 安装为开发环境的依赖项。这意味着这些包主要用于开发、构建和测试，而不是在生产环境中运行时需要。<code>devDependencies</code> 中的包通常包含一些开发工具、测试库、构建工具等，而不是实际的运行时代码。</p>
<p>使用 <code>-D</code> 或 <code>--save-dev</code> 有助于区分开发环境和生产环境的依赖，并使得在构建和部署时可以只安装生产依赖，从而减小项目的体积。</p>
<p>如果没有配置webpack，直接执行：</p>
<pre><code class="language-js">npx webpack ./src/main.js --mode=development
或者：
npx webpack ./src/main.js --mode=production
</code></pre>
<p>二者之间的主要区别在于 webpack 的构建模式。<code>--mode</code> 参数允许你指定构建的模式，有两个选项：<code>development</code> 和 <code>production</code>。</p>
<ol>
<li>Development Mode (开发模式):<ul>
<li>会生成具有更多调试信息的输出。</li>
<li>通常会启用更多的开发工具和优化，以提高构建的速度。</li>
<li>适用于开发阶段，便于调试和追踪问题。</li>
</ul>
</li>
</ol>
<pre><code>npx webpack ./src/main.js --mode=development
</code></pre>
<ol>
<li>Production Mode (生产模式):<ul>
<li>会生成更小、更精简的输出文件，以减小文件大小。</li>
<li>启用更多的代码优化，如压缩、混淆等，以提高运行时性能。</li>
<li>适用于发布生产环境，以提供更好的性能和用户体验。</li>
</ul>
</li>
</ol>
<pre><code>npx webpack ./src/main.js --mode=production
</code></pre>
<p>在实际项目中，通常会在配置文件中定义开发和生产环境的相关配置，而不是在命令行中直接指定。这样可以更灵活地管理项目的构建配置。</p>
<p><strong>npx</strong></p>
<p><code>npx</code> 是 Node.js 包自带的一个可执行包运行工具。它允许你直接运行安装在 <code>node_modules</code> 中的可执行文件，而无需显式地引用其完整路径。在你的命令中，<code>npx webpack</code> 会查找 <code>node_modules/.bin</code> 目录中的 <code>webpack</code> 可执行文件并执行它，而不需要提前将 <code>webpack</code> 安装为全局包。</p>
<p>使用 <code>npx</code> 的一个主要优势是，它允许你在不全局安装工具的情况下使用项目本地安装的工具。这样可以避免全局命名空间污染，而且使得项目的构建工具版本更为一致。</p>
<h3>处理资源</h3>
<p>处理CSS 静态资源 字体图标等资源，都需要安装相关的 <strong>loader</strong>  或者 <strong>plugin</strong>, 使用正则表达式匹配到资源本体，再使用相关插件或者加载器进行处理</p>
<ul>
<li><p>在 Webpack 中，Loader 的顺序通常是从右到左，从下到上的。</p>
<p>以加载 <strong>less</strong> 文件为例：</p>
<pre><code class="language-js">{
    test: /\.less$/,
    use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;],
},
</code></pre>
<p>这确保了 Less 文件首先通过 <code>less-loader</code> 转换，然后通过 <code>css-loader</code> 处理生成的 CSS，最终通过 <code>style-loader</code> 将 CSS 注入到页面中。</p>
</li>
<li><p>对于较小的图片资源可以使用base64来减少请求数量</p>
<pre><code class="language-js">parser: {
          dataUrlCondition: {
            maxSize: 10 * 1024 // 小于10kb的图片会被base64处理
          }
</code></pre>
</li>
</ul>
<h4>对于资源输出的路径和命名规则：</h4>
<h5>全局规则</h5>
<pre><code class="language-js">filename: &quot;static/js/[name].js&quot;,// 入口文件打包输出资源命名方式
chunkFilename: &quot;static/js/[name].chunk.js&quot;,// 动态导入输出资源命名方式
assetModuleFilename: &quot;static/media/[name].[hash][ext]&quot;,// 图片、字体等资源命名方式（注意用hash）
</code></pre>
<p>具体来说，为什么webpack可以捕获到相关文件并设置其路径：</p>
<p><code>assetModuleFilename</code> 是 Webpack 5 中用于配置静态资源输出文件名的选项。它可以用于定义构建时输出的图片、字体等资源的文件名。这个选项会影响通过 <code>type: &quot;asset&quot;</code> 定义的模块资源。</p>
<p><code>assetModuleFilename: &quot;static/media/[name].[hash][ext]&quot;</code> 意味着图片、字体等资源会被输出到 <code>static/media/</code> 目录中，文件名包括原始名称 <code>[name]</code>、hash <code>[hash]</code> 和扩展名 <code>[ext]</code>。</p>
<p>具体而言，<code>assetModuleFilename</code> 适用于你通过 <code>asset/resource</code> 或 <code>asset/inline</code> 模块类型定义的资源。在你的配置中，对于 <code>.jpg</code>、<code>.png</code>、<code>.gif</code>、<code>.webp</code>、<code>.ttf</code>、<code>.woff</code>、<code>.woff2</code>、<code>.map4</code>、<code>.map3</code>、<code>.avi</code> 等文件类型，它们都会使用这个规则进行命名和输出。</p>
<p><code>chunkFilename</code> 主要影响通过 <code>import()</code> 动态导入的模块，或者在使用代码分割时生成的额外代码块。这些代码块通常是在运行时根据需要动态加载的，而不是在初始页面加载时就加载。</p>
<p>举个例子，如果你的应用中有一个模块使用了类似如下的动态导入语法：</p>
<pre><code class="language-javascript">import(/* webpackChunkName: &quot;my-chunk&quot; */ &quot;./my-chunk-module&quot;);
</code></pre>
<p>那么这个模块在构建时会被分割为一个独立的代码块，该代码块的输出文件名将由 <code>chunkFilename</code> 配置所定义。在这个例子中，它将被命名为 <code>my-chunk.chunk.js</code> 并输出到 <code>static/js/</code> 目录中。</p>
<p><code>filename</code> 选项配置了输出文件的名称，它影响的是入口（entry）chunk 的输出文件名。<code>filename: &quot;static/js/[name].js&quot;</code> 表示入口 chunk 的输出文件将被命名为 <code>[name].js</code>，并输出到 <code>static/js/</code> 目录中。</p>
<p>具体而言，<code>filename</code> 主要影响你在配置 <code>entry</code> 入口时所指定的文件。在你的配置中，入口文件是 <code>&quot;./src/main.js&quot;</code>，所以输出文件将是 <code>main.js</code> 并放置在 <code>static/js/</code> 目录中。</p>
<p>举个例子，如果你有多个入口文件，比如：</p>
<pre><code class="language-javascript">entry: {
  main: &quot;./src/main.js&quot;,
  app: &quot;./src/app.js&quot;
},
</code></pre>
<p>那么，对于每个入口文件，Webpack 将生成一个对应的输出文件，分别命名为 <code>main.js</code> 和 <code>app.js</code>，并将它们放置在 <code>static/js/</code> 目录中。</p>
<h4>CSS处理</h4>
<p>对于 CSS 文件和其他静态资源，输出规则主要由 <code>MiniCssExtractPlugin</code> 插件和 <code>assetModuleFilename</code> 选项控制。<code>MiniCssExtractPlugin</code> 插件被配置为将 CSS 文件输出到 <code>static/css/</code> 目录中，文件名为 <code>[name].css</code>，chunk 文件名为 <code>[name].chunk.css</code>。</p>
<pre><code class="language-js">new MiniCssExtractPlugin({
  filename: &quot;static/css/[name].css&quot;,
  chunkFilename: &quot;static/css/[name].chunk.css&quot;
}),
</code></pre>
<p>这表示CSS 文件将以 <code>[name].css</code> 的形式命名，并输出到 <code>static/css/</code> 目录中。对于动态导入的 CSS chunk，将以 <code>[name].chunk.css</code> 的形式命名，同样输出到 <code>static/css/</code> 目录中。</p>
<h4>js处理</h4>
<h5>EsLint</h5>
<p>[参考文档](<a href="https://yk2012.github.io/sgg_webpack5/base/javascript.html#eslint">处理 js 资源 | 尚硅谷 Web 前端之 Webpack5 教程 (yk2012.github.io)</a>)</p>
<h5>Babel</h5>
<p>[参考文档](<a href="https://yk2012.github.io/sgg_webpack5/base/javascript.html#eslint">处理 js 资源 | 尚硅谷 Web 前端之 Webpack5 教程 (yk2012.github.io)</a>)</p>
<ul>
<li><code>@babel/preset-env</code>: 一个智能预设，允许您使用最新的 JavaScript。</li>
<li><code>@babel/preset-react</code>：一个用来编译 React jsx 语法的预设</li>
<li><code>@babel/preset-typescript</code>：一个用来编译 TypeScript 语法的预设</li>
</ul>
<h5>HTML</h5>
<pre><code class="language-js">new HtmlWebpackPlugin({
      // 以 public/index.html 为模板创建文件
      // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源
      template: path.resolve(__dirname, &quot;../public/index.html&quot;),
    }),
</code></pre>
<h3>开发模式 &amp; 生产模式</h3>
<p><strong>开发模式</strong></p>
<pre><code class="language-js">output: {
    path: undefined, // 开发模式没有输出，不需要指定输出目录
        filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中
            // clean: true, // 开发模式没有输出，不需要清空输出结果
},

    // 其他省略
    devServer: {
        host: &quot;localhost&quot;, // 启动服务器域名
            port: &quot;3000&quot;, // 启动服务器端口号
                open: true, // 是否自动打开浏览器
    },
        mode: &quot;development&quot;,  
</code></pre>
<p><strong>生产模式</strong></p>
<pre><code class="language-js">output: {
    path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出
        filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中
            clean: true,
},
    // devServer: {
    //   host: &quot;localhost&quot;, // 启动服务器域名
    //   port: &quot;3000&quot;, // 启动服务器端口号
    //   open: true, // 是否自动打开浏览器
    // },
    mode: &quot;production&quot;,
</code></pre>
<p><strong>配置运行命令</strong></p>
<pre><code class="language-json">// package.json
{
  // 其他省略
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;npm run dev&quot;,
    &quot;dev&quot;: &quot;npx webpack serve --config ./config/webpack.dev.js&quot;,
    &quot;build&quot;: &quot;npx webpack --config ./config/webpack.prod.js&quot;
  }
}
</code></pre>
<h3>CSS处理</h3>
<p><strong>提取 兼容 压缩</strong></p>
<h2>优化开发体验</h2>
<h3>SourceMap</h3>
<ul>
<li>开发模式：<code>cheap-module-source-map</code><ul>
<li>优点：打包编译速度快，只包含行映射</li>
<li>缺点：没有列映射</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">module.exports = {
  // 其他省略
  mode: &quot;development&quot;,
  devtool: &quot;cheap-module-source-map&quot;,
};
</code></pre>
<ul>
<li>生产模式：<code>source-map</code><ul>
<li>优点：包含行/列映射</li>
<li>缺点：打包编译速度更慢</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">module.exports = {
  // 其他省略
  mode: &quot;production&quot;,
  devtool: &quot;source-map&quot;,
};
</code></pre>
<h2>提升打包构建速度</h2>
<h3>HMR</h3>
<p>开发时我们修改了其中一个模块代码，Webpack 默认会将所有模块全部重新打包编译，速度很慢。</p>
<p>所以我们需要做到修改某个模块代码，就只有这个模块代码需要重新打包编译，其他模块不变，这样打包速度就能很快。</p>
<p>HotModuleReplacement（HMR/热模块替换）：在程序运行中，替换、添加或删除模块，</p>
<p><strong>而无需重新加载整个页面。</strong>       <strong>无需重新加载整个页面！！！</strong></p>
<p>当然这个需要插件支持，CSS的 <strong>style-loader</strong>帮我们做好了   JS默认没法HMR,所以也需要插件，<strong>React</strong> <strong>Vue</strong>需要相关插件支持</p>
<h4>注意</h4>
<p><strong>MD 原生 JS + webpack的项目 在使用babel的 cor-js按需引入兼容高级语法时，首次加载没有问题，只要更改了代码触发HMR, 有Promise就报错，比如：</strong></p>
<pre><code>ERROR in [eslint]
F:\Demo\webpack_learn\webpack_01\src\main.js
  45:5  error  &#39;Promise&#39; is not defined  no-undef

✖ 1 problem (1 error, 0 warnings)
</code></pre>
<p>明明首次加载就可以，最后在 <strong>.eslintrc.js</strong> 中加上：</p>
<pre><code class="language-js">module.exports = {
  // 其他配置...
  globals: {
    Promise: true,
  },
};
</code></pre>
<p>就不报错了， <strong>GPT 的解释为:</strong></p>
<p>​		这个问题可能是因为在开发服务器（webpack-dev-server）使用 HMR（热模块替换）时，有一些全局对象可能没有被正确处理，导致 ESLint 报错。具体来说，在某些情况下，全局的 <code>Promise</code> 对象在 HMR 时可能未被正确处理，从而导致 ESLint 报错 <code>&#39;Promise&#39; is not defined</code>。</p>
<p>​		解决这个问题的一种方法是在 ESLint 的配置中显式声明 <code>Promise</code> 对象。在你的 ESLint 配置文件（<code>.eslintrc.js</code> 或者其他配置文件）中添加如下配置：</p>
<pre><code class="language-js">module.exports = {
  // 其他配置...
  globals: {
    Promise: true,
  },
};
</code></pre>
<p><strong>HotModuleReplacement / 热模块替换</strong></p>
<pre><code class="language-js">module.exports = {
  // 其他省略
  devServer: {
    host: &quot;localhost&quot;, // 启动服务器域名
    port: &quot;3000&quot;, // 启动服务器端口号
    open: true, // 是否自动打开浏览器
    hot: true, // 开启HMR功能（只能用于开发环境，生产环境不需要了）
  },
};
</code></pre>
<pre><code class="language-js">// 判断是否支持HMR功能
if (module.hot) {
  module.hot.accept(&quot;./js/count.js&quot;, function (count) {
    const result1 = count(2, 1);
    console.log(result1);
  });

  module.hot.accept(&quot;./js/sum.js&quot;);
}
</code></pre>
<p>上面这样写会很麻烦，所以实际开发我们会使用其他 loader 来解决。</p>
<p>比如：<a href="https://github.com/vuejs/vue-loader">vue-loader</a>    <a href="https://github.com/gaearon/react-hot-loader">react-hot-loader</a>。</p>
<h3>OneOf</h3>
<p>打包时每个文件都会经过所有 loader 处理，虽然因为 <code>test</code> 正则原因实际没有处理上，但是都要过一遍。比较慢。</p>
<p><strong>Oneof</strong> : 顾名思义就是只能匹配上一个 loader, 剩下的就不匹配了。</p>
<p><strong>rules修改为：</strong></p>
<pre><code class="language-js">rules: [
      {
        oneOf: [
          {
            // 用来匹配 .css 结尾的文件
            test: /\.css$/,
            // use 数组里面 Loader 执行顺序是从右到左
            use: [&quot;style-loader&quot;, &quot;css-loader&quot;],
          },
          ......
          {
            test: /\.js$/,
            exclude: /node_modules/, // 排除node_modules代码不编译
            loader: &quot;babel-loader&quot;,
          },
        ],
      },
    ],
</code></pre>
<h3>Include/Exclude</h3>
<p><strong>处理node_modules</strong></p>
<ul>
<li>babel只需要处理 <strong>src</strong> 下的js文件</li>
<li>EsLint不需要处理 <strong>node_modules</strong></li>
</ul>
<pre><code class="language-js">{
    test: /\.js$/,
    // exclude: /node_modules/, // 排除node_modules代码不编译
    include: path.resolve(__dirname, &quot;../src&quot;), // 也可以用包含
    loader: &quot;babel-loader&quot;,
},
</code></pre>
<pre><code class="language-js">new ESLintWebpackPlugin({
      // 指定检查文件的根目录
      context: path.resolve(__dirname, &quot;../src&quot;),
      exclude: &quot;node_modules&quot;, // 默认值
    }),
</code></pre>
<h3>cache</h3>
<p><strong>对 Eslint 检查 和 Babel 编译结果进行缓存。</strong></p>
<p>每次打包时 js 文件都要经过 Eslint 检查 和 Babel 编译，速度比较慢。</p>
<p>我们可以缓存之前的 Eslint 检查 和 Babel 编译结果，这样第二次打包时速度就会更快了。</p>
<pre><code class="language-js">{
    test: /\.js$/,
    // exclude: /node_modules/, // 排除node_modules代码不编译
    include: path.resolve(__dirname, &quot;../src&quot;), // 也可以用包含
    loader: &quot;babel-loader&quot;,
    options: {
        cacheDirectory: true, // 开启babel编译缓存
        cacheCompression: false, // 缓存文件不要压缩
    },
},
</code></pre>
<pre><code class="language-js">new ESLintWebpackPlugin({
      // 指定检查文件的根目录
      context: path.resolve(__dirname, &quot;../src&quot;),
      exclude: &quot;node_modules&quot;, // 默认值
      cache: true, // 开启缓存
      // 缓存目录
      cacheLocation: path.resolve(
        __dirname,
        &quot;../node_modules/.cache/.eslintcache&quot;
      ),
    }),
</code></pre>
<h3>Thead</h3>
<p>多进程打包：开启电脑的多个进程同时干一件事，速度更快。</p>
<p><strong>需要注意：请仅在特别耗时的操作中使用，因为每个进程启动就有大约为 600ms 左右开销。</strong></p>
<p>当项目越来越庞大时，打包速度越来越慢，甚至于需要一个下午才能打包出来代码。这个速度是比较慢的。</p>
<p>我们想要继续提升打包速度，其实就是要提升 js 的打包速度，因为其他文件都比较少。</p>
<p>而对 js 文件处理主要就是 eslint 、babel、Terser 三个工具，所以我们要提升它们的运行速度。</p>
<p>我们可以开启多进程同时处理 js 文件，这样速度就比之前的单进程打包更快了。</p>
<pre><code>npm i thread-loader -D
npm i terser-webpack-plugin -D
</code></pre>
<pre><code class="language-js">const TerserPlugin = require(&quot;terser-webpack-plugin&quot;);
// nodejs核心模块，直接使用
const os = require(&quot;os&quot;);
// cpu核数
const threads = os.cpus().length;
</code></pre>
<p><strong>babel</strong></p>
<pre><code class="language-js">{
    test: /\.js$/,
    // exclude: /node_modules/, // 排除node_modules代码不编译
    include: path.resolve(__dirname, &quot;../src&quot;), // 也可以用包含
    use: [
        {
            loader: &quot;thread-loader&quot;, // 开启多进程
            options: {
                workers: threads, // 数量
            },
        },
        {
            loader: &quot;babel-loader&quot;,
            options: {
                cacheDirectory: true, // 开启babel编译缓存
            },
        },
    ],
},
</code></pre>
<p><strong>EsLint</strong></p>
<pre><code class="language-js">new ESLintWebpackPlugin({
      // 指定检查文件的根目录
      context: path.resolve(__dirname, &quot;../src&quot;),
      exclude: &quot;node_modules&quot;, // 默认值
      cache: true, // 开启缓存
      // 缓存目录
      cacheLocation: path.resolve(
        __dirname,
        &quot;../node_modules/.cache/.eslintcache&quot;
      ),
      threads, // 开启多进程
    }),
</code></pre>
<p>将压缩操作配置在 <strong>optimization</strong> 下：</p>
<pre><code class="language-js">optimization: {
    minimize: true,
    minimizer: [
      // css压缩也可以写到optimization.minimizer里面，效果一样的
      new CssMinimizerPlugin(),
      // 当生产模式会默认开启TerserPlugin，但是我们需要进行其他配置，就要重新写了
      new TerserPlugin({
        parallel: threads // 开启多进程
      })
    ],
  },
</code></pre>
<h2>减小代码打包体积</h2>
<h3>Tree Shaking</h3>
<p><code>Tree Shaking</code> 是一个术语，通常用于描述移除 JavaScript 中的没有使用上的代码。</p>
<p><strong>注意：它依赖 <code>ES Module</code>。</strong></p>
<p>开发时我们定义了一些工具函数库，或者引用第三方工具函数库或组件库。</p>
<p>如果没有特殊处理的话我们打包时会引入整个库，但是实际上可能我们可能只用上极小部分的功能。</p>
<p>这样将整个库都打包进来，体积就太大了。</p>
<p><strong>Webpack 已经默认开启了这个功能，无需其他配置。</strong></p>
<h3>Babel</h3>
<p>Babel 为编译的每个文件都插入了辅助代码，使代码体积过大！</p>
<p>Babel 对一些公共方法使用了非常小的辅助代码，比如 <code>_extend</code>。默认情况下会被添加到每一个需要它的文件中。</p>
<p>你可以将这些辅助代码作为一个独立模块，来避免重复引入。</p>
<p><code>@babel/plugin-transform-runtime</code>: 禁用了 Babel 自动对每个文件的 runtime 注入，而是引入 <code>@babel/plugin-transform-runtime</code> 并且使所有辅助代码从这里引用。</p>
<pre><code>npm i @babel/plugin-transform-runtime -D
</code></pre>
<pre><code class="language-js">{
    test: /\.js$/,
        // exclude: /node_modules/, // 排除node_modules代码不编译
        include: path.resolve(__dirname, &quot;../src&quot;), // 也可以用包含
            use: [
                {
                    loader: &quot;thread-loader&quot;, // 开启多进程
                    options: {
                        workers: threads, // 数量
                    },
                },
                {
                    loader: &quot;babel-loader&quot;,
                    options: {
                        cacheDirectory: true, // 开启babel编译缓存
                        cacheCompression: false, // 缓存文件不要压缩
                        plugins: [&quot;@babel/plugin-transform-runtime&quot;], // 减少代码体积
                    },
                },
            ],
},
</code></pre>
<h3>Image Minimizer</h3>
<p>见尚硅谷 <strong>Webpack5</strong> 文档</p>
<p>包没装上，没试过</p>
<p>开发如果项目中引用了较多图片，那么图片体积会比较大，将来请求速度比较慢。</p>
<p>我们可以对图片进行压缩，减少图片体积。</p>
<p><strong>注意：如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。</strong></p>
<h2>优化代码运行性能</h2>
<h3>Code Split</h3>
<pre><code>https://juejin.cn/post/6994251135540264996
</code></pre>
<p><strong>代码分割</strong></p>
<p>对于多入口文件来说：</p>
<ul>
<li><p>如果多入口文件中都引用了同一份代码，我们不希望这份代码被打包到两个文件中，导致代码重复，体积更大。</p>
</li>
<li><p>我们需要提取多入口的重复代码，只打包生成一个 js 文件，其他文件引用它就好。</p>
</li>
</ul>
<p>但一般来说 <strong>Vue</strong> <strong>React</strong> 都是单页面应用，也就是只有一个入口文件   </p>
<p><strong>疑问：</strong></p>
<ul>
<li>对于单页面应用，<ul>
<li>动态导入模块会被分割  <strong>正解</strong></li>
<li>分割的是动态导入模块之间重复引用的模块也会被分割 <strong>正解</strong></li>
<li>还是说非动态导入的模块，仅仅只是多个js文件重复引用的模块也会被分割到单独的模块，:), 感觉这个应该是错误的，<strong>确实是错误的</strong> 毕竟这些js文件最终都集成到一个main.xxx.js文件了，重复的模块只会声明一次，其他调用的模块应该只会是调用，而不会重复声明，<strong>非动态导入的模块，它们只会被引入一次，不会被重复分割。</strong></li>
</ul>
</li>
</ul>
<p>配置好 splitChunks后，只要代码里有动态导入，<strong>webpack</strong> 会自动帮我们分割动态导入的模块</p>
<pre><code class="language-js">optimization: {
    // 代码分割配置
    splitChunks: {
      chunks: &quot;all&quot;, // 对所有模块都进行分割
      // 以下是默认值
      // minSize: 20000, // 分割代码最小的大小
      // minRemainingSize: 0, // 类似于minSize，最后确保提取的文件大小不能为0
      // minChunks: 1, // 至少被引用的次数，满足条件才会代码分割
      // maxAsyncRequests: 30, // 按需加载时并行加载的文件的最大数量
      // maxInitialRequests: 30, // 入口js文件最大并行请求数量
      // enforceSizeThreshold: 50000, // 超过50kb一定会单独打包（此时会忽略minRemainingSize、maxAsyncRequests、maxInitialRequests）
      // cacheGroups: { // 组，哪些模块要打包到一个组
      //   defaultVendors: { // 组名
      //     test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块
      //     priority: -10, // 权重（越大越高）
      //     reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块
      //   },
      //   default: { // 其他没有写的配置会使用上面的默认值
      //     minChunks: 2, // 这里的minChunks权重更大
      //     priority: -20,
      //     reuseExistingChunk: true, 
      //   },
      // },
  },
</code></pre>
<p>给动态导入的模块在打包后的文件命名：</p>
<pre><code class="language-js">document.getElementById(&quot;btn&quot;).onClick = function () {
  // eslint会对动态导入语法报错，需要修改eslint配置文件
  // webpackChunkName: &quot;math&quot;：这是webpack动态导入模块命名的方式
  // &quot;math&quot;将来就会作为[name]的值显示。
  import(/* webpackChunkName: &quot;math&quot; */ &quot;./js/math.js&quot;).then(({ count }) =&gt; {
    console.log(count(2, 1));
  });
};
</code></pre>
<p>动态导入下，EsLint 会飘红：</p>
<ul>
<li><pre><code>npm i eslint-plugin-import -D
</code></pre>
</li>
<li><pre><code class="language-js">// .eslintrc.js
module.exports = {
  // 继承 Eslint 规则
  extends: [&quot;eslint:recommended&quot;],
  env: {
    node: true, // 启用node中全局变量
    browser: true, // 启用浏览器中全局变量
  },
  plugins: [&quot;import&quot;], // 解决动态导入import语法报错问题 --&gt; 实际使用eslint-plugin-import的规则解决的
  parserOptions: {
    ecmaVersion: 6,
    sourceType: &quot;module&quot;,
  },
  rules: {
    &quot;no-var&quot;: 2, // 不能使用 var 定义变量
  },
};
</code></pre>
</li>
</ul>
<h4>统一命名规则</h4>
<p>入口js文件，代码分割的chunks模块js文件，静态资源文件的命名 --全局配置</p>
<pre><code class="language-js">output: {
    path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出
    filename: &quot;static/js/[name].js&quot;, // 入口文件打包输出资源命名方式
    chunkFilename: &quot;static/js/[name].chunk.js&quot;, // 动态导入输出资源命名方式
    assetModuleFilename: &quot;static/media/[name].[hash][ext]&quot;, // 图片、字体等资源命名方式（注意用hash）
    clean: true,
  },
</code></pre>
<p><strong>CSS 以及 动态导入的CSS模块</strong> 的命名单独处理</p>
<pre><code class="language-js">// 提取css成单独文件
    new MiniCssExtractPlugin({
      // 定义输出文件名和目录
      filename: &quot;static/css/[name].css&quot;,
      chunkFilename: &quot;static/css/[name].chunk.css&quot;,
    }),
</code></pre>
<h3>Preload&amp;Prefetch</h3>
<p>我们前面已经做了代码分割，同时会使用 import 动态导入语法来进行代码按需加载（我们也叫懒加载，比如路由懒加载就是这样实现的）。</p>
<p>但是加载速度还不够好，比如：是用户点击按钮时才加载这个资源的，如果资源体积很大，那么用户会感觉到明显卡顿效果。</p>
<p>我们想在浏览器空闲时间，加载后续需要使用的资源。我们就需要用上 <code>Preload</code> 或 <code>Prefetch</code> 技术。</p>
<ul>
<li>不添加插件，用户触发该资源时加载</li>
<li><strong>rel: &quot;preload&quot;</strong>    告诉浏览器立即加载资源</li>
<li><strong>rel: &#39;prefetch&#39;</strong>    告诉浏览器在空闲时才开始加载资源</li>
</ul>
<p><strong>它们共同点：</strong></p>
<ul>
<li>都只会加载资源，并不执行。</li>
<li>都有缓存。</li>
</ul>
<p>它们区别：</p>
<ul>
<li><code>Preload</code>加载优先级高，<code>Prefetch</code>加载优先级低。</li>
<li><code>Preload</code>只能加载当前页面需要使用的资源，<code>Prefetch</code>可以加载当前页面资源，也可以加载下一个页面需要使用的资源。</li>
</ul>
<p>总结：</p>
<ul>
<li>当前页面优先级高的资源用 <code>Preload</code> 加载。</li>
<li>下一个页面需要使用的资源用 <code>Prefetch</code> 加载。</li>
</ul>
<p>它们的问题：兼容性较差。</p>
<ul>
<li>我们可以去 <a href="https://caniuse.com/">Can I Useopen in new window</a> 网站查询 API 的兼容性问题。</li>
<li><code>Preload</code> 相对于 <code>Prefetch</code> 兼容性好一点。</li>
</ul>
<pre><code class="language-js">new PreloadWebpackPlugin({
    rel: &quot;preload&quot;, // preload兼容性更好
    as: &quot;script&quot;,
    // rel: &#39;prefetch&#39; // prefetch兼容性更差
})
</code></pre>
<h3>Network Cache</h3>
<p>将来开发时我们对静态资源会使用缓存来优化，这样浏览器第二次请求资源就能读取缓存了，速度很快。</p>
<p>但是这样的话就会有一个问题, 因为前后输出的文件名是一样的，都叫 main.js，一旦将来发布新版本，因为文件名没有变化导致浏览器会直接读取缓存，不会加载新资源，项目也就没法更新了。</p>
<p>所以我们从文件名入手，确保更新前后文件名不一样，这样就可以做缓存了。</p>
<p>它们都会生成一个唯一的 hash 值。</p>
<ul>
<li>fullhash（webpack4 是 hash）</li>
</ul>
<p>每次修改任何一个文件，所有文件名的 hash 至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效。</p>
<ul>
<li>chunkhash</li>
</ul>
<p>根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。我们 js 和 css 是同一个引入，会共享一个 hash 值。</p>
<ul>
<li>contenthash</li>
</ul>
<p>根据文件内容生成 hash 值，只有文件内容变化了，hash 值才会变化。所有文件 hash 值是独享且不同的。</p>
<pre><code class="language-js">output: {
    path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出
    // [contenthash:8]使用contenthash，取8位长度
    filename: &quot;static/js/[name].[contenthash:8].js&quot;, // 入口文件打包输出资源命名方式
    chunkFilename: &quot;static/js/[name].[contenthash:8].chunk.js&quot;, // 动态导入输出资源命名方式
    assetModuleFilename: &quot;static/media/[name].[hash][ext]&quot;, // 图片、字体等资源命名方式（注意用hash）
    clean: true,
  },
  
  // 提取css成单独文件
  new MiniCssExtractPlugin({
      // 定义输出文件名和目录
      filename: &quot;static/css/[name].[contenthash:8].css&quot;,
      chunkFilename: &quot;static/css/[name].[contenthash:8].chunk.css&quot;,
  }),
</code></pre>
<ul>
<li>问题：</li>
</ul>
<p>当我们修改 math.js 文件再重新打包的时候，因为 contenthash 原因，math.js 文件 hash 值发生了变化（这是正常的）。</p>
<p>但是 main.js 文件的 hash 值也发生了变化，这会导致 main.js 的缓存失效。明明我们只修改 math.js, 为什么 main.js 也会变身变化呢？</p>
<ul>
<li>原因：<ul>
<li>更新前：math.xxx.js, main.js 引用的 math.xxx.js <strong>这里的math.xxx.js是通过动态导入的模块，不经过代码分割的模块因为本身就合并在输出的主文件里，所以其改变势必会引起输出主文件的改变而导致其哈希值改变</strong></li>
<li>更新后：math.yyy.js, main.js 引用的 math.yyy.js, 文件名发生了变化，间接导致 main.js 也发生了变化</li>
</ul>
</li>
<li>解决：</li>
</ul>
<p>将 hash 值单独保管在一个 <strong>runtime</strong> 文件中。</p>
<p>我们最终输出三个文件：main、math、runtime。当 math 文件发送变化，变化的是 math 和 runtime 文件，main 不变。</p>
<p>runtime 文件只保存文件的 hash 值和它们与文件关系，整个文件体积就比较小，所以变化重新请求的代价也小。</p>
<p><strong>optimization中添加runtime配置对象</strong></p>
<pre><code class="language-js">// 提取runtime文件
    runtimeChunk: {
      name: (entrypoint) =&gt; `runtime~${entrypoint.name}`, // runtime文件命名规则
    },
</code></pre>
<h4>哈希命名和runtime的意义</h4>
<ol>
<li><strong>哈希值：</strong> 将哈希值嵌入文件名中，可以确保当文件内容发生变化时，文件名会随之变化。这样做的目的是让浏览器能够识别新的文件，并下载最新的版本，而不使用缓存的旧版本。</li>
<li><strong>runtime文件：</strong> 将模块间的依赖关系提取到runtime文件中，可以确保只有当模块的依赖关系发生变化时，runtime文件才会更新。这避免了因为一个文件的变化而导致其他有引用关系的文件也重新请求，从而提高了缓存的利用率。</li>
</ol>
<p>综合来说，这些策略有助于优化浏览器对静态资源的缓存和更新机制，提升应用的性能和用户体验。</p>
<h4>优化 <strong>runtime~xxx.js</strong></h4>
<pre><code>稀土掘金 https://juejin.cn/post/7245980207314796602
</code></pre>
<p>查看下runtime~xxx.js文件内容:</p>
<pre><code class="language-js">function a(e){return i.p+&quot;js/&quot;+({about:&quot;about&quot;}[e]||e)+&quot;.&quot;+{about:&quot;3cc6fa76&quot;}[e]+&quot;.js&quot;}f
</code></pre>
<p>发现文件很小，且就是加载chunk的依赖关系的文件。虽然每次构建后app的hash没有改变，但是runtime~xxx.js会变啊。每次重新构建上线后，浏览器每次都需要重新请求它，它的 http 耗时远大于它的执行时间了，</p>
<ul>
<li>所以建议不要将它单独拆包，而是将它内联到我们的 index.html 之中。</li>
<li>这边我们使用<code>script-ext-html-webpack-plugin</code>来实现。（也可使用<code>html-webpack-inline-source-plugin</code>，其不会删除runtime文件。）</li>
</ul>
<pre><code class="language-js">const ScriptExtHtmlWebpackPlugin = require(&#39;script-ext-html-webpack-plugin&#39;)
module.exports = {
  productionSourceMap: false,
  configureWebpack: {
    optimization: {
      runtimeChunk: true
    },
    plugins: [
      new ScriptExtHtmlWebpackPlugin({
        inline: /runtime~.+.js$/  //正则匹配runtime文件名
      })
    ]
  },
  chainWebpack: config =&gt; {
    config.plugin(&#39;preload&#39;)
      .tap(args =&gt; {
        args[0].fileBlacklist.push(/runtime~.+.js$/) //正则匹配runtime文件名，去除该文件的preload
        return args
      })
  }
}
</code></pre>
<p>打包后的 <strong>index.html</strong> 文件：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=en&gt;

&lt;head&gt;
    &lt;meta charset=utf-8&gt;
    &lt;meta http-equiv=X-UA-Compatible content=&quot;IE=edge&quot;&gt;
    &lt;meta name=viewport content=&quot;width=device-width,initial-scale=1&quot;&gt;
    &lt;link rel=icon href=/favicon.ico&gt;
    &lt;title&gt;runtime-chunk&lt;/title&gt;
    &lt;link href=/js/about.cccc71df.js rel=prefetch&gt;
    &lt;link href=/css/app.b087a504.css rel=preload as=style&gt;
    &lt;link href=/js/app.9f1ba6f7.js rel=preload as=script&gt;
    &lt;link href=/css/app.b087a504.css rel=stylesheet&gt;
&lt;/head&gt;

&lt;body&gt;&lt;noscript&gt;&lt;strong&gt;We&#39;re sorry but runtime-chunk doesn&#39;t work properly without JavaScript enabled. Please enable it
            to continue.&lt;/strong&gt;&lt;/noscript&gt;
    &lt;div id=app&gt;&lt;/div&gt;
    &lt;script&gt;(function (e) { //runtime~xxx.js的代码将会内联进该script标签里
        ...... 
        })([]);&lt;/script&gt;
    &lt;script src=/js/chunk-vendors.1e5c55d3.js&gt;&lt;/script&gt;
    &lt;script src=/js/app.9f1ba6f7.js&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>index.html中已经没有对runtime~xxx.js的引用了，而是直接将其代码写入到了index.html中，故不会在请求文件，减少http请求。</p>
<h3>Core-js</h3>
<p><strong>具体参考 [babel官网](<a href="https://babel.docschina.org/docs/babel-preset-env#corejs">@babel/preset-env · Babel (docschina.org)</a>)</strong></p>
<p><code>core-js</code> 是专门用来做 ES6 以及以上 API 的 <code>polyfill</code>。</p>
<p><code>polyfill</code>翻译过来叫做垫片/补丁。就是用社区上提供的一段代码，让我们在不兼容某些新特性的浏览器上，使用该新特性。</p>
<p>过去我们使用 babel 对 js 代码进行了兼容性处理，其中使用@babel/preset-env 智能预设来处理兼容性问题。</p>
<p>它能将 ES6 的一些语法进行编译转换，比如箭头函数、点点点运算符等。但是如果是 async 函数、promise 对象、数组的一些方法（includes）等，它没办法处理。</p>
<p>所以此时我们 js 代码仍然存在兼容性问题，一旦遇到低版本浏览器会直接报错。所以我们想要将 js 兼容性问题彻底解决</p>
<pre><code class="language-js">// 安装
// npm i @babel/eslint-parser -D

// .eslintrc.js添加 babel 解析器
module.exports = {
  // 继承 Eslint 规则
  extends: [&quot;eslint:recommended&quot;],
  parser: &quot;@babel/eslint-parser&quot;, // 支持最新的最终 ECMAScript 标准
  env: {
    node: true, // 启用node中全局变量
    browser: true, // 启用浏览器中全局变量
  },
  plugins: [&quot;import&quot;], // 解决动态导入import语法报错问题 --&gt; 实际使用eslint-plugin-import的规则解决的
  parserOptions: {
    ecmaVersion: 6, // es6
    sourceType: &quot;module&quot;, // es module
  },
  rules: {
    &quot;no-var&quot;: 2, // 不能使用 var 定义变量
  },
};
</code></pre>
<pre><code>npm i core-js
</code></pre>
<ul>
<li>手动引入： <strong>import &quot;core-js/es/promise&quot;;</strong> 打包后体积较大</li>
<li>只引入打包 promise 的 <code>polyfill</code>，打包体积更小。但是将来如果还想使用其他语法，我需要手动引入库很麻烦</li>
</ul>
<p>这里选择按需引入</p>
<ul>
<li><p>babel.config.js</p>
<pre><code class="language-js">module.exports = {
  // 智能预设：能够编译ES6语法
  presets: [
    [
      &quot;@babel/preset-env&quot;,
      // 按需加载core-js的polyfill
      { useBuiltIns: &quot;usage&quot;, corejs: { version: &quot;3&quot;, proposals: true } },
    ],
  ],
};
</code></pre>
<p>这里需要注意的是，在不加入 <strong>core-js</strong>之前，babel.config.js是下面这样的：</p>
<pre><code class="language-js">module.exports = {
  // 智能预设：能够编译ES6语法
  presets: [&quot;@babel/preset-env&quot;],
};
</code></pre>
<p>对比修改前后的代码可知，这里的改动是将 **&quot;@babel/preset-env&quot;**包装在了一个数组里，</p>
<pre><code class="language-js">[
    &quot;@babel/preset-env&quot;,
    // 按需加载core-js的polyfill
    { useBuiltIns: &quot;usage&quot;, corejs: { version: &quot;3&quot;, proposals: true } },
],
</code></pre>
<p>数组的第二项是配置选项</p>
</li>
<li><p><code>presets</code>: 用于指定一组预设，预设是一组 Babel 插件的集合，用于支持特定的语法或功能。</p>
<ul>
<li><code>[&quot;@babel/preset-env&quot;, { useBuiltIns: &quot;usage&quot;, corejs: { version: &quot;3&quot;, proposals: true } }]</code>: 这里使用了 <code>@babel/preset-env</code> 预设，它的作用是根据配置的目标环境自动确定需要的 Babel 插件，并进行相应的转译。具体配置包括：<ul>
<li><code>useBuiltIns: &quot;usage&quot;</code>: 指定使用按需加载的方式引入 <code>core-js</code> 的 polyfill。这意味着 Babel 会根据代码中实际使用的特性来引入相应的 polyfill，而不是一次性引入整个 polyfill。</li>
<li><code>corejs: { version: &quot;3&quot;, proposals: true }</code>: 指定使用的 <code>core-js</code> 版本为 3，并启用提案阶段的 ECMAScript 特性支持。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这段配置的目的是使 Babel 能够正确地编译和转译项目中的代码，以确保在目标环境中运行时不会出现语法错误或缺失特性的问题。</p>
<h3>PWA</h3>
<p>渐进式网络应用程序(progressive web application - PWA)：是一种可以提供类似于 native app(原生应用程序) 体验的 Web App 的技术。</p>
<p>其中最重要的是，在 <strong>离线(offline)</strong> 时应用程序能够继续运行功能。</p>
<p>内部通过 Service Workers 技术实现的。</p>
<p>开发 Web App 项目，项目一旦处于网络离线情况，就没法访问了。</p>
<p>我们希望给项目提供离线体验。</p>
<pre><code>npm i workbox-webpack-plugin -D
</code></pre>
<pre><code class="language-js">const WorkboxPlugin = require(&quot;workbox-webpack-plugin&quot;);

new WorkboxPlugin.GenerateSW({
      // 这些选项帮助快速启用 ServiceWorkers
      // 不允许遗留任何“旧的” ServiceWorkers
      clientsClaim: true,
      skipWaiting: true,
    }),
</code></pre>
<ul>
<li><strong>易错</strong>： 注意是 <strong>new WorkboxPlugin.GenerateSW</strong>  是其身上的<strong>GenerateSW</strong>方法</li>
</ul>
<p>同时在入口文件注册 <strong>serviceWorker</strong></p>
<pre><code class="language-js">if (&quot;serviceWorker&quot; in navigator) {
  window.addEventListener(&quot;load&quot;, () =&gt; {
    navigator.serviceWorker
      .register(&quot;/service-worker.js&quot;)
      .then((registration) =&gt; {
        console.log(&quot;SW registered: &quot;, registration);
      })
      .catch((registrationError) =&gt; {
        console.log(&quot;SW registration failed: &quot;, registrationError);
      });
  });
}
</code></pre>
<p>之后再 <strong>npm run build</strong> ，生成的 <strong>dist</strong> 目录结构是这样的：
<img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240103205451056.png" alt="image-20240103205451056"></p>
<p>如果直接 <strong>live server</strong> dist下的index.html,会发现报错，路径是不对的，少了 <strong>/dist这个路径</strong></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240103204815516.png" alt="image-20240103204815516"></p>
<p>这里采用 <strong>serve</strong> 本地模拟生产环境</p>
<pre><code>npm i serve
之后
serve dist
</code></pre>
<p><strong>GPT</strong></p>
<p><code>serve</code> 是一个简单的静态文件服务器，它可以帮助你在本地快速启动一个 HTTP 服务器，用于提供静态文件服务。一般来说，你可以通过以下步骤使用 <code>serve</code>：</p>
<ol>
<li><p><strong>全局安装 <code>serve</code>：</strong></p>
<pre><code class="language-bash">npm install -g serve
</code></pre>
</li>
<li><p><strong>在项目目录中运行 <code>serve</code>：</strong></p>
<pre><code class="language-bash">serve
</code></pre>
<p> 这将启动一个服务器，并默认在当前目录中提供静态文件服务。你可以在浏览器中访问 <code>http://localhost:5000</code>（默认端口是 5000）查看项目文件。</p>
<p>你也可以在命令行中提供目录路径，例如：</p>
<pre><code class="language-bash">serve my-project
</code></pre>
<p>这将在 <code>my-project</code> 目录下启动服务器。</p>
</li>
</ol>
<p><code>serve</code> 的主要用途包括：</p>
<ul>
<li>快速搭建本地静态文件服务器，方便开发和测试。</li>
<li>提供一个简单的方式共享文件，例如通过局域网访问。</li>
</ul>
<p>请注意，<code>serve</code> 只是一个基本的静态文件服务器，不支持像服务器端脚本、动态路由等功能。</p>
<h2>ReactCli</h2>
<ol>
<li><p><strong>isProduction ? MiniCssExtractPlugin.loader : &quot;style-loader&quot;</strong></p>
</li>
<li><p>为何区分命名</p>
</li>
</ol>
<pre><code class="language-js">filename: isProduction ? &quot;static/js/[name].[contenthash:8].js&quot; : &quot;static/js/[name].js&quot;, // 入口文件打包输出资源命名方式
    chunkFilename: isProduction ? &quot;static/js/[name].[contenthash:8].chunk.js&quot; : &quot;static/js/[name].chunk.js&quot;, // 动态导入输出资源命名方式
</code></pre>
<ol start="3">
<li><pre><code class="language-js"> resolve:{
   extensions: [&#39;.jsx&#39;, &#39;.js&#39;, &#39;.json&#39;]
 },
</code></pre>
</li>
<li><p><strong>激活js的HMR ，注意，是 !isProduction 仅用于开发模式！仅用于开发模式！仅用于开发模式！ 焯！</strong></p>
</li>
</ol>
<pre><code class="language-js">{
    test: /\.jsx?$/,
        // exclude: /node_modules/, // 排除node_modules代码不编译
        include: path.resolve(__dirname, &quot;../src&quot;), // 也可以用包含
            use: [
                {
                    loader: &quot;babel-loader&quot;,
                    options: {
                        cacheDirectory: true, // 开启babel编译缓存
                        cacheCompression: false, // 缓存文件不要压缩
                        plugins: [
                            !isProduction &amp;&amp; &quot;react-refresh/babel&quot;  // 激活js的HMR
                        ].filter(Boolean),
                    },
                },
            ],
},
</code></pre>
<p>  还要在 <strong>plugin配置 (注意，是 !isProduction 仅用于开发模式！仅用于开发模式！仅用于开发模式！)：</strong></p>
<pre><code class="language-js">!isProduction &amp;&amp; new ReactRefreshWebpackPlugin()
</code></pre>
<p>  <strong>焯！！！！</strong></p>
<ol start="5">
<li><p>使用 <strong>isProduction &amp;&amp; new CssMinimizerPlugin()</strong> 分别为生产模式和开发模式添加插件， <strong>plugin</strong> 不接受数组中有 <strong>undefined</strong> 所以使用 <strong>[].filter(Boolean)过滤</strong></p>
</li>
<li><p>解决 前端刷新 404 问题</p>
<pre><code class="language-js">devServer:{
    host: &quot;localhost&quot;,
    port: 3000,
    open: true,
    hot: true, // 开启HMR   
    historyApiFallback: true  // 解决前端路由刷新404问题
},

    //.eslintrc.js
    module.exports = {
        extends: [&quot;react-app&quot;], // 继承 react 官方规则
        parserOptions: {
            babelOptions: {
                presets: [
                    // 解决页面报错问题
                    [&quot;babel-preset-react-app&quot;, false],
                    &quot;babel-preset-react-app/prod&quot;,
                ],
            },
        },
    };
</code></pre>
</li>
</ol>
<p><strong>为什么会有该问题？</strong></p>
<p>​	当使用 Webpack 构建的单页应用（Single Page Application，SPA）时，如果刷新页面后出现 404 错误，通常是因为服务器端不理解或不识别你的路由路径，导致无法正确地处理刷新后的请求。</p>
<p>这是因为在 SPA 中，页面的路由通常是由前端框架（如 React、Vue 等）通过客户端路由（Client-Side Routing）来控制的。当你刷新页面时，浏览器会向服务器发送请求，但服务器并没有处理这些前端路由。</p>
<p>解决这个问题的常见方法是配置服务器，使其对所有路径返回同一个 HTML 文件。这样，在刷新页面时，服务器会始终返回这个 HTML 文件，然后由前端路由来处理具体的页面渲染。</p>
<p>​		以下是一个简单的配置示例，使用 Express 作为服务器：</p>
<ol>
<li><p>安装 Express：</p>
<pre><code>npm install express --save
</code></pre>
</li>
<li><p>在项目根目录创建一个 <code>server.js</code> 文件，并添加以下内容：</p>
<pre><code class="language-js">const express = require(&#39;express&#39;);
const path = require(&#39;path&#39;);

const app = express();

// 静态文件中间件
app.use(express.static(path.resolve(__dirname, &#39;dist&#39;)));

// 所有请求都返回 index.html
app.get(&#39;*&#39;, (req, res) =&gt; {
  res.sendFile(path.resolve(__dirname, &#39;dist&#39;, &#39;index.html&#39;));
});

// 监听端口
const port = process.env.PORT || 3000;
app.listen(port, () =&gt; {
  console.log(`Server is running on port ${port}`);
});
</code></pre>
</li>
<li><p>在 <code>package.json</code> 中添加一个新的脚本，用于启动服务器：</p>
<pre><code class="language-js">&quot;scripts&quot;: {
  &quot;start&quot;: &quot;node server.js&quot;
}
</code></pre>
</li>
<li><p>确保在构建时生成的 <code>index.html</code> 文件位于 <code>dist</code> 目录中。</p>
</li>
<li><p>最后，运行以下命令启动服务器：</p>
<pre><code>npm start
</code></pre>
</li>
</ol>
<p>现在，当你刷新页面时，Express 服务器会始终返回 <code>index.html</code> 文件，由前端路由来处理页面的渲染。这样就解决了刷新页面导致的 404 问题。确保你的服务器配置适用于你的项目结构和路由需求。</p>
<p>​		React 官方文档也推荐类似的处理方式，尤其是在使用 React Router 等前端路由库的情况下。对于单页应用（SPA），在刷新页面时需要确保服务器正确处理前端路由。</p>
<p>一种常见的解决方案是使用服务器端路由重定向（Server-Side Route Redirection），确保对于所有请求都返回同一个 HTML 文件，从而让前端路由接管页面的渲染。</p>
<p>对于 React 项目，如果你使用的是 React Router，官方文档提供了一些建议，其中之一是使用 <code>BrowserRouter</code> 组件，并配置服务器以始终返回你的 index.html 文件。</p>
<p><strong>问题：</strong></p>
<ol>
<li><strong>React Cli 是怎么做 HMR 的</strong></li>
</ol>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240105195825648.png" alt="image-20240105195825648"><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240105195753877.png" alt="image-20240105195753877"></p>
<h1>Vite</h1>
<h2>P3</h2>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240105211614001.png" alt="image-20240105211614001"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240105211531128.png" alt="image-20240105211531128"></p>
<h2>P4</h2>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240105211504257.png" alt="image-20240105211504257"></p>
<h2>P5</h2>
<h2>P6 依赖预构建</h2>
<ul>
<li>解决多包问题</li>
</ul>
<p> <img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107160426634.png" alt="image-20240107160426634"></p>
<p> <img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107160455756.png" alt="image-20240107160455756"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107161421873.png" alt="image-20240107161421873"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107161616622.png" alt="image-20240107161616622"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107161712479.png" alt="image-20240107161712479"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107161624152.png" alt="image-20240107161624152"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107161559803.png" alt="image-20240107161559803"></p>
<h2>P7 语法提示</h2>
<p>方法一:
<img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107162034164.png" alt="image-20240107162034164"></p>
<p>方法二：</p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107162202143.png" alt="image-20240107162202143"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107162829539.png" alt="image-20240107162829539"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107162708031.png" alt="image-20240107162708031"></p>
<h2>P8 环境变量</h2>
<p>配置环境变量时必须要注意：</p>
<ul>
<li><p>配置  <strong>envDir</strong>  注意，因为 <strong>vite.config.js</strong>其实是在<strong>node</strong>环境下执行的，也就是服务端，所以该配置的工作目录为node命令执行的目录</p>
</li>
<li><p>配置 <strong>envPrefix</strong></p>
</li>
<li></li>
</ul>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107163106157.png" alt="image-20240107163106157"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107164215201.png" alt="image-20240107164215201"></p>
<p> <img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107170837984.png" alt="image-20240107170837984"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107170901286.png" alt="image-20240107170901286"><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107165132356.png" alt="image-20240107165132356"><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107185141179.png" alt="image-20240107185141179"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107185337032.png" alt="image-20240107185337032"><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107185502576.png" alt="image-20240107185502576"><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240107185756546.png" alt="image-20240107185756546"></p>
<h2>P9</h2>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240108155347720.png" alt="image-20240108155347720"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240108155219832.png" alt="image-20240108155219832"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240108155232764.png" alt="image-20240108155232764"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240108155248781.png" alt="image-20240108155248781"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240108155314484.png" alt="image-20240108155314484"></p>
<h2>P10</h2>
<h1>模块化</h1>
<p>参考资料：</p>
<ul>
<li><p>[前端模块标准之CommonJS和ES6 Module的区别](<a href="https://juejin.cn/post/6959360326299025445">前端模块标准之CommonJS和ES6 Module的区别 - 掘金 (juejin.cn)</a>)</p>
</li>
<li><p><strong>动态与静态</strong></p>
</li>
<li><p><strong>值拷贝与动态映射</strong></p>
<ul>
<li><pre><code class="language-js">// calculator.js
var count = 0
module.exports = {
    count,
    add: function (a, b) {
        count += 1
        return a + b
    }
}

// index.js
var count = require(&#39;./calculator.js&#39;).count
var add = require(&#39;./calculator.js&#39;).add

console.log(count) // 0（这里的count是对 calculator.js 中 count 值的拷贝）
add(2, 3)
console.log(count) // 0（calculator.js中变量值的改变不会对这里的拷贝值造成影响）

count += 1
console.log(count) // 1（拷贝的值可以更改）
</code></pre>
<pre><code class="language-js">// calculator.js
let count = 0
const add = function (a, b) {
    count += 1
    return a + b
}
export { count, add }

// index.js
import { count, add } from &#39;./calculator.js&#39;

console.log(count) // 0（对 calculator.js 中 count 值的引用）
add(2, 3)
console.log(count) // 1（因为是引用，所以和calculator.js中的count值保持一致）

// count += 1 // 不可更改，会报错 SyntaxError: &#39;count&#39; is read-only
</code></pre>
</li>
</ul>
</li>
</ul>
<p>CommonJS与ES6 Module最本质的区别是：<strong>动态vs静态</strong></p>
<ul>
<li>CommonJS对模块依赖的解决是“动态的”（<strong>只能在运行时，分析出对应的依赖关系</strong>）</li>
<li>ES6 Module是“静态的”（<strong>可以在编译时，就分析出对应的依赖关系，才能做tree shaking</strong>）</li>
</ul>
<p>这句话描述了 CommonJS 和 ES6 Module 两种模块系统对于模块依赖解决的不同方式：</p>
<ol>
<li><p><strong>CommonJS 对模块依赖的解决是“动态的”：</strong></p>
<ul>
<li>在 CommonJS 中，模块的加载和执行是在运行时进行的。</li>
<li>当代码执行到 <code>require</code> 语句时，模块才会被动态加载，所需的依赖关系在运行时被分析和解决。</li>
<li>这种动态性意味着在运行时才能确定模块的依赖关系，因为它可以包含在条件语句、循环等结构中。</li>
</ul>
</li>
<li><p><strong>ES6 Module 是“静态的”：</strong></p>
<ul>
<li>在 ES6 Module 中，模块的加载和执行是在编译时进行的。</li>
<li>在代码被解释之前，编译器就能够静态地分析和确定模块之间的依赖关系。</li>
<li>这种静态性使得工具（如 tree shaking 工具）可以在编译时对模块进行更彻底的优化，去除未使用的部分，以减小最终的代码体积。</li>
</ul>
</li>
</ol>
<p>总体而言，动态和静态的区别在于模块加载和依赖解决发生的时间。CommonJS 是动态加载，只有在运行时才能确定依赖关系；而 ES6 Module 是静态加载，在编译时就能够确定依赖关系，这为一些性能和优化工具提供了更多的可能性。</p>
<h1>浏览器工作原理</h1>
<p><strong>优化</strong></p>
<pre><code>https://juejin.cn/post/6844904205358989319
</code></pre>
<h1>计算机网络&amp;&amp;前端开发</h1>
<h2>相关定义：</h2>
<p>**CDN：**的全称是<code>Content Delivery Network</code>，即<code>内容分发网络</code></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240110184344557.png" alt="image-20240110184344557"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240110190532141.png" alt="image-20240110190532141"></p>
<p>jsonp</p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240110190636430.png" alt="image-20240110190636430"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240110191945560.png" alt="image-20240110191945560"></p>
<h2>TCP &amp;&amp; UDP</h2>
<h3>80端口</h3>
<p>端口号 80 是目标服务器上的 HTTP 服务所使用的默认端口。当你在浏览器中访问一个网站时，默认的 HTTP 协议会使用目标服务器的端口 80 进行通信。</p>
<p>所以，当使用 <code>ping -t www.baidu.com -p tcp</code> 等命令，并且指定协议为 TCP 以及端口号为 80 时，你实际上是在尝试与目标服务器的 HTTP 服务建立连接，目标服务器的端口是 80。这并不是本地主机的端口，而是目标服务器上用于提供 HTTP 服务的端口。</p>
<p>在 TCP（传输控制协议）中，<code>ACK</code>、<code>ack</code> 和 <code>seq</code> 分别表示以下内容：</p>
<ol>
<li><p><strong>ACK（Acknowledgment）：</strong></p>
<ul>
<li><strong>意义：</strong> 表示确认，用于确认接收到的数据。</li>
<li><strong>位置：</strong> TCP 头部中的 <code>ACK</code> 标志位。</li>
<li><strong>作用：</strong> 当 <code>ACK</code> 标志位被置为 1 时，表示当前报文段携带的确认号字段（<code>Acknowledgment Number</code>）是有效的，对方已成功接收到了发送方之前发送的报文段。</li>
</ul>
</li>
<li><p><strong>ack：</strong></p>
<ul>
<li><strong>意义：</strong> 表示确认号，用于指定接收方期望收到的下一个字节的序号。</li>
<li><strong>位置：</strong> TCP 头部中的 <code>Acknowledgment Number</code> 字段。</li>
<li><strong>作用：</strong> 接收方通过 <code>ack</code> 字段告诉发送方，它期望下一个接收到的字节的序号是多少。这样发送方就知道哪些数据已经被接收，可以进行下一轮的数据发送。</li>
</ul>
</li>
<li><p><strong>seq：</strong></p>
<ul>
<li><strong>意义：</strong> 表示序号，用于标识发送方发送的数据字节的序号。</li>
<li><strong>位置：</strong> TCP 头部中的 <code>Sequence Number</code> 字段。</li>
<li><strong>作用：</strong> 发送方通过 <code>seq</code> 字段标识当前发送的数据的起始字节的序号。接收方通过该序号确定接收到的数据在整个数据流中的位置。</li>
</ul>
</li>
</ol>
<p>综合来看，TCP 中的 <code>ACK</code> 表示确认，<code>ack</code> 表示确认号，<code>seq</code> 表示序号。这些字段的协同工作确保了可靠的数据传输和流量控制。通过适当设置这些字段，TCP 可以确保数据在网络中可靠传递，并且接收方可以正确地重组数据流。</p>
<p>**wireshark抓包工具： **</p>
<p><strong>使用教程： <a href="http://t.csdnimg.cn/6w7dY">网络分析工具——WireShark的使用（超详细）</a></strong></p>
<p>在 Wireshark 工具中，你看到的 <code>ACK</code> 和 <code>seq</code> 是 TCP 报文头中的标志和字段。Wireshark 中通常使用大写的 <code>ACK</code> 表示 <code>ACK</code> 标志位，而 <code>ack</code> 通常指的是 <code>Acknowledgment Number</code> 字段。这里我解释一下 Wireshark 中可能出现的情况：</p>
<ol>
<li><p><strong>ACK 标志位：</strong></p>
<ul>
<li><strong>显示为 <code>ACK</code>：</strong> Wireshark 通常将 TCP 头部中的 <code>ACK</code> 标志位显示为 <code>ACK</code>，表示该报文是一个带有确认标志的 TCP 报文。这个标志位表示确认号字段有效。</li>
</ul>
</li>
<li><p><strong>Acknowledgment Number 字段（ack）：</strong></p>
</li>
</ol>
<ul>
<li><strong>显示为 <code>ack</code>：</strong> Wireshark 通常将 TCP 头部中的 <code>Acknowledgment Number</code> 字段显示为 <code>ack</code>。这个字段的值表示接收方期望收到的下一个字节的序号。</li>
</ul>
<p>所以，Wireshark 中的 <code>ACK</code> 和 <code>ack</code> 分别表示 TCP 报文头中的确认标志和确认号字段。在 TCP 报文中，<code>ACK</code> 标志位被设置表示确认号字段有效。<code>ack</code> 字段的值表示接收方期望接收的下一个字节的序号。这两者协同工作，确保了 TCP 的可靠数据传输。</p>
<h3>三次握手</h3>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240116153552215.png" alt="image-20240116153552215"></p>
<h3>四次挥手</h3>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240116153502322.png" alt="image-20240116153502322"></p>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240116153810690.png" alt="image-20240116153810690"><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240116153822730.png" alt="image-20240116153822730"></p>
<h2>HTTP</h2>
<h3>Content-Type</h3>
<p><a href="https://juejin.cn/post/6959742146781904904">详解 HTTP Header 中的 Content-Type</a></p>
<p>HTTP 请求头/响应头 Content-Type 用于向接收方说明传输资源的媒体类型。例如，如果传输的是图片，那么它的媒体类型可能会是 <code>image/png</code> 、<code>image/jpg</code>。</p>
<p>在浏览器中，浏览器会根据 Content-Type 判断响应体的资源类型，然后根据不同文件类型做出不同的展示。例如，对于同样一张图片，如果 Response Header 中声明了 <code>Content-type: image/jpeg</code>，浏览器会以图片形式展示；如果没有声明 Content-Type，那么浏览器会以文本形式展示。</p>
<h2>Ajax</h2>
<h2>Fetch</h2>
<h2>SSE</h2>
<h2>webSocket</h2>
<p><img src="%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.assets/image-20240116201425629.png" alt="image-20240116201425629"></p>
<h3>**express-ws英文文档： **</h3>
<p><a href="https://gitee.com/link?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWebSockets_API">WebSocket</a> endpoints for <a href="https://gitee.com/link?target=http%3A%2F%2Fexpressjs.com%2F">Express</a> applications. Lets you define WebSocket endpoints like any other type of route, and applies regular Express middleware. The WebSocket support is implemented with the help of the <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fwebsockets%2Fws">ws</a> library.</p>
<p><strong>Installation</strong></p>
<pre><code>npm install --save express-ws
</code></pre>
<p><strong>Usage</strong></p>
<p><strong>Full documentation can be found in the API section below. This section only shows a brief example.</strong></p>
<p>Add this line to your Express application:</p>
<pre><code>var expressWs = require(&#39;express-ws&#39;)(app);
</code></pre>
<p><strong>Important: Make sure to set up the <code>express-ws</code> module like above *before* loading or defining your routers!</strong> Otherwise, <code>express-ws</code> won&#39;t get a chance to set up support for Express routers, and you might run into an error along the lines of <code>router.ws is not a function</code>.</p>
<p>After setting up <code>express-ws</code>, you will be able to add WebSocket routes (almost) the same way you add other routes. The following snippet sets up a simple echo server at <code>/echo</code>. The <code>ws</code> parameter is an instance of the WebSocket class described <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fwebsockets%2Fws%2Fblob%2Fmaster%2Fdoc%2Fws.md%23class-websocket">here</a>.</p>
<pre><code>app.ws(&#39;/echo&#39;, function(ws, req) {
  ws.on(&#39;message&#39;, function(msg) {
    ws.send(msg);
  });
});
</code></pre>
<p>It works with routers, too, this time at <code>/ws-stuff/echo</code>:</p>
<pre><code>var router = express.Router();

router.ws(&#39;/echo&#39;, function(ws, req) {
  ws.on(&#39;message&#39;, function(msg) {
    ws.send(msg);
  });
});

app.use(&quot;/ws-stuff&quot;, router);
</code></pre>
<p><strong>Full example</strong></p>
<pre><code>var express = require(&#39;express&#39;);
var app = express();
var expressWs = require(&#39;express-ws&#39;)(app);

app.use(function (req, res, next) {
  console.log(&#39;middleware&#39;);
  req.testing = &#39;testing&#39;;
  return next();
});

app.get(&#39;/&#39;, function(req, res, next){
  console.log(&#39;get route&#39;, req.testing);
  res.end();
});

app.ws(&#39;/&#39;, function(ws, req) {
  ws.on(&#39;message&#39;, function(msg) {
    console.log(msg);
  });
  console.log(&#39;socket&#39;, req.testing);
});

app.listen(3000);
</code></pre>
<h4>expressWs(app, <em>server</em>, <em>options</em>)</h4>
<p>Sets up <code>express-ws</code> on the specified <code>app</code>. This will modify the global Router prototype for Express as well - see the <code>leaveRouterUntouched</code> option for more information on disabling this.</p>
<ul>
<li><p><strong>app</strong>: The Express application to set up <code>express-ws</code> on.</p>
</li>
<li><p><strong>server</strong>: <em>Optional.</em> When using a custom <code>http.Server</code>, you should pass it in here, so that <code>express-ws</code> can use it to set up the WebSocket upgrade handlers. If you don&#39;t specify a <code>server</code>, you will only be able to use it with the server that is created automatically when you call <code>app.listen</code>.</p>
</li>
<li><p>options</p>
<p>:</p>
<p>Optional.</p>
<p>An object containing further options.</p>
<ul>
<li><strong>leaveRouterUntouched:</strong> Set this to <code>true</code> to keep <code>express-ws</code> from modifying the Router prototype. You will have to manually <code>applyTo</code> every Router that you wish to make <code>.ws</code> available on, when this is enabled.</li>
<li><strong>wsOptions:</strong> Options object passed to WebSocketServer constructor. Necessary for any ws specific features.</li>
</ul>
</li>
</ul>
<p>This function will return a new <code>express-ws</code> API object, which will be referred to as <code>wsInstance</code> in the rest of the documentation.</p>
<h4>wsInstance.app</h4>
<p>This property contains the <code>app</code> that <code>express-ws</code> was set up on.</p>
<h4>wsInstance.getWss()</h4>
<p><strong>广播</strong></p>
<p>Returns the underlying WebSocket server/handler. You can use <code>wsInstance.getWss().clients</code> to obtain a list of all the connected WebSocket clients for this server.</p>
<p>Note that this list will include <em>all</em> clients, not just those for a specific route - this means that it&#39;s often <em>not</em> a good idea to use this for broadcasts, for example.</p>
<h4>wsInstance.applyTo(router)</h4>
<p><strong>基本不用</strong></p>
<p>Sets up <code>express-ws</code> on the given <code>router</code> (or other Router-like object). You will only need this in two scenarios:</p>
<ol>
<li>You have enabled <code>options.leaveRouterUntouched</code>, or</li>
<li>You are using a custom router that is not based on the express.Router prototype.</li>
</ol>
<p>In most cases, you won&#39;t need this at all.</p>
<h4>Development</h4>
<p>This module is written in ES6 and uses ESM.</p>

</body>
</html>