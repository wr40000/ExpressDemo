<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="http://139.159.253.241:3000/stylesheets/github.css">
    <title>Document</title>
</head>
<body>
    <h1>HTML</h1>
<h1>CSS</h1>
<h1>Js</h1>
<h2>Promise</h2>
<h3>珠峰手写Promise</h3>
<h4>前置编程思想</h4>
<h5>AOP--面向切片编程</h5>
<pre><code>参考资料
https://juejin.cn/post/7011797590207365128

https://juejin.cn/post/6844903796129136654
</code></pre>
<p><img src="%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3.assets/image-20231211202652051.png" alt="image-20231211202652051"></p>
<p>面向切面的程序设计（Aspect-oriented programming，AOP，又译作面向方面的程序设计、剖面导向程序设计）是计算机科学中的一种程序设计思想，旨在将横切关注点与业务主体进行进一步分离，以提高程序代码的模块化程度。面向切面的程序设计思想也是面向切面软件开发的基础。切面的概念源于对面向对象的程序设计和计算反射的融合，但并不只限于此，它还可以用来改进传统的函数。与切面相关的编程概念还包括元对象协议、主题（Subject）、混入（Mixin）和委托（Delegate）。</p>
<p>面向切面编程为我们提供了一种将代码注入现有函数或对象的方法，而无需修改目标逻辑。</p>
<p>注入的代码虽然不是必需的，但在具有横切关注点的，例如添加日志记录功能、调试元数据、性能统计、安全控制、事务处理、异常处理或不那么通用的功能，可以在不影响原始代码的情况下注入额外的行为。把它们抽离出来，用“动态”插入的方式嵌到各业务逻辑中。业务模块可以变得比较干净，不受污染，同时这些功能点能够得到很好的复用，给模块解耦。</p>
<p><img src="%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3.assets/image-20231213102440106.png" alt="image-20231213102440106"></p>
<pre><code class="language-js">function say(who) {
  console.log(who + &quot;说话&quot;);
}
Function.prototype.before = function (cb) {
  // 写法一
  //   return function () {
  //     cb();
  //     this(); //有this指向问题  可在外侧let that = this
  //   };
  // 写法二  采用ES6解决this指向
  return (...arg) =&gt; {
    console.log(&quot;arg: &quot;, arg);
      cb();
      // console.log(&quot;this: &quot;, this);
      // this(...arg)
  }
};
let newFn = say.before(function () {
  console.log(&quot;说话前&quot;);
});

newFn(&#39;Terraria&#39;);
</code></pre>
<ul>
<li><p>上面的代码，在<strong>Function</strong>的原型上添加方法<strong>before</strong>，接受一个函数作为参数，且返回一个函数，所以调用<strong>newFn</strong>也将返回一个函数</p>
</li>
<li><p>在<strong>before</strong>的内部，我们可以先调用传入的函数，在使用<strong>this()<strong>调用</strong>say</strong>方法，因为这里是箭头函数，所以<strong>this</strong>也就是<strong>say</strong>, 使用<strong>ES5</strong>的写法则需要使用 <strong>let that = this</strong></p>
</li>
<li><p>为什么**...arg<strong>可以接收到</strong>newFn(&#39;Terraria&#39;)<strong>中的参数，因为</strong>newFnqi**其实是函数</p>
<ul>
<li><pre><code class="language-js">(...arg) =&gt; {
    console.log(&quot;arg: &quot;, arg);
      cb();
      // console.log(&quot;this: &quot;, this);
      // this(...arg)
  }
</code></pre>
<p>newFn(&#39;Terraria&#39;)也就是相当是：</p>
<pre><code class="language-js">(() =&gt; {
    console.log(&quot;arg: &quot;, arg);
      cb();
      // console.log(&quot;this: &quot;, this);
      // this(...arg)
  })(&#39;Terraria&#39;)
</code></pre>
<p>所以 <strong>...arg</strong>可以接受到所有传入的参数，并将其封装到一个数组里</p>
</li>
</ul>
</li>
</ul>
<h5>事件发布&amp;订阅</h5>
<p>我的理解是：</p>
<ul>
<li>首先有一个保存订阅的事件的数组</li>
<li>有一个方法要将订阅的事件添加到数组里</li>
<li>在时机成熟时有一个方法要对数组的里方法进行触发</li>
<li>最好是把这些逻辑封装成一个对象</li>
</ul>
<p>下面的代码中的 <strong>event</strong> 实现的基本就是这样</p>
<p>先订阅事件，事件触发时，再根据内部的逻辑判断执行哪些事件</p>
<pre><code class="language-js">let fs = require(&#39;fs&#39;);

let event = {
    _arr: [],
    on(cb){
        this._arr.push(cb);
    },
    emit(){
        this._arr.forEach(cb =&gt; cb())
    }
}

let player = []
event.on(function(){
    console.log(&quot;读取一个&quot;);
})
event.on(function(){
    if(player.length == 2 ){
        console.log(&#39;over player: &#39;, player);
    }
})

fs.readFile(&#39;.\/1.txt&#39;, &#39;utf8&#39;, (err, data)=&gt;{
    player.push(data)
    event.emit()
})
fs.readFile(&#39;./2.txt&#39;, &#39;utf8&#39;, (err, data)=&gt;{
    player.push(data)
    event.emit()
})
</code></pre>
<h5>观察者模式</h5>
<p><strong>观察者模式的一个优点是实现了观察者和被观察者的解耦，被观察者不需要知道观察者的具体细节，只需要通知观察者即可。这有助于代码的灵活性和可维护性。</strong></p>
<p>挺像Vue2中的依赖收集</p>
<ul>
<li>有一个观察者实例和一个被观察者实例</li>
<li>被观测者在内部有一个保存着谁在观测他其的数组</li>
<li>被观测者在内部有一个更新状态的方法，一旦状态更新，该方法会通知所有观察者数组的成员，并将新的状态传递过去，也就是带着新的状态触发观测者的方法，实现响应式</li>
</ul>
<p>下面的例子，宝宝实例会将爸爸和妈妈的实例对象先加入观测者的数组，当宝宝状态发生改变，通知数组里的成员并携带着新状态去调用相关方法</p>
<pre><code class="language-js">class Subject{
    constructor(){
        this.state = &#39;开心的一批&#39;
        this.arr = []
    }
    attach(o){
        this.arr.push(o)
    }
    setState(newValue){
        this.state = newValue;
        this.arr.forEach(o =&gt; o.updata(newValue))
    }
}
// 观察者
class Observer{
    constructor(name){
        this.name = name
    }
    updata(newValue){
        console.log(&quot;name: &quot; + this.name + &#39;,    baby状态是: &#39; + newValue);
    }
}

let baby = new Subject;
let mm = new Observer(&#39;宝宝他妈&#39;);
let bb = new Observer(&#39;宝宝他爸&#39;);
baby.attach(mm)
baby.attach(bb)
baby.setState(&quot;困得一批&quot;)
</code></pre>
<h5>装饰器模式</h5>
<p>称为&quot;装饰器模式&quot;（Decorator Pattern）</p>
<p>装饰器模式是一种结构型设计模式，允许通过将对象放入包装对象中来动态地扩展其行为。在这里，<code>perform</code> 函数接受两个参数：<code>anyMethods</code> 和 <code>wrappers</code>。</p>
<ul>
<li><code>anyMethods</code> 是一个函数，代表了要执行的具体操作。</li>
<li><code>wrappers</code> 是一个包含了多个装饰器对象的数组，每个装饰器对象都有 <code>initialize</code> 和 <code>close</code> 方法，分别在操作执行前后进行一些初始化和清理工作。</li>
</ul>
<p>在 <code>perform</code> 函数内部，首先通过循环调用 <code>wrappers</code> 数组中每个装饰器的 <code>initialize</code> 方法，然后执行 <code>anyMethods</code> 函数，最后再次循环调用 <code>wrappers</code> 数组中每个装饰器的 <code>close</code> 方法。</p>
<p>这样一来，通过使用装饰器模式，你可以在不修改原始操作（<code>anyMethods</code>）的情况下，动态地添加一些前置和后置的功能，以满足不同的需求。这种模式可以使代码更加灵活和可扩展。</p>
<pre><code class="language-js">function perform(anyMethods, wrappers) {
  wrappers.forEach((wrapper) =&gt; wrapper.initialize());
  anyMethods();
  wrappers.forEach((wrapper) =&gt; wrapper.close());
}

perform(
  function () {
    console.log(&quot;say&quot;);
  },
  [
    {
      initialize() {
        console.log(&quot;say前&quot;);
      },
      close() {
        console.log(&quot;say后&quot;);
      },
    },
    {
      initialize() {
        console.log(&quot;say前前&quot;);
      },
      close() {
        console.log(&quot;say后后&quot;);
      },
    },
  ]
);
</code></pre>
<h4>手写Promise</h4>
<ul>
<li><p>new Promise失败状态也会reject</p>
</li>
<li><p>官方术语</p>
<ul>
<li><p>promise 是一个有then方法的对象或者是函数，行为遵循本规范</p>
</li>
<li><p>thenable 是一个有then方法的对象或者是函数</p>
</li>
<li><p>value 是promise状态成功时的值，包括 undefined/thenable或者是 promise</p>
</li>
<li><p>exception 是一个使用throw抛出的异常值</p>
</li>
<li><p>reason 是promise状态失败时的值</p>
</li>
</ul>
</li>
</ul>
<h5>首先初始化状态和方法</h5>
<pre><code class="language-js">  constructor(executor) {
    this.state = PENDING;
    this.value = undefined; // 成功的结果
    this.reason = undefined; // 失败的原因
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];

    let resolve = (value) =&gt; { //添加判断，状态一旦更改就不可变
      if ((this.state === PENDING)) {
        this.state = RESOLVE;
        this.value = value;
        this.onResolvedCallbacks.forEach((cb) =&gt; cb());
      }
    };
    let reject = (reason) =&gt; {
      if ((this.state === PENDING)) {
        this.state = REJECT;
        this.reason = reason;
        this.onRejectedCallbacks.forEach((cb) =&gt; cb());
      }
    };
    try {
      executor(resolve, reject);
    } catch (e) {
      reject(e);
    }
  }
</code></pre>
<ul>
<li><p><strong>resolve reject</strong>添加判断，状态一旦更改就不可变</p>
</li>
<li><p><strong>this.onResolvedCallbacks = [] ：</strong> 当promise还是pending状态时调用then方法时，显然不适合触发其中的方法，所以将then方法里的函数存放在自身的一个队列里，当状态发生改变，会去调用resolve,这时再执行该数组里的方法</p>
</li>
<li><p><strong>this.onRejectedCallbacks：</strong> 同理，失败时调用reject,后再清空其中的方法即可</p>
</li>
<li><p>立即执行函数要求上来就执行，使用try..catch...捕获错误</p>
</li>
</ul>
<h5>then方法</h5>
<ul>
<li><p>then接收一个成功的方法，一个失败的方法，<strong>且返回的是一个Promise,因为then是可以连续调用的</strong></p>
</li>
<li><p>因为函数不是必传的，所以要判断，没有传就直接分别传递一下<strong>value reason</strong>即可</p>
<ul>
<li><p>​	</p>
<pre><code class="language-js">onfulfilled =
    typeof onfulfilled === &quot;function&quot; ? onfulfilled : (data) =&gt; data;
onrejected =
    typeof onrejected === &quot;function&quot;
    ? onfulfilled
: (err) =&gt; {
    throw new Error(err);
};
</code></pre>
</li>
</ul>
</li>
<li><p>then返回的还是promise,根据上一步的状态来决定是调用 <strong>onfulfilled 还是 onrejected</strong></p>
<ul>
<li><p><strong>定时器的作用：</strong> 因为在 <strong>let promise2</strong>的内部调用了 <strong>promise2</strong>,所以要加上定时器异步获取 <strong>promise2</strong></p>
</li>
<li><p>**定时器里面使用try...catch..：**如果在定时器里的逻辑发生错误了，<strong>constructor</strong>里的try...catch...是无法捕获的，因为加上定时器后，这已经是个异步任务了</p>
</li>
<li><p><strong>调用then的promise状态是成功</strong>，则用定时器将回调函数包裹成自执行函数，失败同理</p>
<pre><code class="language-js">if (this.state === RESOLVE) {
    setTimeout(() =&gt; {
        try {
            let x = onfulfilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
        } catch (e) {
            reject(e);
        }
    }, 0);
}
</code></pre>
</li>
<li><p><strong>调用then的promise状态是pending：</strong> 将then中的回调用定时器包装成自执行函数后，外面再包装成一个函数，并放到调用该then方法的promise的<strong>onResolvedCallbacks 和 onRejectedCallbacks</strong></p>
<pre><code class="language-js">if (this.state === PENDING) {
    this.onResolvedCallbacks.push(() =&gt; {
        setTimeout(() =&gt; {
            try {
                let x = onfulfilled(this.value);
                resolvePromise(promise2, x, resolve, reject);
            } catch (e) {
                reject(e);
            }
        }, 0);
    });
    this.onRejectedCallbacks.push(() =&gt; {
        setTimeout(() =&gt; {
            try {
                let x = onrejected(this.reason);
                resolvePromise(promise2, x, resolve, reject);
            } catch (e) {
                reject(e);
            }
        }, 0);
    });
}
</code></pre>
</li>
<li><p>**判断then成功或失败回调的返回值是否是Promise,解决链式调用的异步：**这里有个问题要解决，因为要在你不能确定经过 **onfulfilled **后返回的x值是普通值还是仍然是一个 Promise,如果是个promise就必须要根据x的状态来执行后续then的回调，保证异步任务的顺序执行，所以添加方法 <strong>resolvePromise(promise2, x, resolve, reject);</strong> 用以判定异步任务执行的逻辑</p>
<ul>
<li><p>因为如果是普通值，显然直接 <strong>resolve</strong>即可</p>
</li>
<li><p>但是如果 <strong>x</strong> 是个promise, 那么显然要<strong>根据x的状态来决定后续还有then方法的连续调用中的方法执行顺序</strong>，对于这种情况，是<strong>什么时候</strong>将后续then调用中的方法放入onResolvedCallbacks 或者onRejectedCallbacks里的呢？</p>
<p>在<strong>resolvePromise</strong>中，如果x是promise，有这样一段代码:</p>
<pre><code class="language-js">then.call(
    x,
    (y) =&gt; {
        if (called) {
            return;
        }
        called = true;
        resolvePromise(promise2, y, resolve, reject);
    },
    (r) =&gt; {
        if (called) {
            return;
        }
        called = true;
        reject(r);
    }
);
</code></pre>
<p>显然，<strong>如果x是promise,将会调用它的then方法，且将this指向x</strong>，也就是确定是调用了x.then，所以对于后续的then的链式调用就会根据x的状态，<strong>以事件发布订阅的思想基于x的状态的改变来调用数组的方法</strong></p>
</li>
<li><p>对于x.then的返回值还是promise的情况，采用递归</p>
</li>
<li><p>called的作用是使回调只能被调用一次</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5>GPT问答--重要</h5>
<ul>
<li><p>**then中的this：**对于 <code>then</code> 返回的新的 Promise 对象，其中的 <code>this</code> 确实指向调用 <code>then</code> 方法的原始 Promise 对象。这是因为 <code>then</code> 方法的设计是基于链式调用的，新的 Promise 对象是由 <code>then</code> 方法生成的，而该方法是在原始 Promise 对象上调用的。</p>
<p>对于状态传递和成功/失败值的正确传递的作用：</p>
<ul>
<li><strong>状态传递：</strong> 在 Promise 链中，<code>then</code> 方法返回的新 Promise 对象的状态取决于前一个 Promise 对象的状态。如果前一个 Promise 对象是 resolved，新的 Promise 对象将会变为 resolved，并且会执行 <code>onfulfilled</code> 回调；如果前一个 Promise 对象是 rejected，新的 Promise 对象将会变为 rejected，并且会执行 <code>onrejected</code> 回调。这种状态的传递是通过 <code>this</code> 来实现的，确保新的 Promise 对象与前一个 Promise 对象相互关联。</li>
<li><strong>成功的 value 和失败的 reason 传递：</strong> 当前一个 Promise 对象的状态为 resolved 时，<code>onfulfilled</code> 回调的返回值会成为新的 Promise 对象的解决值；当前一个 Promise 对象的状态为 rejected 时，<code>onrejected</code> 回调的返回值（或者抛出的错误）会成为新的 Promise 对象的拒绝原因。这里的传递也是基于 <code>this</code> 指向的关系。</li>
</ul>
<p>例如，在 <code>p.then(onfulfilled, onrejected)</code> 中，<code>onfulfilled</code> 和 <code>onrejected</code> 中的 <code>this</code> 都指向调用 <code>then</code> 方法的原始 Promise 对象 <code>p</code>。这使得在这些回调函数中可以访问到原始 Promise 对象的状态和值。</p>
<p>总的来说，<code>this</code> 的正确指向确保了 Promise 链中的状态传递和成功/失败值的正确传递。这是 Promise 链式调用的关键机制。</p>
</li>
<li><p>​	<strong>if ((typeof x === &quot;object&quot; &amp;&amp; typeof x !== null) || typeof x === &quot;function&quot;)是什么作用</strong>：</p>
<ul>
<li><p>这行代码用于判断 <code>x</code> 是否是一个对象（除了 <code>null</code> 外）或者一个函数。这是在 <code>resolvePromise</code> 函数中对于 <code>x</code> 类型的判断。</p>
<p>具体来说：</p>
<ul>
<li><code>typeof x === &quot;object&quot;</code>：首先判断 <code>x</code> 的类型是否为对象。这可以用于检查 <code>x</code> 是否是一个普通对象，因为 <code>typeof null</code> 也是 &quot;object&quot;，所以这一部分条件还需要加上 <code>&amp;&amp; typeof x !== null</code> 来排除 <code>null</code>。</li>
<li><code>|| typeof x === &quot;function&quot;</code>：这一部分用于检查 <code>x</code> 是否是一个函数。这是因为在 JavaScript 中，函数也被认为是一种特殊的对象类型。</li>
</ul>
<p>综合起来，这个条件语句是为了判断 <code>x</code> 是否是一个对象（除了 <code>null</code> 外）或者一个函数。如果是这两种类型之一，就认为 <code>x</code> 可能是一个 Promise 对象，需要进行进一步的处理。这个判断在实现 Promise 链式调用和异步操作时非常重要。如果 <code>x</code> 是一个对象，那么可能具有 <code>then</code> 方法，我们需要根据它的状态来决定新 Promise 对象的状态和值。</p>
</li>
</ul>
</li>
<li><p>每个返回的promise都有自己的 <strong>onResolvedCallbacks<code>和</code>onRejectedCallbacks</strong></p>
<ul>
<li><p>其实想想也是，如果所有待执行任务都放在一个<strong>onResolvedCallbacks</strong>和一个 <strong>onRejectedCallbacks</strong>里，每个自执行函数里的this指向也会出现问题，毕竟this.value来自调用then的promise</p>
</li>
<li><p>每个 <code>then</code> 调用返回的新的 Promise 对象都有自己独立的 <code>onResolvedCallbacks</code> 和 <code>onRejectedCallbacks</code> 数组。这两个数组是为了存放该 Promise 对象的状态变为 resolved 或 rejected 时需要执行的回调函数。</p>
<p>所以，不同的 Promise 对象之间的这两个数组是相互独立的，互不干扰。每个 Promise 对象都有自己的一组回调函数，这确保了在链式调用中每个 Promise 对象都能够按照正确的顺序执行自己的回调函数，而不会产生相互干扰的情况。</p>
</li>
</ul>
</li>
<li><p>调用 <strong>pending</strong> 状态的Promise</p>
<ul>
<li><p>在 Promise 的实现中，<code>then</code> 方法的回调函数确实会被放入调用它的 Promise 的任务队列中。这确保了 <code>then</code> 中的回调函数在适当的时机执行，符合 Promise 的异步执行特性。</p>
<p>当 <code>then</code> 方法被调用时，它会将 <code>onResolvedCallbacks</code> 或 <code>onRejectedCallbacks</code> 中的回调函数包装成一个延迟执行的函数，并将这个延迟执行的函数放入任务队列中。这是通过 <code>setTimeout</code> 或者类似的异步机制来实现的。</p>
<p>具体代码可以参考你提供的 Promise 实现中的以下部分：</p>
<pre><code class="language-js">if (this.state == PENDING) {
  this.onResolvedCallbacks.push(() =&gt; {
    setTimeout(() =&gt; {
      try {
        let x = onfulfilled(this.value);
        resolvePromise(promise2, x, resolve, reject);
      } catch (e) {
        reject(e);
      }
    }, 0);
  });

  // 省略其他代码
}
</code></pre>
<p>在上述代码中，<code>setTimeout</code> 的调用就是为了将回调函数放入任务队列中，以确保在当前 JavaScript 执行栈执行完成后，回调函数才会被执行。这符合 Promise 的异步执行特性，确保了回调函数在适当的时机执行。</p>
</li>
</ul>
</li>
<li><p><strong>立刻执行函数写为箭头函数</strong></p>
<ul>
<li>​	箭头函数的一个特性是它继承了外层函数的 <code>this</code>。在 <code>new Promise</code> 的执行器函数中，<code>resolve</code> 和 <code>reject</code> 是通过函数参数传递的。使用箭头函数确保在箭头函数内部可以访问到外层函数的 <code>this</code>，也就是 <code>new Promise</code> 创建的 Promise 实例，从而可以调用 <code>resolve</code> 和 <code>reject</code> 方法。</li>
</ul>
</li>
<li><p>关于 <strong>resolve reject</strong> 的命名</p>
<ul>
<li><code>resolve</code> 和 <code>reject</code> 只是通用的命名约定，用于表示 Promise 的状态变更。实际上，你可以使用任何合法的标识符作为这两个函数的名称，只要它们在执行器函数中被正确调用就可以。</li>
</ul>
</li>
</ul>
<h5>Promise A+ 测试</h5>
<p>结果：<strong>好好好</strong></p>
<p>有专门的测试脚本可以测试所编写的代码是否符合PromiseA+的规范。</p>
<p>首先，在promise实现的代码中，增加以下代码:</p>
<pre><code class="language-js">// promise.js添加如下代码
Promise.defer = Promise.deferred = function () {
    let dfd = {};
    dfd.promise = new Promise((resolve, reject) =&gt; {
        dfd.resolve = resolve;
        dfd.reject = reject;
    });
    return dfd;
}
</code></pre>
<p>安装测试脚本:</p>
<pre><code class="language-js">npm install -g promises-aplus-tests
</code></pre>
<p>如果当前的promise源码的文件名为promise.js</p>
<p>那么在对应的目录执行以下命令:</p>
<pre><code>promises-aplus-tests promise.js
</code></pre>
<p>promises-aplus-tests中共有872条测试用例。以上代码，可以完美通过所有用例。</p>
<h4>完整代码：</h4>
<p><img src="%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3.assets/image-20231212195206737.png" alt="image-20231212195206737"></p>
<p><img src="%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3.assets/image-20231212195220765.png" alt="image-20231212195220765"></p>
<p><img src="%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3.assets/image-20231212195243979.png" alt="image-20231212195243979"></p>
<p><img src="%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3.assets/image-20231212195254930.png" alt="image-20231212195254930"></p>
<p><img src="%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3.assets/image-20231212195331292.png" alt="image-20231212195331292"></p>
<p><img src="%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3.assets/image-20231212195346444.png" alt="image-20231212195346444"></p>
<p><img src="%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3.assets/image-20231212195356912.png" alt="image-20231212195356912"></p>
<p><img src="%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3.assets/image-20231212200112771.png" alt="image-20231212200112771"></p>
<h3>异步嵌套解决方案</h3>
<pre><code>参考文献
作者：一只ice
链接：https://juejin.cn/post/7144308012952322084
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h4>Promise.defer</h4>
<p>将Promise Promise的resolve Promise的reject提升到同一层级</p>
<h4>返回Promise使用then连续调用的形式</h4>
<ul>
<li><pre><code class="language-js">function requestData(url) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      if (url.includes(&#39;iceweb&#39;)) {
        resolve(url)
      } else {
        reject(&#39;请求错误&#39;)
      }
    }, 1000);
  })
}

requestData(&#39;iceweb.io&#39;).then(res =&gt; {
  return requestData(`iceweb.org ${res}`)
}).then(res =&gt; {
  return requestData(`iceweb.com ${res}`)
}).then(res =&gt; {
  console.log(res)
})

//iceweb.com iceweb.org iceweb.io
</code></pre>
</li>
</ul>
<h4>生成器 + Promise</h4>
<ul>
<li><p>每次调用<strong>generator.next()</strong>，都会<strong>执行到对应的yield然后停止</strong></p>
</li>
<li><p>像let result = yield requestData(url); 因为是先执行右边的，有结果了再赋值给result</p>
</li>
</ul>
<p>所以第一次执行结束还没有完成赋值，也就是此时result为undefined,且每次next(arg),arg将</p>
<p>被作为上一次yield的结果</p>
<pre><code class="language-js">function* getData(url) {
  let result = yield requestData(url);
  let result2 = yield requestData(result);
  let result3 = yield requestData(result2);
  console.log(result3);
}
</code></pre>
<pre><code class="language-js">// 打印结果是一个对象：{ value: Promise { &lt;pending&gt; }, done: false }
// requestData(url)会返回一个promise,作为value的值
console.log(generator.next()); 
</code></pre>
<pre><code class="language-js">// 看着也挺抽象的
generator
    .next()
    .value.then((data) =&gt;
                generator
                .next(`iceweb.org${data}`)
                .value.then((data) =&gt;
                            generator.next(`iceweb.com${data}`).value.then((data) =&gt; generator.next(data))
                           )
               );
</code></pre>
<p>getData已经变为同步的形式，可以拿到最终的结果了。generator虽然一直在调用.next看起来似乎也产生了回调地狱，其实不用关心这个，因为它这个是有规律的，我们可以封装成一个自动化执行的函数，内部是如何调用的我们就不用关心了。</p>
<h4>自动化执行函数封装</h4>
<pre><code class="language-js">function* getData() {
  const res1 = yield requestData(&#39;iceweb.io&#39;)
  const res2 = yield requestData(`iceweb.org ${res1}`)
  const res3 = yield requestData(`iceweb.com ${res2}`)

  console.log(res3)
}
</code></pre>
<pre><code class="language-js">function asyncAutomation(genFn){
  let generator = genFn();

  const _automation = (result) =&gt; {
    let nextData = generator.next(result)
    if(nextData.done) return 
    nextData.value.then((data)=&gt;{
      _automation(data)
    })
  }

  _automation()
}

asyncAutomation(getData)
</code></pre>
<ul>
<li>利用 <strong>promise+生成器</strong> 的方式变相实现解决回调地狱问题，其实就是<code>async await</code>的一个变种而已</li>
<li>最早为 <strong>TJ</strong> 实现，<strong>前端大神人物</strong></li>
<li>async await核心代码就类似这些，内部主动帮我们调用<code>.next</code>方法</li>
</ul>
<h4>async + await</h4>
<p><strong>最终解决方案</strong></p>
<pre><code class="language-js">function requestData(url) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      if (url.includes(&#39;iceweb&#39;)) {
        resolve(url)
      } else {
        reject(&#39;请求错误&#39;)
      }
    }, 1000);
  })
}

async function getData(url){
  let result = await requestData(url)
  let result2 = await requestData(`iceweb.org${result}`)
  let result3 = await requestData(`iceweb.com${result2}`)
  console.log(result3);
}

getData(&#39;iceweb.io&#39;)
</code></pre>
<ul>
<li>哈人，只要把 <strong>自动化执行函数封装</strong> 中的getData生成器函数，改为async函数，yeild的关键</li>
</ul>
<p>字替换为await就可以实现异步代码同步写法了。</p>
<h3>async/await 剖析</h3>
<pre><code>参考文献
作者：一只ice
链接：https://juejin.cn/post/7144308012952322084
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<ul>
<li>async（异步的）</li>
<li>async 用于申明一个异步函数</li>
</ul>
<h5>async内部代码同步执行</h5>
<ul>
<li><p>异步函数的内部代码执行过程和普通的函数是一致的，默认情况下也是会被同步执行</p>
<ul>
<li><p>​	</p>
<pre><code class="language-js">async function sayHi() {
  console.log(&#39;hi ice&#39;)
}

sayHi()

//hi ice
</code></pre>
</li>
</ul>
</li>
</ul>
<h5>异步函数的返回值</h5>
<p>异步函数的返回值和普通返回值有所区别</p>
<ul>
<li>普通函数主动返回什么就返回什么，不返回为<code>undefined</code></li>
<li>异步函数的返回值特点<ul>
<li>明确有返回一个普通值，相当于<code>Promise.resolve</code>(返回值)</li>
<li>返回一个thenable对象，则与then方法中的<code>resolve</code>,或者<code>reject</code>有关</li>
<li>明确返回一个promise，则由这个promise决定</li>
</ul>
</li>
</ul>
<p>异步函数中可以使用<code>await</code>关键字，现在在全局也可以进行<code>await</code>，但是不推荐。会阻塞主进程的代码执行</p>
<h5>异步函数的异常处理</h5>
<ul>
<li>如果函数内部中途发生错误，可以通过try catch的方式捕获异常</li>
<li>如果函数内部中途发生错误，也可以通过函数的返回值.catch进行捕获</li>
</ul>
<pre><code class="language-js">async function sayHi() {
  console.log(res)
}
sayHi().catch(e =&gt; console.log(e))

//或者

async function sayHi() {
  try {
    console.log(res)
  }catch(e) {
    console.log(e)
  }
}

sayHi()

//ReferenceError: res is not defined
</code></pre>
<h5>await 关键字</h5>
<p>异步函数中可以使用<code>await</code>关键字，普通函数不行</p>
<p>await特点</p>
<ul>
<li>通常await关键字后面都是跟一个Promise<ul>
<li>可以是普通值</li>
<li>可以是thenable</li>
<li>可以是Promise主动调用<code>resolve或者reject</code></li>
</ul>
</li>
<li>这个promise状态变为fulfilled才会执行<code>await</code>后续的代码，所以<code>await</code>后面的代码，相当于包括在<code>.then</code>方法的回调中，如果状态变为rejected，你则需要在函数内部<code>try catch</code>，或者进行链式调用进行<code>.catch</code>操作</li>
</ul>
<pre><code class="language-js">function requestData(url) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      if (url.includes(&#39;iceweb&#39;)) {
        resolve(url)
      } else {
        reject(&#39;请求错误&#39;)
      }
    }, 1000);
  })
}

async function getData() {
  const res = await requestData(&#39;iceweb.io&#39;)
  console.log(res)
}

getData()

// iceweb.io
</code></pre>
<p><img src="%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3.assets/image-20231213190818377.png" alt="image-20231213190818377"></p>
<h3>Promise.resolve</h3>
<p>Promise.resolve(value) 返回一个以给定值解析后的Promise 对象.</p>
<ol>
<li>如果 value 是个 thenable 对象，返回的promise会“跟随”这个thenable的对象，采用它的最终状态</li>
<li>如果传入的value本身就是promise对象，那么Promise.resolve将不做任何修改、原封不动地返回这个promise对象。</li>
<li>其他情况，直接返回以该值为成功状态的promise对象。</li>
</ol>
<pre><code class="language-js">Promise.resolve = function (param) {
        if (param instanceof Promise) {
        return param;
    }
    return new Promise((resolve, reject) =&gt; {
        if (param &amp;&amp; typeof param === &#39;object&#39; &amp;&amp; typeof param.then === &#39;function&#39;) {
            setTimeout(() =&gt; {
                param.then(resolve, reject);
            });
        } else {
            resolve(param);
        }
    });
}
</code></pre>
<p>thenable对象的执行加 setTimeout的原因是根据原生Promise对象执行的结果推断的，如下的测试代码，原生的执行结果为: 20  400  30;为了同样的执行顺序，增加了setTimeout延时。</p>
<h3>Promise.finally</h3>
<p>不管成功还是失败，都会走到finally中,并且finally之后，还可以继续then。并且会将值原封不动的传递给后面的then.</p>
<pre><code class="language-js">Promise.prototype.finally = function (callback) {
    return this.then((value) =&gt; {
        return Promise.resolve(callback()).then(() =&gt; {
            return value;
        });
    }, (err) =&gt; {
        return Promise.resolve(callback()).then(() =&gt; {
            throw err;
        });
    });
}
</code></pre>
<h3>Promise.all</h3>
<p>Promise.all(promises) 返回一个promise对象</p>
<ol>
<li>如果传入的参数是一个空的可迭代对象，那么此promise对象回调完成(resolve),只有此情况，是同步执行的，其它都是异步返回的。</li>
<li>如果传入的参数不包含任何 promise，则返回一个异步完成.</li>
<li>promises 中所有的promise都promise都“完成”时或参数中不包含 promise 时回调完成。</li>
<li>如果参数中有一个promise失败，那么Promise.all返回的promise对象失败</li>
<li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组</li>
</ol>
<pre><code class="language-js">Promise.all = function (promises) {
    promises = Array.from(promises);//将可迭代对象转换为数组
    return new Promise((resolve, reject) =&gt; {
        let index = 0;
        let result = [];
        if (promises.length === 0) {
            resolve(result);
        } else {
            function processValue(i, data) {
                result[i] = data;
                if (++index === promises.length) {
                    resolve(result);
                }
            }
            for (let i = 0; i &lt; promises.length; i++) {
                  //promises[i] 可能是普通值
                  Promise.resolve(promises[i]).then((data) =&gt; {
                    processValue(i, data);
                }, (err) =&gt; {
                    reject(err);
                    return;
                });
            }
        }
    });
}
</code></pre>
<ul>
<li>使用计数器来解决多个异步并发的问题</li>
</ul>
<p><img src="%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3.assets/image-20231212204429560.png" alt="image-20231212204429560"></p>
<h3>面试题</h3>
<pre><code class="language-js">const promise = new Promise((resolve, reject) =&gt; {
  resolve({
    then(res, rej) {
      res(&#39;hi ice&#39;)
    }
  })
})

promise.then(res =&gt; console.log(res))

// hi ice
</code></pre>
<h2>闭包-原型与原型链</h2>
<p><img src="%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3.assets/image-20231211202014454.png" alt="image-20231211202014454"></p>
<h2>Js执行上下文</h2>
<h2>词法环境</h2>
<h2>作用域 作用域链</h2>
<h2>继承</h2>
<h1>Vue &amp; React</h1>
<h2>路由懒加载</h2>
<pre><code>参考文章
https://juejin.cn/post/7087220735063621640
https://juejin.cn/post/6844904180285456398#heading-14
</code></pre>
<h2>页面缓存</h2>
<h1>浏览器渲染原理</h1>
<h1>浏览器事件循环任务队列(异步)</h1>

</body>
</html>